1、kotlin语言和jvm虚拟机
	
		Kotlin语言             Java语言           Groovy语言
		    |                      |                  |
                    +----------------------+------------------+	  
                                          ⇩
                                       编译环节
       				          ⇩
                                       产生字节码
				          ⇩
                         JVM产生指令对，操作系统进行命令式执行

  kotlin也可以直接生成二进制代码。就是说kotlin可以通过在jvm上运行达到跨平台的能力，也可以直接生成某个平台的字节码来运行。
  
2、kotlin语言声明变量与内置数据
	源码见project/KotlinStart项目 base.MainVarTest
	
	2.1）定义一个String类型的变量
		/**
     		*  代表可读可改  变量名   变量类型    值
     		*  var           name  :  String   =  "Hello World! "
     		*/
		var name:String = "Hello World! "
	
	2.2）内置数据类型	
		String      字符串
     		Char        单字符
		Byte        字节类型
		Short       短整形
     		Boolean     true/false
     		Int         整形
     		Double      双精度小数
     		Float       单精度小数
     		List        集合
     		Set         无重复的元素集合
     		Map         键值对集合

3、kotlin语言的只读变量
	源码见project/KotlinStart项目 base.MainVarTest
	
	只读变量   变量名  变量类型     值
	val        data  : Int       =  20

4、kotlin语言的类型推断
	源码见project/KotlinStart项目 base.MainVarTest

	当定义变量时，比如：
		var name:String = "Hello World! "
		val data : Int = 20
	编译器会提示 ：Explicitly given type is redundant here，类型不需要定义，因为kotlin会根据值推导出变量类型，此时类型部分就可以不需要写了

5、编译时常量
	源码见project/KotlinStart项目 base.MainVarTest
	编译时常量只能时常用的基本数据类型：String,Int,List,Set,Map等
	val是只读变量，使用const修饰表示编译时常量
	const不适用于局部变量,因为在函数内定义一个变量的时候，就必须在运行时才能调用函数赋值，不属于编译时的范围


6、查看kotlin反编译后的字节码
	kotlin编译成字节码后可以在jvm上运行，在idea中 tools->kotlin->Show Kotlin Bytecode,可以查看字节码
	通过反编译可以大致了解没有类型的变量具体是什么类型的
	比如 : const val data2 = 100 反编译后是   public final static I data2 = 100，I 就是 int类型
	在Kotlin Bytecode中点击Decompile,可以看反编译的java代码。相对容易理解
	从反编译的类型验证，kotlin的基本类型（引用类型）， 比如Int ,Double等虽然是类，但是在编译成java字节码的时候都转化成了java基本类型，所以不用担心效率问题。

7 、kotlin语言的range表达式
	源码见project/KotlinStart项目 base.MainVarTest
	用于数字范围判断的表达式
	例如：
		 if(number in 1..200){
		     ...
       		 }
	使用关键字 in 表示 ..用于表示闭合区间 相当于 if(number >=1 and number <= 100)
	也可以结合取反符号“!” , 例如 ：if(number !in 1..100)
	
8、kotlin语言的when表达式
	源码见project/KotlinStart项目 base.MainVarTest
	when表达是类似于java 的 switch表达式，但是功能更强大
	因为是表达式，所以可以返回数据,如果使用{} ,则可以执行其他业务语句
	例1：
		val week=5
		val info = when(week){
			6->"星期六"
			7->"星期日"
			else-> {
				"工作日"
			}
		}
	此时所有返回值都是String 的，则info会自动类型推断为String类型
	
	例子2
          	val week=5
          	val info = when(week){
                 	 6->"星期六"
                  	7->"星期日"
                  	else-> {
                        	println("工作日")
                  	}
         	 }
	此时，else中的返回值不是String，info会自动推断为Any类型，Any类型类似java中的Object类型

9、kotlin语言的String 模板
	源码见project/KotlinStart项目 base.MainVarTest
	    val garden = "黄石公园"
    	    val time = 6
    	    //如果用空格隔开可以直接接如其他字符串，如果没有空格隔开就需要使用{}把变量包裹起来
	    println("今天天气很晴朗，去$garden 玩，玩了${time}个小时")
	
            val isLogin = true
            //kt的if是表达式可以更灵活的使用，java的if是语句，有局限性
            println("server response result : ${if(isLogin) "恭喜你登陆成功" else "登陆失败"}")

10、函数
	源码见project/KotlinStart项目 base.MainVarTest
	/**
 	* private : 默认是public修饰符
	* fun : 函数声明关键字
 	* method1 : 函数名
 	* age:Int,name:String  函数参数
 	* : Int ,返回类型
 	*/
	private fun method1(age:Int,name:String) : Int {
    		println("name $name , age : $age");
    		return 200
	} 

11、函数参数中的默认参数
	源码见project/KotlinStart项目 base.FunEx.kt
	private fun action3(name:String = "NoName",age:Byte = 18){
    		println("action3 name :$name , age : $age");
	}


12、具名函数参数
	源码见project/KotlinStart项目 base.FunEx.kt
	
	private fun action3(name:String = "NoName",age:Byte = 18){
                 println("action3 name :$name , age : $age");
        }
	该方法在使用具名参数调用时如：
		action3(age=11) : 此时第一个参数name会使用默认值，使用具名参数方式传参时，可以忽略顺序，只要保证所有参数都有值/默认值就行

13、Unit函数特点
	源码见project/KotlinStart项目 base.FunEx.kt
	//:Unit不写，默认也有，相当于Java中的void关键字，但是Uint实际上是一个类
	Unit比void更高级，因为void不能打印，也不能判断，Unit实际上是返回一个类对象，更有利于程序的编写
	private fun action1(name:String,age:Byte):Unit{
    		println("action1 name :$name , age : $age");
	}

14、Nothing类型特点
	源码见project/KotlinStart项目 base.FunEx.kt
	private fun show(number:Int){
   		 when(number){
        		in 0..59 -> println("不及格")
        		in 60..69 -> println("及格")
        		in 70..100 ->println("优秀")
        		else -> {
            			//TODO会返回一个Nothing类型的对象，并抛出异常，程序会终止
            			TODO("没有这种分数 $number")
        		}
    		}
	}

15、反引号中函数名的特点
	源码见project/KotlinStart项目 base.FunEx.kt
	1) 可以使用特殊符号定义方法名，比如使用中文。一般用于测试方法
		private fun `测试`(){
    			println("测试反引号函数名")
		}
	2）跟java互相调用时用到
		JavaTest.`in`()//in是java类中的方法名，但是在kt中 in 是关键字，此时为了执行调用方法，需要用``

	3) 一些核心功能的方法为了提高反编译的门槛使用特殊字符作为函数名称

16、匿名函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	//count后面可以使用匿名函数增加逻辑，it 是 每个字符，判断每个字符是否是“r”，如果是"r"才计数
    	val len2 = "Sandro".count(){
        	it == 'r'
    	}
    	println("r in Sandro is $len2");

17、匿名函数类型与隐式返回
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	//1、函数输入输出的声明 ，定一个了一个返回值是String的methodAciton函数
    	val methodAciton : ()-> String

    	//2、函数实现
    	methodAciton = {
        	val prefix = "kt_"
        	"${prefix}sandro"//最后一行的值就是返回值，匿名函数不能用return返回
    	}

    	//3、调用函数
    	println(methodAciton())

18、带参数的匿名/隐式函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	//1、定义函数的声明并直接实现,参数部分只定义类型，不定义变量名
    	val methodAction2:(Int ,String)->String = {
        	age,name-> //2、按参数类型顺序指定对应的变量名
        	"age : $age , name : $name"
    	}
    	println(methodAction2(12,"cici"));

19、匿名函数中it关键字特点
	源码见project/KotlinStart项目 base.AnonymousFun.kt
    	//匿名函数参数只有一个参数时，it就是代表这个参数的参数名称，类型会根据这个参数的类型变化
    	val methodAction3 : (Int) ->String = {
        	var result = it +1
        	"methodAction3 param is $it ,result is $result"
    	}
    	println(methodAction3(3))	

20、匿名函数的类型推断
	源码见project/KotlinStart项目 base.AnonymousFun.kt
    	//匿名函数中的类型一般不需要指定，kt可以自动推断
    	//使用自动推断，不需要用“:” ,直接 方法名={} 就可以了
    	val methodAction4 = {
        	v1:Double,v2:Int -> //方法参数定义
        	val result = v1+v2//这里会自动推导返回类型是double，不需要显示声明名返回类型了
        	result
    	}
    	println("methodAction4 ${methodAction4(3.3,5)}");


   	//这个匿名函数返回值由于无法确定是字符串还是Int，所以会统一返回一个Any类型的实例
    	val methodAction5 = {
        	number : Int ->
        	when(number){
            		6->"休息日"
            		7->"休息日"
            		in 1 .. 5 -> "工作日"
            		else -> -1
        	}
    	}
    	println("methodAction5 ${methodAction5(5)}");

21、kt中使用lamdba		
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	kt中匿名函数等价于lamdba表达式


22、使用函数A作为函数b的参数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	函数：
		/**
		 * 参数callBack是一个函数
		 * callBack函数参数是String和一个int,返回值是Unit
		 */
		private fun funWithMParam(callBack:(String,Int) -> Unit){
   			callBack("success",0);
		}	

	调用：
   		 //类似于c++的函数指针，或者java中接口回调
    		val callBack = {
        		result : String,code : Int ->
        		println("funWithMParam return result : $result , code : $code");
    		}
    		funWithMParam(callBack);	

    		//简化写法2
    		//直接使用匿名函数作为参数
    		funWithMParam("call funWithMParam 2 ", callBack = { result: String, code: Int ->
        		println("funWithMParam callBack2 result : $result , code : $code");
    		})

    		//简化写法3
    		//直接使用匿名函数作为参数 ，此时匿名函数参数是放在函数调用的后面,并包裹在{}中
    		funWithMParam("call funWithMParam 3 "){
            		result : String ,code : Int ->
        		println("funWithMParam callBack3 result : $result , code : $code");
    		}

23、函数内联
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	当函数参数中有lambda语句，可以使用内联函数（inline修饰符）对其优化，减少调用栈
	反编译class文件，可以看到如果使用lambda作为函数参数，编译成java字节码时，在调用端会调用多个对象，造成性能损耗。
	使用内联函数后相当于使用了c++的宏定义和宏替换，在编译期间将函数代码替换到调用的地方，从而减少了对象的使用
	
	/**
 	 * 使用内联函数可以提高效率
 	 */
	private inline fun funWithMParam2(msg:String,callBack:(String,Int) -> Unit){
    		println(msg);
    		callBack("funWithMParam2",1);
	}
	
24、函数引用
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	1）定义一个参数是匿名函数的内联函数
	private inline fun funWithMParam2(msg:String,callBack:(String,Int) -> Unit){
    		println(msg);
    		callBack("funWithMParam2",1);
	}

	2）实现一个函数对应callBack()参数
		private fun funWithMParam2Back(result:String,code :Int){
    		println("funWithMParam2Back result : $result , code : $code")
	}
	
	3）调用
	//使用 “::” 将funWithMParam2Back()转换成一个函数引用，作为lambda函数参数
    	funWithMParam2("call funWithMParam2",::funWithMParam2Back)	
	或者
	val obj = ::funWithMParam2Back
    	funWithMParam2("call funWithMParam2",::obj)


25、函数类型作为返回类型
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	kt支持一个函数的返回值是一个函数。在java中一般是通过返回一个接口实例来实现这样的功能

	定义：
		/**
 		* 返回一个函数类型的值
 		* showAction的参数是 String 和 Int
 		* 返回一个匿名函数
 		* 匿名函数的参数是String,返回值是String
 		*/
		private fun showAction(name:String,age:Int):(String) -> String {
    			return {
        			world : String ->
        			"name : $name , age: $age,world:$world"
    			}
		}

	调用：
   		 val obj = showAction("bob" , 18);
    		 println(obj(" is a student "));		

26、匿名函数和具名函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	1)定一个参数是函数的内联函数
		private inline fun showStudentInfo(name:String,age:Int,isMale:Boolean,callback:(String)->Unit){
    			callback("name:$name,age:$age,isMale:$isMale");
		}	
	
 	2)使用匿名函数调用这个方法，相当于java中在函数参数里直接new了一个接口对象
		 showStudentInfo("kk",28,true,callback={
       	 		//因为callback参数只有一个，所以在实现这个callback的时候不需要显式的定义一个参数，直接用$it引用这个值
       			 println("使用匿名函数 ：$it ")
    		 })
	
	3)使用具名函数调用这个方法，相当java中先实现了接口的成员变量，当调用的时候，把这个成员变量当成传参。
		//先定一个具体名函数
		private fun showStudentInfoCallBack(result:String){
   			 println("使用showStudentInfoCallBack具名函数：$result");
		}
	  调用：
		//使用具名函数showStudentInfoCallBack作为callback参数
    		//注意，使用的时候需要用 “::”把函数声明为一个函数对象才能作为参数使用
    		showStudentInfo("lily",16,false,::showStudentInfoCallBack);
	
27、kt的可空性特点
	源码见project/KotlinStart项目 base.KTnull.kt
	java在运行期间才会遇到空指针异常，kt优化了该问题，编译期间能在一定程度上减少空指针的出现

    	第一种情况：默认是不可控类型：不能随意给null
    		var name : String = "sandro"
    		//name = null , 如果手动赋null，编译其会提示：Null can not be a value of a non-null type String

    	第二种情况：使用修饰符 “？” 声明变量时指定为可空类型
    		var name2:String ?
    		name2 = null//此时就可以赋值为null了
    
28、安全调用操作符	
	源码见project/KotlinStart项目 base.KTnull.kt
		 var name3:String ? = "sandro"
   	 	//name3.capitalize()因为name3是可空类型，想要使用name3,必须给出补救措施,否则编译失败
    		name3?.capitalize()//使用修饰符"?"，如果真的是null ?后面这一段代码就不执行，从而避免空指针异常

29、使用带let的安全调用
	源码见project/KotlinStart项目 base.KTnull.kt
	
	1)判空操作
		var name4:String ?=null//定义一个可空变量		
		name4?.let {
        		//在let的代码块中 使用 it 代替 name4本身
        		//这种写法，相当于对nam4进行了判空，如果name4为空，代码块不执行
        		println(name4);
    		}
	
	2）判空赋默认值
	    	name4=""
    		var name5 = name4?.let{
        		if(it.isBlank()){//如果name没有内容
            			"default" // 返回一个新值给外部
        		}else{
            			it
        		}
    		}
    		println("name5 : $name5");

30、非空断言操作符特点
	源码见project/KotlinStart项目 base.KTnull.kt
  
     	//!!表示不管name是否为空都执行，这种情况下和java一样有可能空指针异常
     	//如果能保证name是有值的才建议使用断言，否则有空指针的风险
     	var name6:String?=""
     	var n = name6!!.capitalize()
     	println(n)30、非空断言操作符特点

31、使用if判断null值的情况
	源码见project/KotlinStart项目 base.KTnull.kt
    	//if也算是补救措施，编译器能够通过编译，这种写法和java一样
	if(name6 != null){
        	println(name6.capitalize())
    	}

32、空合并操作符
	源码见project/KotlinStart项目 base.KTnull.kt

   	 //使用?:判断变量是否为空，如果为空执行“:”后面的语句
    	var info:String? = null
    	println(info?:"sundro")

    	//let + 空合并操作符
    	println(info?.let { "[$it]" } ?: "[sandro]")	

33、异常处理和自定义异常
	源码见project/KotlinStart项目 base.KTEXception.kt
	
	//定义一个异常类继承IllegalArgumentException
	class MyException : IllegalArgumentException("没有赋值")

	//异常检查方法，如果为空抛出一个自定义异常
	private fun checkExeption(info:String?){
    		info ?: throw MyException()
	}

	调用：
    	try {
        	var info:String? = null;
        	checkExeption(info);
        	println(info!!.length);
    	}catch (e:Exception){
        	println("出现异常 $e");
    	}	

34、先决条件函数
	源码见project/KotlinStart项目 base.KTEXception.kt
    	
	//使用checkNotNull 和 requireNotNull 判空
    	var value:String?=null
    	try {
        	checkNotNull(value)
    	}catch (e:Exception){
        	println("$e");//java.lang.IllegalStateException: Required value was null.
    	}
    	try {
        	requireNotNull(value)//java.lang.IllegalArgumentException: Required value was null.
    	}catch (e:Exception){
        	println("$e");
    	}

	//Boolean变量 可以用require判断是否是false,false会抛异常
    	var b = false
    	try {
        	require(b)//java.lang.IllegalArgumentException: Required value was null.
    	}catch (e:Exception){
        	println("require exception : $e");//java.lang.IllegalArgumentException: Failed requirement.
    	}	

35、substring
	源码见project/KotlinStart项目 base.KTString.kt
	    	val indexof = INFO.indexOf('k') + 1
    		println("indexof : $indexof , substring : ${INFO.substring(0,indexof)}")
    		println("indexof : $indexof , substring : ${INFO.substring(0 until indexof)}")
	kt一般用第二种写法 ：0 until xxx,表示 0>= && <indexof


36、split操作
	源码见project/KotlinStart项目 base.KTString.kt
    	val list:List<String> = DATA.split(",")
    	println("list size ${list.size} , values : $list");//kt可以直接输出list内容
    	//kt的解构写法，最多只能赋值5个元素，从第6个开始要实现对应的接口
    	val (v1,v2,v3,v4,v5) = list
    	println("v1:$v1,v2:$v2,v3:$v3,v4:$v4,v5:$v5");

37、replace
	源码见project/KotlinStart项目 base.KTString.kt
	val pwd = "qwer1234!@#一二三"
    	println("pwd : $pwd")
    	/**
     	* 使用replace的正则表达式提取“qw34三”这5个字符，q w,替换成-，三替换单成 叁，其他替换成=，没有提取的字符不会被替换
     	*/
   	 val result = pwd.replace(Regex("[qw34三]")){
        	when(it.value){
            		"q" -> "-"
            		"w" -> "-"
            		"三" -> "叁"
            		else -> "="
        	}
    	}
    	println("result $result");	
	
38、== 与 ===
	源码见project/KotlinStart项目 base.KTString.kt

	var name = "123"
    	var name2 = "123"
    	println("name == name2 is ${name == name2}");//true,因为值相等
    	// === 是引用的比较，相当于 java中两个对象使用 ==
    	println("name === name2 is ${name === name2}");//true ,因为字符串放在字符串常量池里，此时两个变量都是这个字符串常量池中的字符串的引用

    	var name3 = "";
    	name3 += "123"
    	println("name === name3 is ${name === name3}");//false

39、字符串遍历
	源码见project/KotlinStart项目 base.KTString.kt
	var str = "abcde"
    	str.forEach {
        	println("$it")
    	}

40、数字安全转换函数
	源码见project/KotlinStart项目 base.KTString.kt
	
	val number : Int = "666".toInt()
    	println(number)

    	try {
        	val number2:Int = "666.6".toInt()//此时会抛出NumberFormatException异常
    	} catch (e: Exception) {
        	println(e.message);
    	}

    	//使用toIntOrNull,如果转换失败，会返回null，所以定义的时候需要定义为可空类型
    	//字符串转整形尽量用这个函数
    	val number3:Int? = "666.6".toIntOrNull();
    	println(number3?:"number3 is null");	

41、Double转Int与类型格式化
	源码见project/KotlinStart项目 base.MainVarTest.kt
    	println("3.99999.toInt ${3.99999.toInt()}");//向下取正
    	println("3.99999.roundToInt ${3.99999.roundToInt()}");//四舍五入

   	 //保留小数点3位
    	val r = "%.3f".format(1.234567)//返回的是字符串
    	println("r is $r");	

42、apply的内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
    
	val info = "Hello World"
    	//普通方式
    	println("info 字符串的长度是:${info.length} , 最后一个字符是：${info[info.length-1]} , 全部转成大写：${info.uppercase()}")

    	//apply方式,特点：始终返回info本身
    	val infoNew = info.apply {
        	//匿名函数，大部分情况下都会持有 it ,但是apply没有it,使用this代替，this == info本身
        	println("apply 匿名函数中的this : $this")
        	println("info 字符串的长度是:${this.length} , 最后一个字符是：${this[this.length-1]} , 全部转成大写：${this.uppercase()}")
        	//在apply匿名函数块里，this作为对象引用可以省略
        	println("info 字符串的长度是:${length} , 最后一个字符是：${this[length-1]} , 全部转成大写：${uppercase()}")
    	}
    	println("apply返回值 ：$infoNew")

    	//真正使用apply函数的写法是用来链式调用，比如新建对象，初始化操作之类，类似build模式初始化一个对象
    	info.apply {
        	println("info 字符串的长度是:${length} ")
    	}.apply {
        	println("最后一个字符是：${this[length-1]}")
    	}.apply {
        	println("全部转成大写：${uppercase()}")
    	}	

43、let 内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt

	/**
 	*let方式判断null
	*/
	private fun m3(value : String?): String {
  		return value?.let{
      			//?.let代表只有不为空的情况下才会执行let内置函数
      			"value is $it"
  		} ?:"-"//?： 当value为null的时候不执行let内置函数，此时执行?:后面的语句
	}

	/**
	 * 普通方式 对值判空，并返回
	 */
	private fun m1(value:String?): String {
    		return value ?: "-"
	}

	/**
 	* 普通方式 对值判空，并返回 简化版本
 	*/
	private fun m2(value:String?) = value?:"-"	

	调用：
    	//普通方式判断null
    	println("${m1(null)} , ${m2("hello")}")
    	//let方式判断null
    	println("${m3(null)} , ${m3("hello")}")	

44、run内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt

 	1. run返回类型根据最后一行变化而变化
 	2. 匿名函数中持有的当前对象是this,不是it
 	3. 多个run函数链式执行，可以使用匿名函数，也可以使用匿名函数
 	4.使用具名函数的时候，run和let可以互相替换
	
	定义一个具名函数
	private fun runM1(str:String):Int{
    		return str.length
	}
	
	调用：
	
    	val str = "hello world"
    	val r1 : Boolean = str.run{
        	println("当前匿名函数引用对象的值是: $this");
        	true
    	}
    	println("r1 : $r1");

    	//具名函数配合run函数
    	//第一个run函数返回int，并传递给第二个run函数，第二个run函数返回boolen值给到more5
    	str
        	.run(::runM1)
        	.run{
            		this > 5
        	}
        	.run(::println)//第三个run执行println具名函数，参数是第二个run返回的boolean值

45、with内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
 	
	1. 匿名函数中持有的当前对象是this,不是it
	2. with函数返回类型，是根据匿名函数最后一行的变化而变化
	3. 使用参数传值，例如：with(xxx){...}

	例子：
    		var str = "Hello World"

    		//具名操作
    		with(str, ::println)//println参数是一个String,此时传参就是with中的this,也就是str

    		//匿名操作
    		with(with(str){
        		length //匿名函数里，this代表str对象，并且可以省略，此时返回的是str.length 整形,并作为外层with中的参数
    		}){
        		println("str[$str] len is $this" );
    		}

46、also内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
	
	1.also 返回值是调用对象本身,和apply是一样的
	2.一般用于链式调用

    	val str = "Hello World"
    	str.also {
        	println("str : $it")
    	}.also {
        	println("str len is ${it.length}");
    	}

    	var r2:Int = 123.also{
        	println("123 + 234 = ${it + 234}");
    	}
    	println("r2 is $r2");

47、takeIf内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
	
	1.如果takeif匿名函数中返回true，则调用对象本身，否者返回null
	2.一般的用法是 takeIf + 空合并操作符

	例子：
    		val str = "success"
    		var result = str.takeIf {
        		takeIfM1("lucy",18)
    		}
    		println("result : $result")

    		result = str.takeIf { takeIfM1("lucy",0) }
    		println("result : $result")

    		println("验证结果 is ${str.takeIf { takeIfM1("lucy",0) }?:"验证失败"}")
    		println("验证结果 is ${str.takeIf { takeIfM1("lucy",18) }?:"验证失败"}")	

48、takeUnless内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
	和takeIf相反

	例子：
		private fun takeIfM1(name:String , age:Int):Boolean{
    			//kt if是表达式，代表一个值，所以可以直接return if表达式的值
    			return (age in 1..120) && name!=null
		}

		...	
		val str = "success"
   		var result = str.takeUnless{
        		takeIfM1("lucy",18)
    		}
    		println("result : $result")//返回null

    		//takeUnless一般配合空合并操作符，进行判空处理
    		val s = ""
    		val r = s.takeUnless { it.isNullOrBlank() } ?: "s 为空"
    		println(r)
		...

49、List的创建与元素获取
	源码见project/KotlinStart项目 collection.KTList.kt
	
	//List初始化
    	val names:List<String> = listOf<String>("sandro","joy","jess","ray")
    	//List初始化 简化写法 ,如果元素是多种类型，返回的list类型是 Any,相当于val namesForShort<Any> = ...
    	val namesForShort = listOf("sandro",123,"jess","ray")

    	//取值
    	println(namesForShort)//println可以直接输出所有元素
    	println("names[0] : ${names[0]}")//kt对List进行了运算符重载，可以像java数组取值一样

    	try {
        	println("${names[100]}")//使用运算符索引获取元素，有异常的风险
    	}catch (e:Exception){
        	println("names[100] error , $e")//java.lang.ArrayIndexOutOfBoundsException
    	}

    	//推荐有保护措施的取值getOrElse、getOrNull ，能够避免空指针异常 下标越界异常
    	val names100 = names.getOrElse(100){
        	//取不到值的情况下，返回一个值
        	"-"
    	}
    	println("names100 : $names100")

    	//取不到值的情况下，返回null对象,
    	val names101 = names.getOrNull(101)
    	println("names101:$names101")
    	//一般配合可空操作符使用
    	println("names102: ${names.getOrNull(101)?:"-"}")

50、可变list集合
	源码见project/KotlinStart项目 collection.KTList.kt
	可变list集合可以增删元素,使用listOf创建的List不能增删元素

	//可变list初始化,完整写法
    	val list:MutableList<String> = mutableListOf<String>("sandro","jhye","joy","jihai")
    	println(list)
    	//可变list初始化,简化写法
    	val l = mutableListOf("sandro1","jhye1","joy1","jihai1")
    	l.add("jess")
    	l.add(0,"space")
    	l.removeAt(2)
    	l.remove("sandro1")
    	println(l)

    	//不可变化集合 to 可变集合
    	val array = listOf(1,2,3,4)
    	val array2 = array.toMutableList()
    	array2.add(100)
    	println(array2)

    	//可变集合 to 不可变集合
    	val array3 = array2.toList()
    	println(array3)

51、mutator函数
	源码见project/KotlinStart项目 collection.KTList.kt
	mutator函数重载了 += -= 操作符，用来增删元素
    
	val ml = mutableListOf("sandro","joy","wang")
    	ml += "jess"
    	ml -= "sandro"

    	ml.removeIf { true } //逐个元素调用该匿名函数，返回true则删除当前元素
    	println("ml : $ml")
    	ml.add("a")
    	ml.add("b")
    	ml.add("c")
    	ml.removeIf {
        	it == "a"
    	}
    	println("ml : $ml")
    	println(ml)

52、list遍历
	源码见project/KotlinStart项目 collection.KTList.kt
	
	 val list = listOf(10,20,30,40,50)
    	//方式一 输出list详情，并不是遍历集合
    	println(list)

    	//方式二
    	for(data in list){
        	println("data : $data")
    	}

    	//方式二 元素值遍历
    	list.forEach {
        	//it = 每一个元素
        	println("foreach it : $it")
    	}

    	//方式三 元素索引遍历
    	list.forEachIndexed { index, i ->
        	//forEachIndexed 有两个回执，代表索引和值
        	println("index : $index , data : $i")
    	}

53、使用解构语法过滤元素
	源码见project/KotlinStart项目 collection.KTList.kt
	
	//基本用法
    	val list = listOf(1,2,3,4,5,6,7)
    	//v1 v2 v3 是三个不可变变量，分别赋值为list的前三个值
    	//如果list没有三个值会抛出异常java.lang.ArrayIndexOutOfBoundsException
    	//最多只能赋值给5个变量，第六个时，编译会失败：Destructuring declaration initializer of type List<Int> must have a 'component6()' function
    	val(v1,v2,v3) = list
    	println("v1:$v1 , v2:$v2 , v3:$v3 ")

    	//过滤用法
    	//"_"不是变量名，是用来过滤解构赋值的，不接受赋值
    	val(_,n2,n3) = list//这里只获取第二个和第三个值
    	println("n2:$n2,n3:$n3")

54、set的创建和元素获取
	源码见project/KotlinStart项目 collection.KTSet.kt

    	//setOf创建Set集合并初始化，Set里不会出现重复元素，重复的元素会被覆盖掉
    	val set:Set<String> = setOf("A","B","A","C")
    	println("set len : ${set.size}, set : $set");

    	//使用elementAt获取Set中的元素，如果索引大于Set的容量，会抛出越界异常
    	println("set.elementAt(0) : ${set.elementAt(0)}")

    	//Set取值时 ，使用elementAtOrElse 或者 elementAtOrNull保护，避免空指针，或者越界异常
    	println(set.elementAtOrElse(5){"当前set只有${set.size}个元素"})
    	println(set.elementAtOrNull(5)?:"当前set只有${set.size}个元素")	

55、可变Set集合
	源码见project/KotlinStart项目 collection.KTSet.kt
   	val set = mutableSetOf("A","B","C")
    	set += "D"
    	set -= "B"
    	set.add("E")
    	set.remove("A")
    	println(set)

56、集合转换与快捷函数
	源码见project/KotlinStart项目 collection.KTSet.kt	

	val list = mutableListOf(1,2,3,4,5,5,4,3,2,1)
    	println("list : $list")
    	//通过使用list转set去重
    	val set = list.toSet()
    	val newList = set.toList()
    	println("newList : $newList")

    	//list通过转Set去重的简化写法
    	println("list.toSet().toList() : ${list.toSet().toList()}")

    	//使用快捷函数去重
    	println("list.distinct():${list.distinct()}")

57、数组类型
	源码见project/KotlinStart项目 collection.KTArray.kt
 	
	kt中的各种数组类型，虽然是引用类型，背后可以编译成java基本数据类型
 	
	类型          初始化方法
 	IntArray     intArrayOf
 	DoubleArray  doubleArrayOf
 	LongArray    longArrayOf
 	ShortArray   shortArrayOf
 	ByteArray    byteArrayOf
 	FloatArray   floatArrayOf
 	BooleanArray booleanArrayOf
 	Array        arrayOf   对象数组	

	val intArray:IntArray = intArrayOf(1,2,3,4)
    	try {
        	println(intArray[100])//越界异常：java.lang.ArrayIndexOutOfBoundsException
    	}catch (e:Exception){
        	println("exception : $e");
    	}

    	//使用elementAtOrElse 或者 elementAtOrNull避免异常
    	println("intArray[100] ${intArray.elementAtOrElse(100){-1}}")
    	println("intArray[101] ${intArray.elementAtOrNull(100)}")
    	println("intArray[101] ${intArray.elementAtOrNull(100) ?:"没有100个数据"}")

    	//集合转数组
    	val listToArray:CharArray = listOf('a','b','c').toCharArray()
    	println("listToArray[1] : ${listToArray[1]}")

    	val stringArray:Array<String> = arrayOf("A","B","c")
    	println("stringArray[1] : ${stringArray[1]}");

58、Map的创建
	源码见project/KotlinStart项目 collection.KTMap.kt
    	val map1 : Map<Int,String> = mapOf<Int,String>(1 to ("sandro") , 2 to ("joy") , 3 to ("yixiong"))
    	println(map1)
    	val map2  = mapOf(Pair(1,"jhye"),Pair(2,"jihai"),Pair(3,"wentao"))
    	println(map2)

59、Map取值
	源码见project/KotlinStart项目 collection.KTMap.kt
    
	//方式1
    	println("map[1] : ${map[1]}")
    	println("map[100] : ${map[100]}")//如果找不到，返回null,不会崩溃

    	//方式2 getOrDefault 设置一个非法情况下的默认值作为参数
    	println("map[100] : ${map.getOrDefault(100,"-")}")

    	//方式3 getOrElse 通过匿名函数设置默认返回值
    	println("map[100] : ${map.getOrElse(100){"--"}}")

    	//方式4 等价于map[100]
    	println("map.get(100) : ${map.get(100)}" )

    	//方式5 这种方式如果需要捕获异常，保证调用安全
    	try{
       		println("map.get(100) : ${map.getValue(100)}" )
    	}catch (e:Exception){
        	println("map.get(100) error $e")//java.util.NoSuchElementException: Key 100 is missing in the map.
    	}

60、map遍历
	源码见project/KotlinStart项目 collection.KTMap.kt
		
    	val map = mapOf(1 to "A",2 to "B",3 to "C",4 to "D")
    	//方式一
    	map.forEach { (t, u) ->
        	println("key:$t , value:$u")
    	}

    	//方式二
    	map.forEach{
        	//it类型 Map.Entry<k,v>
        	println("k:${it.key} , v:${it.value}")
    	}

    	//方式三
    	for (entry in map) {
        	println("key:${entry.key} , value:${entry.value}")
    	}

61、可变map集合操作
	源码见project/KotlinStart项目 collection.KTMap.kt
    
	//map的增、删、改
    	val map:MutableMap<Int,String> = mutableMapOf(Pair(1,"abc"),Pair(2 , "def"),Pair(3,"ghi"))
    	map += 4 to "qwer"
    	map -= 1
    	map[5] = "asd"
    	map[2] = "aaa"
    	println(map)

    	//如果没有key对应的元素，就添加，并返回这个值,
    	val result = map.getOrPut(6){"bbb"}
    	println(map)
    	println("result : $result")
    
    	// 如果当前key对应的值存在则返回当前值，默认值不会起作用
    	val r2= map.getOrPut(2){"bbb"}
    	println(map)

62、
    println("r2 : $r2")


