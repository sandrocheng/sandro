1、kotlin语言和jvm虚拟机
	
		Kotlin语言             Java语言           Groovy语言
		    |                      |                  |
                    +----------------------+------------------+	  
                                          ⇩
                                       编译环节
       				          ⇩
                                       产生字节码
				          ⇩
                         JVM产生指令对，操作系统进行命令式执行

  kotlin也可以直接生成二进制代码。就是说kotlin可以通过在jvm上运行达到跨平台的能力，也可以直接生成某个平台的字节码来运行。
  
2、kotlin语言声明变量与内置数据
	源码见project/KotlinStart项目 base.MainVarTest
	
	2.1）定义一个String类型的变量
		/**
     		*  代表可读可改  变量名   变量类型    值
     		*  var           name  :  String   =  "Hello World! "
     		*/
		var name:String = "Hello World! "
	
	2.2）内置数据类型	
		String      字符串
     		Char        单字符
		Byte        字节类型
		Short       短整形
     		Boolean     true/false
     		Int         整形
     		Double      双精度小数
     		Float       单精度小数
     		List        集合
     		Set         无重复的元素集合
     		Map         键值对集合

3、kotlin语言的只读变量
	源码见project/KotlinStart项目 base.MainVarTest
	
	只读变量   变量名  变量类型     值
	val        data  : Int       =  20

4、kotlin语言的类型推断
	源码见project/KotlinStart项目 base.MainVarTest

	当定义变量时，比如：
		var name:String = "Hello World! "
		val data : Int = 20
	编译器会提示 ：Explicitly given type is redundant here，类型不需要定义，因为kotlin会根据值推导出变量类型，此时类型部分就可以不需要写了

5、编译时常量
	源码见project/KotlinStart项目 base.MainVarTest
	编译时常量只能时常用的基本数据类型：String,Int,List,Set,Map等
	val是只读变量，使用const修饰表示编译时常量
	const不适用于局部变量,因为在函数内定义一个变量的时候，就必须在运行时才能调用函数赋值，不属于编译时的范围


6、查看kotlin反编译后的字节码
	kotlin编译成字节码后可以在jvm上运行，在idea中 tools->kotlin->Show Kotlin Bytecode,可以查看字节码
	通过反编译可以大致了解没有类型的变量具体是什么类型的
	比如 : const val data2 = 100 反编译后是   public final static I data2 = 100，I 就是 int类型
	在Kotlin Bytecode中点击Decompile,可以看反编译的java代码。相对容易理解
	从反编译的类型验证，kotlin的基本类型（引用类型）， 比如Int ,Double等虽然是类，但是在编译成java字节码的时候都转化成了java基本类型，所以不用担心效率问题。

7 、kotlin语言的range表达式
	源码见project/KotlinStart项目 base.MainVarTest
	用于数字范围判断的表达式
	例如：
		 if(number in 1..200){
		     ...
       		 }
	使用关键字 in 表示 ..用于表示闭合区间 相当于 if(number >=1 and number <= 100)
	也可以结合取反符号“!” , 例如 ：if(number !in 1..100)
	
8、kotlin语言的when表达式
	源码见project/KotlinStart项目 base.MainVarTest
	when表达是类似于java 的 switch表达式，但是功能更强大
	因为是表达式，所以可以返回数据,如果使用{} ,则可以执行其他业务语句
	例1：
		val week=5
		val info = when(week){
			6->"星期六"
			7->"星期日"
			else-> {
				"工作日"
			}
		}
	此时所有返回值都是String 的，则info会自动类型推断为String类型
	
	例子2
          	val week=5
          	val info = when(week){
                 	 6->"星期六"
                  	7->"星期日"
                  	else-> {
                        	println("工作日")
                  	}
         	 }
	此时，else中的返回值不是String，info会自动推断为Any类型，Any类型类似java中的Object类型

9、kotlin语言的String 模板
	源码见project/KotlinStart项目 base.MainVarTest
	    val garden = "黄石公园"
    	    val time = 6
    	    //如果用空格隔开可以直接接如其他字符串，如果没有空格隔开就需要使用{}把变量包裹起来
	    println("今天天气很晴朗，去$garden 玩，玩了${time}个小时")
	
            val isLogin = true
            //kt的if是表达式可以更灵活的使用，java的if是语句，有局限性
            println("server response result : ${if(isLogin) "恭喜你登陆成功" else "登陆失败"}")

10、函数
	源码见project/KotlinStart项目 base.MainVarTest
	/**
 	* private : 默认是public修饰符
	* fun : 函数声明关键字
 	* method1 : 函数名
 	* age:Int,name:String  函数参数
 	* : Int ,返回类型
 	*/
	private fun method1(age:Int,name:String) : Int {
    		println("name $name , age : $age");
    		return 200
	} 

11、函数参数中的默认参数
	源码见project/KotlinStart项目 base.FunEx.kt
	private fun action3(name:String = "NoName",age:Byte = 18){
    		println("action3 name :$name , age : $age");
	}


12、具名函数参数
	源码见project/KotlinStart项目 base.FunEx.kt
	
	private fun action3(name:String = "NoName",age:Byte = 18){
                 println("action3 name :$name , age : $age");
        }
	该方法在使用具名参数调用时如：
		action3(age=11) : 此时第一个参数name会使用默认值，使用具名参数方式传参时，可以忽略顺序，只要保证所有参数都有值/默认值就行

13、Unit函数特点
	源码见project/KotlinStart项目 base.FunEx.kt
	//:Unit不写，默认也有，相当于Java中的void关键字，但是Uint实际上是一个类
	Unit比void更高级，因为void不能打印，也不能判断，Unit实际上是返回一个类对象，更有利于程序的编写
	private fun action1(name:String,age:Byte):Unit{
    		println("action1 name :$name , age : $age");
	}

14、Nothing类型特点
	源码见project/KotlinStart项目 base.FunEx.kt
	private fun show(number:Int){
   		 when(number){
        		in 0..59 -> println("不及格")
        		in 60..69 -> println("及格")
        		in 70..100 ->println("优秀")
        		else -> {
            			//TODO会返回一个Nothing类型的对象，并抛出异常，程序会终止
            			TODO("没有这种分数 $number")
        		}
    		}
	}

15、反引号中函数名的特点
	源码见project/KotlinStart项目 base.FunEx.kt
	1) 可以使用特殊符号定义方法名，比如使用中文。一般用于测试方法
		private fun `测试`(){
    			println("测试反引号函数名")
		}
	2）跟java互相调用时用到
		JavaTest.`in`()//in是java类中的方法名，但是在kt中 in 是关键字，此时为了执行调用方法，需要用``

	3) 一些核心功能的方法为了提高反编译的门槛使用特殊字符作为函数名称

16、匿名函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	//count后面可以使用匿名函数增加逻辑，it 是 每个字符，判断每个字符是否是“r”，如果是"r"才计数
    	val len2 = "Sandro".count(){
        	it == 'r'
    	}
    	println("r in Sandro is $len2");

17、匿名函数类型与隐式返回
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	//1、函数输入输出的声明 ，定一个了一个返回值是String的methodAciton函数
    	val methodAciton : ()-> String

    	//2、函数实现
    	methodAciton = {
        	val prefix = "kt_"
        	"${prefix}sandro"//最后一行的值就是返回值，匿名函数不能用return返回
    	}

    	//3、调用函数
    	println(methodAciton())

18、带参数的匿名/隐式函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	//1、定义函数的声明并直接实现,参数部分只定义类型，不定义变量名
    	val methodAction2:(Int ,String)->String = {
        	age,name-> //2、按参数类型顺序指定对应的变量名
        	"age : $age , name : $name"
    	}
    	println(methodAction2(12,"cici"));

19、匿名函数中it关键字特点
	源码见project/KotlinStart项目 base.AnonymousFun.kt
    	//匿名函数参数只有一个参数时，it就是代表这个参数的参数名称，类型会根据这个参数的类型变化
    	val methodAction3 : (Int) ->String = {
        	var result = it +1
        	"methodAction3 param is $it ,result is $result"
    	}
    	println(methodAction3(3))	

20、匿名函数的类型推断
	源码见project/KotlinStart项目 base.AnonymousFun.kt
    	//匿名函数中的类型一般不需要指定，kt可以自动推断
    	//使用自动推断，不需要用“:” ,直接 方法名={} 就可以了
    	val methodAction4 = {
        	v1:Double,v2:Int -> //方法参数定义
        	val result = v1+v2//这里会自动推导返回类型是double，不需要显示声明名返回类型了
        	result
    	}
    	println("methodAction4 ${methodAction4(3.3,5)}");


   	//这个匿名函数返回值由于无法确定是字符串还是Int，所以会统一返回一个Any类型的实例
    	val methodAction5 = {
        	number : Int ->
        	when(number){
            		6->"休息日"
            		7->"休息日"
            		in 1 .. 5 -> "工作日"
            		else -> -1
        	}
    	}
    	println("methodAction5 ${methodAction5(5)}");

21、kt中使用lamdba		
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	kt中匿名函数等价于lamdba表达式


22、使用函数A作为函数b的参数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	函数：
		/**
		 * 参数callBack是一个函数
		 * callBack函数参数是String和一个int,返回值是Unit
		 */
		private fun funWithMParam(callBack:(String,Int) -> Unit){
   			callBack("success",0);
		}	

	调用：
   		 //类似于c++的函数指针，或者java中接口回调
    		val callBack = {
        		result : String,code : Int ->
        		println("funWithMParam return result : $result , code : $code");
    		}
    		funWithMParam(callBack);	

    		//简化写法2
    		//直接使用匿名函数作为参数
    		funWithMParam("call funWithMParam 2 ", callBack = { result: String, code: Int ->
        		println("funWithMParam callBack2 result : $result , code : $code");
    		})

    		//简化写法3
    		//直接使用匿名函数作为参数 ，此时匿名函数参数是放在函数调用的后面,并包裹在{}中
    		funWithMParam("call funWithMParam 3 "){
            		result : String ,code : Int ->
        		println("funWithMParam callBack3 result : $result , code : $code");
    		}

23、函数内联
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	当函数参数中有lambda语句，可以使用内联函数（inline修饰符）对其优化，减少调用栈
	反编译class文件，可以看到如果使用lambda作为函数参数，编译成java字节码时，在调用端会调用多个对象，造成性能损耗。
	使用内联函数后相当于使用了c++的宏定义和宏替换，在编译期间将函数代码替换到调用的地方，从而减少了对象的使用
	
	/**
 	 * 使用内联函数可以提高效率
 	 */
	private inline fun funWithMParam2(msg:String,callBack:(String,Int) -> Unit){
    		println(msg);
    		callBack("funWithMParam2",1);
	}
	
24、函数引用
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	1）定义一个参数是匿名函数的内联函数
	private inline fun funWithMParam2(msg:String,callBack:(String,Int) -> Unit){
    		println(msg);
    		callBack("funWithMParam2",1);
	}

	2）实现一个函数对应callBack()参数
		private fun funWithMParam2Back(result:String,code :Int){
    		println("funWithMParam2Back result : $result , code : $code")
	}
	
	3）调用
	//使用 “::” 将funWithMParam2Back()转换成一个函数引用，作为lambda函数参数
    	funWithMParam2("call funWithMParam2",::funWithMParam2Back)	
	或者
	val obj = ::funWithMParam2Back
    	funWithMParam2("call funWithMParam2",::obj)


25、函数类型作为返回类型
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	kt支持一个函数的返回值是一个函数。在java中一般是通过返回一个接口实例来实现这样的功能

	定义：
		/**
 		* 返回一个函数类型的值
 		* showAction的参数是 String 和 Int
 		* 返回一个匿名函数
 		* 匿名函数的参数是String,返回值是String
 		*/
		private fun showAction(name:String,age:Int):(String) -> String {
    			return {
        			world : String ->
        			"name : $name , age: $age,world:$world"
    			}
		}

	调用：
   		 val obj = showAction("bob" , 18);
    		 println(obj(" is a student "));		

26、匿名函数和具名函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	1)定一个参数是函数的内联函数
		private inline fun showStudentInfo(name:String,age:Int,isMale:Boolean,callback:(String)->Unit){
    			callback("name:$name,age:$age,isMale:$isMale");
		}	
	
 	2)使用匿名函数调用这个方法，相当于java中在函数参数里直接new了一个接口对象
		 showStudentInfo("kk",28,true,callback={
       	 		//因为callback参数只有一个，所以在实现这个callback的时候不需要显式的定义一个参数，直接用$it引用这个值
       			 println("使用匿名函数 ：$it ")
    		 })
	
	3)使用具名函数调用这个方法，相当java中先实现了接口的成员变量，当调用的时候，把这个成员变量当成传参。
		//先定一个具体名函数
		private fun showStudentInfoCallBack(result:String){
   			 println("使用showStudentInfoCallBack具名函数：$result");
		}
	  调用：
		//使用具名函数showStudentInfoCallBack作为callback参数
    		//注意，使用的时候需要用 “::”把函数声明为一个函数对象才能作为参数使用
    		showStudentInfo("lily",16,false,::showStudentInfoCallBack);
	
27、kt的可空性特点
	源码见project/KotlinStart项目 base.KTnull.kt
	java在运行期间才会遇到空指针异常，kt优化了该问题，编译期间能在一定程度上减少空指针的出现

    	第一种情况：默认是不可控类型：不能随意给null
    		var name : String = "sandro"
    		//name = null , 如果手动赋null，编译其会提示：Null can not be a value of a non-null type String

    	第二种情况：使用修饰符 “？” 声明变量时指定为可空类型
    		var name2:String ?
    		name2 = null//此时就可以赋值为null了
    
28、安全调用操作符	
	源码见project/KotlinStart项目 base.KTnull.kt
		 var name3:String ? = "sandro"
   	 	//name3.capitalize()因为name3是可空类型，想要使用name3,必须给出补救措施,否则编译失败
    		name3?.capitalize()//使用修饰符"?"，如果真的是null ?后面这一段代码就不执行，从而避免空指针异常

29、使用带let的安全调用
	源码见project/KotlinStart项目 base.KTnull.kt
	
	1)判空操作
		var name4:String ?=null//定义一个可空变量		
		name4?.let {
        		//在let的代码块中 使用 it 代替 name4本身
        		//这种写法，相当于对nam4进行了判空，如果name4为空，代码块不执行
        		println(name4);
    		}
	
	2）判空赋默认值
	    	name4=""
    		var name5 = name4?.let{
        		if(it.isBlank()){//如果name没有内容
            			"default" // 返回一个新值给外部
        		}else{
            			it
        		}
    		}
    		println("name5 : $name5");

30、非空断言操作符特点
	源码见project/KotlinStart项目 base.KTnull.kt
  
     	//!!表示不管name是否为空都执行，这种情况下和java一样有可能空指针异常
     	//如果能保证name是有值的才建议使用断言，否则有空指针的风险
     	var name6:String?=""
     	var n = name6!!.capitalize()
     	println(n)30、非空断言操作符特点

31、使用if判断null值的情况
	源码见project/KotlinStart项目 base.KTnull.kt
    	//if也算是补救措施，编译器能够通过编译，这种写法和java一样
	if(name6 != null){
        	println(name6.capitalize())
    	}

32、空合并操作符
	源码见project/KotlinStart项目 base.KTnull.kt

   	 //使用?:判断变量是否为空，如果为空执行“:”后面的语句
    	var info:String? = null
    	println(info?:"sundro")

    	//let + 空合并操作符
    	println(info?.let { "[$it]" } ?: "[sandro]")	

33、异常处理和自定义异常
	源码见project/KotlinStart项目 base.KTEXception.kt
	
	//定义一个异常类继承IllegalArgumentException
	class MyException : IllegalArgumentException("没有赋值")

	//异常检查方法，如果为空抛出一个自定义异常
	private fun checkExeption(info:String?){
    		info ?: throw MyException()
	}

	调用：
    	try {
        	var info:String? = null;
        	checkExeption(info);
        	println(info!!.length);
    	}catch (e:Exception){
        	println("出现异常 $e");
    	}	

34、先决条件函数
	源码见project/KotlinStart项目 base.KTEXception.kt
    	
	//使用checkNotNull 和 requireNotNull 判空
    	var value:String?=null
    	try {
        	checkNotNull(value)
    	}catch (e:Exception){
        	println("$e");//java.lang.IllegalStateException: Required value was null.
    	}
    	try {
        	requireNotNull(value)//java.lang.IllegalArgumentException: Required value was null.
    	}catch (e:Exception){
        	println("$e");
    	}

	//Boolean变量 可以用require判断是否是false,false会抛异常
    	var b = false
    	try {
        	require(b)//java.lang.IllegalArgumentException: Required value was null.
    	}catch (e:Exception){
        	println("require exception : $e");//java.lang.IllegalArgumentException: Failed requirement.
    	}	

35、substring
	源码见project/KotlinStart项目 base.KTString.kt
	    	val indexof = INFO.indexOf('k') + 1
    		println("indexof : $indexof , substring : ${INFO.substring(0,indexof)}")
    		println("indexof : $indexof , substring : ${INFO.substring(0 until indexof)}")
	kt一般用第二种写法 ：0 until xxx,表示 0>= && <indexof


36、split操作
	源码见project/KotlinStart项目 base.KTString.kt
    	val list:List<String> = DATA.split(",")
    	println("list size ${list.size} , values : $list");//kt可以直接输出list内容
    	//kt的解构写法，最多只能赋值5个元素，从第6个开始要实现对应的接口
    	val (v1,v2,v3,v4,v5) = list
    	println("v1:$v1,v2:$v2,v3:$v3,v4:$v4,v5:$v5");

37、replace
	源码见project/KotlinStart项目 base.KTString.kt
	val pwd = "qwer1234!@#一二三"
    	println("pwd : $pwd")
    	/**
     	* 使用replace的正则表达式提取“qw34三”这5个字符，q w,替换成-，三替换单成 叁，其他替换成=，没有提取的字符不会被替换
     	*/
   	 val result = pwd.replace(Regex("[qw34三]")){
        	when(it.value){
            		"q" -> "-"
            		"w" -> "-"
            		"三" -> "叁"
            		else -> "="
        	}
    	}
    	println("result $result");	
	
38、== 与 ===
	源码见project/KotlinStart项目 base.KTString.kt

	var name = "123"
    	var name2 = "123"
    	println("name == name2 is ${name == name2}");//true,因为值相等
    	// === 是引用的比较，相当于 java中两个对象使用 ==
    	println("name === name2 is ${name === name2}");//true ,因为字符串放在字符串常量池里，此时两个变量都是这个字符串常量池中的字符串的引用

    	var name3 = "";
    	name3 += "123"
    	println("name === name3 is ${name === name3}");//false

39、字符串遍历
	源码见project/KotlinStart项目 base.KTString.kt
	var str = "abcde"
    	str.forEach {
        	println("$it")
    	}

40、数字安全转换函数
	源码见project/KotlinStart项目 base.KTString.kt
	
	val number : Int = "666".toInt()
    	println(number)

    	try {
        	val number2:Int = "666.6".toInt()//此时会抛出NumberFormatException异常
    	} catch (e: Exception) {
        	println(e.message);
    	}

    	//使用toIntOrNull,如果转换失败，会返回null，所以定义的时候需要定义为可空类型
    	//字符串转整形尽量用这个函数
    	val number3:Int? = "666.6".toIntOrNull();
    	println(number3?:"number3 is null");	

41、Double转Int与类型格式化
	源码见project/KotlinStart项目 base.MainVarTest.kt
    	println("3.99999.toInt ${3.99999.toInt()}");//向下取正
    	println("3.99999.roundToInt ${3.99999.roundToInt()}");//四舍五入

   	 //保留小数点3位
    	val r = "%.3f".format(1.234567)//返回的是字符串
    	println("r is $r");	

42、apply的内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
    
	val info = "Hello World"
    	//普通方式
    	println("info 字符串的长度是:${info.length} , 最后一个字符是：${info[info.length-1]} , 全部转成大写：${info.uppercase()}")

    	//apply方式,特点：始终返回info本身
    	val infoNew = info.apply {
        	//匿名函数，大部分情况下都会持有 it ,但是apply没有it,使用this代替，this == info本身
        	println("apply 匿名函数中的this : $this")
        	println("info 字符串的长度是:${this.length} , 最后一个字符是：${this[this.length-1]} , 全部转成大写：${this.uppercase()}")
        	//在apply匿名函数块里，this作为对象引用可以省略
        	println("info 字符串的长度是:${length} , 最后一个字符是：${this[length-1]} , 全部转成大写：${uppercase()}")
    	}
    	println("apply返回值 ：$infoNew")

    	//真正使用apply函数的写法是用来链式调用，比如新建对象，初始化操作之类，类似build模式初始化一个对象
    	info.apply {
        	println("info 字符串的长度是:${length} ")
    	}.apply {
        	println("最后一个字符是：${this[length-1]}")
    	}.apply {
        	println("全部转成大写：${uppercase()}")
    	}	

43、let 内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt

	/**
 	*let方式判断null
	*/
	private fun m3(value : String?): String {
  		return value?.let{
      			//?.let代表只有不为空的情况下才会执行let内置函数
      			"value is $it"
  		} ?:"-"//?： 当value为null的时候不执行let内置函数，此时执行?:后面的语句
	}

	/**
	 * 普通方式 对值判空，并返回
	 */
	private fun m1(value:String?): String {
    		return value ?: "-"
	}

	/**
 	* 普通方式 对值判空，并返回 简化版本
 	*/
	private fun m2(value:String?) = value?:"-"	

	调用：
    	//普通方式判断null
    	println("${m1(null)} , ${m2("hello")}")
    	//let方式判断null
    	println("${m3(null)} , ${m3("hello")}")	

44、run内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt

 	1. run返回类型根据最后一行变化而变化
 	2. 匿名函数中持有的当前对象是this,不是it
 	3. 多个run函数链式执行，可以使用匿名函数，也可以使用匿名函数
 	4.使用具名函数的时候，run和let可以互相替换
	
	定义一个具名函数
	private fun runM1(str:String):Int{
    		return str.length
	}
	
	调用：
	
    	val str = "hello world"
    	val r1 : Boolean = str.run{
        	println("当前匿名函数引用对象的值是: $this");
        	true
    	}
    	println("r1 : $r1");

    	//具名函数配合run函数
    	//第一个run函数返回int，并传递给第二个run函数，第二个run函数返回boolen值给到more5
    	str
        	.run(::runM1)
        	.run{
            		this > 5
        	}
        	.run(::println)//第三个run执行println具名函数，参数是第二个run返回的boolean值

45、with内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
 	
	1. 匿名函数中持有的当前对象是this,不是it
	2. with函数返回类型，是根据匿名函数最后一行的变化而变化
	3. 使用参数传值，例如：with(xxx){...}

	例子：
    		var str = "Hello World"

    		//具名操作
    		with(str, ::println)//println参数是一个String,此时传参就是with中的this,也就是str

    		//匿名操作
    		with(with(str){
        		length //匿名函数里，this代表str对象，并且可以省略，此时返回的是str.length 整形,并作为外层with中的参数
    		}){
        		println("str[$str] len is $this" );
    		}

46、also内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
	
	1.also 返回值是调用对象本身,和apply是一样的
	2.一般用于链式调用

    	val str = "Hello World"
    	str.also {
        	println("str : $it")
    	}.also {
        	println("str len is ${it.length}");
    	}

    	var r2:Int = 123.also{
        	println("123 + 234 = ${it + 234}");
    	}
    	println("r2 is $r2");

47、takeIf内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
	
	1.如果takeif匿名函数中返回true，则调用对象本身，否者返回null
	2.一般的用法是 takeIf + 空合并操作符

	例子：
    		val str = "success"
    		var result = str.takeIf {
        		takeIfM1("lucy",18)
    		}
    		println("result : $result")

    		result = str.takeIf { takeIfM1("lucy",0) }
    		println("result : $result")

    		println("验证结果 is ${str.takeIf { takeIfM1("lucy",0) }?:"验证失败"}")
    		println("验证结果 is ${str.takeIf { takeIfM1("lucy",18) }?:"验证失败"}")	

48、takeUnless内置函数
	源码见project/KotlinStart项目 base.KTBuildInFun.kt
	和takeIf相反

	例子：
		private fun takeIfM1(name:String , age:Int):Boolean{
    			//kt if是表达式，代表一个值，所以可以直接return if表达式的值
    			return (age in 1..120) && name!=null
		}

		...	
		val str = "success"
   		var result = str.takeUnless{
        		takeIfM1("lucy",18)
    		}
    		println("result : $result")//返回null

    		//takeUnless一般配合空合并操作符，进行判空处理
    		val s = ""
    		val r = s.takeUnless { it.isNullOrBlank() } ?: "s 为空"
    		println(r)
		...

49、List的创建与元素获取
	源码见project/KotlinStart项目 collection.KTList.kt
	
	//List初始化
    	val names:List<String> = listOf<String>("sandro","joy","jess","ray")
    	//List初始化 简化写法 ,如果元素是多种类型，返回的list类型是 Any,相当于val namesForShort<Any> = ...
    	val namesForShort = listOf("sandro",123,"jess","ray")

    	//取值
    	println(namesForShort)//println可以直接输出所有元素
    	println("names[0] : ${names[0]}")//kt对List进行了运算符重载，可以像java数组取值一样

    	try {
        	println("${names[100]}")//使用运算符索引获取元素，有异常的风险
    	}catch (e:Exception){
        	println("names[100] error , $e")//java.lang.ArrayIndexOutOfBoundsException
    	}

    	//推荐有保护措施的取值getOrElse、getOrNull ，能够避免空指针异常 下标越界异常
    	val names100 = names.getOrElse(100){
        	//取不到值的情况下，返回一个值
        	"-"
    	}
    	println("names100 : $names100")

    	//取不到值的情况下，返回null对象,
    	val names101 = names.getOrNull(101)
    	println("names101:$names101")
    	//一般配合可空操作符使用
    	println("names102: ${names.getOrNull(101)?:"-"}")

50、可变list集合
	源码见project/KotlinStart项目 collection.KTList.kt
	可变list集合可以增删元素,使用listOf创建的List不能增删元素

	//可变list初始化,完整写法
    	val list:MutableList<String> = mutableListOf<String>("sandro","jhye","joy","jihai")
    	println(list)
    	//可变list初始化,简化写法
    	val l = mutableListOf("sandro1","jhye1","joy1","jihai1")
    	l.add("jess")
    	l.add(0,"space")
    	l.removeAt(2)
    	l.remove("sandro1")
    	println(l)

    	//不可变化集合 to 可变集合
    	val array = listOf(1,2,3,4)
    	val array2 = array.toMutableList()
    	array2.add(100)
    	println(array2)

    	//可变集合 to 不可变集合
    	val array3 = array2.toList()
    	println(array3)

51、mutator函数
	源码见project/KotlinStart项目 collection.KTList.kt
	mutator函数重载了 += -= 操作符，用来增删元素
    
	val ml = mutableListOf("sandro","joy","wang")
    	ml += "jess"
    	ml -= "sandro"

    	ml.removeIf { true } //逐个元素调用该匿名函数，返回true则删除当前元素
    	println("ml : $ml")
    	ml.add("a")
    	ml.add("b")
    	ml.add("c")
    	ml.removeIf {
        	it == "a"
    	}
    	println("ml : $ml")
    	println(ml)

52、list遍历
	源码见project/KotlinStart项目 collection.KTList.kt
	
	 val list = listOf(10,20,30,40,50)
    	//方式一 输出list详情，并不是遍历集合
    	println(list)

    	//方式二
    	for(data in list){
        	println("data : $data")
    	}

    	//方式二 元素值遍历
    	list.forEach {
        	//it = 每一个元素
        	println("foreach it : $it")
    	}

    	//方式三 元素索引遍历
    	list.forEachIndexed { index, i ->
        	//forEachIndexed 有两个回执，代表索引和值
        	println("index : $index , data : $i")
    	}

53、使用解构语法过滤元素
	源码见project/KotlinStart项目 collection.KTList.kt
	
	//基本用法
    	val list = listOf(1,2,3,4,5,6,7)
    	//v1 v2 v3 是三个不可变变量，分别赋值为list的前三个值
    	//如果list没有三个值会抛出异常java.lang.ArrayIndexOutOfBoundsException
    	//最多只能赋值给5个变量，第六个时，编译会失败：Destructuring declaration initializer of type List<Int> must have a 'component6()' function
    	val(v1,v2,v3) = list
    	println("v1:$v1 , v2:$v2 , v3:$v3 ")

    	//过滤用法
    	//"_"不是变量名，是用来过滤解构赋值的，不接受赋值
    	val(_,n2,n3) = list//这里只获取第二个和第三个值
    	println("n2:$n2,n3:$n3")

54、set的创建和元素获取
	源码见project/KotlinStart项目 collection.KTSet.kt

    	//setOf创建Set集合并初始化，Set里不会出现重复元素，重复的元素会被覆盖掉
    	val set:Set<String> = setOf("A","B","A","C")
    	println("set len : ${set.size}, set : $set");

    	//使用elementAt获取Set中的元素，如果索引大于Set的容量，会抛出越界异常
    	println("set.elementAt(0) : ${set.elementAt(0)}")

    	//Set取值时 ，使用elementAtOrElse 或者 elementAtOrNull保护，避免空指针，或者越界异常
    	println(set.elementAtOrElse(5){"当前set只有${set.size}个元素"})
    	println(set.elementAtOrNull(5)?:"当前set只有${set.size}个元素")	

55、可变Set集合
	源码见project/KotlinStart项目 collection.KTSet.kt
   	val set = mutableSetOf("A","B","C")
    	set += "D"
    	set -= "B"
    	set.add("E")
    	set.remove("A")
    	println(set)

56、集合转换与快捷函数
	源码见project/KotlinStart项目 collection.KTSet.kt	

	val list = mutableListOf(1,2,3,4,5,5,4,3,2,1)
    	println("list : $list")
    	//通过使用list转set去重
    	val set = list.toSet()
    	val newList = set.toList()
    	println("newList : $newList")

    	//list通过转Set去重的简化写法
    	println("list.toSet().toList() : ${list.toSet().toList()}")

    	//使用快捷函数去重
    	println("list.distinct():${list.distinct()}")

57、数组类型
	源码见project/KotlinStart项目 collection.KTArray.kt
 	
	kt中的各种数组类型，虽然是引用类型，背后可以编译成java基本数据类型
 	
	类型          初始化方法
 	IntArray     intArrayOf
 	DoubleArray  doubleArrayOf
 	LongArray    longArrayOf
 	ShortArray   shortArrayOf
 	ByteArray    byteArrayOf
 	FloatArray   floatArrayOf
 	BooleanArray booleanArrayOf
 	Array        arrayOf   对象数组	

	val intArray:IntArray = intArrayOf(1,2,3,4)
    	try {
        	println(intArray[100])//越界异常：java.lang.ArrayIndexOutOfBoundsException
    	}catch (e:Exception){
        	println("exception : $e");
    	}

    	//使用elementAtOrElse 或者 elementAtOrNull避免异常
    	println("intArray[100] ${intArray.elementAtOrElse(100){-1}}")
    	println("intArray[101] ${intArray.elementAtOrNull(100)}")
    	println("intArray[101] ${intArray.elementAtOrNull(100) ?:"没有100个数据"}")

    	//集合转数组
    	val listToArray:CharArray = listOf('a','b','c').toCharArray()
    	println("listToArray[1] : ${listToArray[1]}")

    	val stringArray:Array<String> = arrayOf("A","B","c")
    	println("stringArray[1] : ${stringArray[1]}");

58、Map的创建
	源码见project/KotlinStart项目 collection.KTMap.kt
    	val map1 : Map<Int,String> = mapOf<Int,String>(1 to ("sandro") , 2 to ("joy") , 3 to ("yixiong"))
    	println(map1)
    	val map2  = mapOf(Pair(1,"jhye"),Pair(2,"jihai"),Pair(3,"wentao"))
    	println(map2)

59、Map取值
	源码见project/KotlinStart项目 collection.KTMap.kt
    
	//方式1
    	println("map[1] : ${map[1]}")
    	println("map[100] : ${map[100]}")//如果找不到，返回null,不会崩溃

    	//方式2 getOrDefault 设置一个非法情况下的默认值作为参数
    	println("map[100] : ${map.getOrDefault(100,"-")}")

    	//方式3 getOrElse 通过匿名函数设置默认返回值
    	println("map[100] : ${map.getOrElse(100){"--"}}")

    	//方式4 等价于map[100]
    	println("map.get(100) : ${map.get(100)}" )

    	//方式5 这种方式如果需要捕获异常，保证调用安全
    	try{
       		println("map.get(100) : ${map.getValue(100)}" )
    	}catch (e:Exception){
        	println("map.get(100) error $e")//java.util.NoSuchElementException: Key 100 is missing in the map.
    	}

60、map遍历
	源码见project/KotlinStart项目 collection.KTMap.kt
		
    	val map = mapOf(1 to "A",2 to "B",3 to "C",4 to "D")
    	//方式一
    	map.forEach { (t, u) ->
        	println("key:$t , value:$u")
    	}

    	//方式二
    	map.forEach{
        	//it类型 Map.Entry<k,v>
        	println("k:${it.key} , v:${it.value}")
    	}

    	//方式三
    	for (entry in map) {
        	println("key:${entry.key} , value:${entry.value}")
    	}

61、可变map集合操作
	源码见project/KotlinStart项目 collection.KTMap.kt
    
	//map的增、删、改
    	val map:MutableMap<Int,String> = mutableMapOf(Pair(1,"abc"),Pair(2 , "def"),Pair(3,"ghi"))
    	map += 4 to "qwer"
    	map -= 1
    	map[5] = "asd"
    	map[2] = "aaa"
    	println(map)

    	//如果没有key对应的元素，就添加，并返回这个值,
    	val result = map.getOrPut(6){"bbb"}
    	println(map)
    	println("result : $result")
    
    	// 如果当前key对应的值存在则返回当前值，默认值不会起作用
    	val r2= map.getOrPut(2){"bbb"}
    	println(map)
	println("r2 : $r2")//此时因为2对应的value已经存在，所以返回的还是旧值，新的bbb不会起作用

62、定义类 与 field关键字
    	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassA.kt
	
	class ClassA {
    		/**
     		* 背后实际上是定义了私有成员变量，
     		* 并定义成员变量的set get方法
     		* private String name = null
     		*/
    	var name: String? = null
    	var age = 0

    	var info = "info"
        	//这两个get set方法是针对info这个变量的隐式方法，如果只是简单的读取和设置就不需要显示的写出来
        	//field代表info这个变量，get set也是对应info这个变量
        	//写的话，编译器会提示这是多余的代码
        	//get set方法 标准写法需要再缩进一下
        	get() = field //如果变量是public的，get方法不能用private修饰
        	set(value) {  //set方法也可以通过 private set(value){} ,定义为私有方法
            		field = value
        	}

    	var word = "hello word"
        	//此时因为对get方法进行了扩展使用，这个时候编译器会认为是合理的
        	get() {
            	return field.uppercase()
        	}
        	set(value) {
            		field = "[$value]"
        	}
	}

	调用：
	    	ClassA().name = "sss"//实际上是隐式调用这个成员变量的set方法 => new ClassA().setName("sss")
    		println(ClassA().age)//实际上是隐式调用 new ClassA().getAge()

    		println("ClassA().info : ${ClassA().info}")

    		println("ClassA().word : ${ClassA().word}")

63、计算属性与防范竞态条件
    	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassA.kt
	class ClassB {
    		/**
     		* 因为是val类型的
     		* 所以对应的java代码是
     		* private int number = 0
     		* public int getNumber(){return this.number;}
     		* 不会有set方法
     		*/
    		val number:Int = 0

    		/**
     		* number2在声明的时候没有赋值，但是get函数有值返回，因此也符合kt的语法，不会编译报错
     		* 外部调用的时候 也是通过number来隐式调用到 getNumber2()这个方法
     		* 这种属性变量，就叫做计算属性，此时field就失效了，不需要使用field,也不能初始化
     		* 比如 val number2:Int = 0
     		*          get() = 5
     		*     此时会编译报错
     		*  这种情况下对应的java代码不会有 private int number2=0 这个定义
     		*  只会有 public int getNumber2(){...}这个函数
     		*/
    		val number2:Int
        	get()=(1..1000).shuffled().first()//取从1 到 1000的随机数

    		private var info:String?=null

    		/**
     		* 防范竟态条件
     		*  当调用成员时，这个成员可能为null，这个时候必须要采用防范竟态条件，这个是kt编程的规范
    		*  先使用?.also 对字符串判空，如果为空 不执行 also匿名函数
     		*  再使用?: 空合并字符，返回一个不空的值
     		*/
    		fun getShowInfo():String{
        		return info?.also {
            			"[$it]"
        		} ?: "info is null ,error"
    		}
	}	

	调用：
		println("ClassB().number : ${ClassB().number}")//实际上是new ClassB().getNumber()
    		//ClassB().number = 1 此时编译会报错，因为number 是 val 类型，不会有set函数

    		println("ClassB().number2 : ${ClassB().number2}")

    		println("ClassB().getShowInfo() ：${ClassB().getShowInfo()}")

64、主构造函数
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassC.kt

	//这个叫主构造函数，如果没有参数的化，()可以不写
	//规范的写法 一般用 _xxx来传参，这些参数实际上是临时输入类型，不能直接使用，需要手动接受成为变量才能用
	class ClassC(_name:String ,_age:Int,_isMale:Boolean) {

    		var name = _name//需要手动接受才能赋值
        		private set // set私有化简写，这样外部就不能 通过.name = "xxx"来给name赋值了
    		private val isMale = _isMale // 使用val也相当于把set私有化了，和name一样，如果是private的变量，set和get方法都会自动定义为private
    		val sex:String//使用计算属性
        		get() {
            			if(isMale){
                			return "男"
            			}
            			return "女"
        		}
    		val age = _age
        		get() {
            			if(field < 0){
                			return 0
            			}
            			return field
        		}
		}

65、主构造函数中定义属性
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassD.kt

	/**
	* 在主构造函数中直接定义成员变量,这样比较方便，比较常见的写法
 	* 相当于
 	* class ClassC(_name:String ,_age:Int,_isMale:Boolean){
 	*      var name = _name
 	*      val age = _age
 	*      val isMale=_isMale
 	* }
 	*/
	class ClassD(var name:String,val age:Int,private val isMale:Boolean ) {
    		val sex:String//使用计算属性
    			get() {
        			if(isMale){
            				return "男"
        			}
        			return "女"
    			}
	}

66、次要构造函数
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassE.kt
	
	/**
 	* 次要构造函数，完成类似java的构造函数重载
 	* 如果次要函数和主构造函数都有默认参数，实例化的时候，由于编译器无法确认用的是哪个构造函数，会优先调用主构造函数
 	*/
	class ClassE(var name:String ) {//有参数的主构造
    		var age:Int = 0
        		private set
    		private var isMale = false
    		private var info:String? = null

    		val infoMsg:String
        		get() {
            			return info?.let {
                			it
            			}?:"未赋值"
        		}


    		/**
     		* 次构造
     		* 如果主构造有参数，次构造必须要通过:this(xxx)调用父构造,否则编译失败
     		* 目的是为了构造统一管理，为了更好的初始化设计
     		*/
    		constructor(_name:String,_age:Int):this(_name){
        		this.age = _age
    		}

    		/**
     		* 这个次构造，通过this(xxx,xxx) 调用的是另一个次构造
     		* info定义了一个默认参数，如果不传值就使用这个默认值
     		*/
    		constructor(_name:String,_age:Int,_isMale:Boolean ,_info:String = "未知"):this(_name,_age){
        		this.isMale = _isMale
        		this.info = _info
    		}
	}

67、初始化块
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassF.kt
	
	/**
 	* 初始化块
 	*/
	class ClassF(_name:String?,_age:Int,_info:String?) {
    		/**
     		* 初始化块，init代码块
     		* 主构造调用的时候执行
     		*/
    		init {
        		//代码块里可以使用主构造里的临时变量
        		//可以在这里做统一的初始化工作，或者变量的校验
        		println("name:${_name},age:${_age},info:$_info")
    		}

    		/**
     		* 没有参数的次构造，次构造调用的时候会调用主构造，从而执行init代码块
     		*/
    		constructor():this(null,0,null){
        		println("次构造调用");
    		}
	}

68、构造初始化顺序
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassG.kt
	
	class ClassG (_name:String,val age:Int){//第一步 ，主构造内部属性age生成并赋值
    		//第二步，因为成员变量name在init代码块上边，所以name会先生成并赋值 ，如果name在init代码块下边，则name的生成和赋值会在init后面
    		val name = _name
    		init {//第三步，执行init代码块
        		val nameTmp = _name
        		println("init name:$name,nameTmp:$nameTmp ,age:$age");
    		}


    		constructor(_name:String,_age:Int,_isMale:Boolean):this(_name,_age){
        		//第五步，如果外部是通过次构造实例化一个对象，次构造内部代码块最后执行
        		println("次构造 name:$_name ,age:$_age ,isMale:$_isMale")
    		}
    
    		//第四步，其他写在init代码块后面的成员变量的生成和赋值或初始化
    		val list = mutableListOf<Int>()
	}

69、延迟初始化lateinit
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassH.kt

	class ClassH {
    		//延时初始化对象只能是var类型，不且不能是可空类型，否则编译失败
    		private lateinit var value: String

    		/**
     		* 模拟一个耗时操作，延时初始化 value赋值
     		*/
    		fun request(){
        		value = "success"
    		}

    		/**
     		* 由于showValue里使用了延迟加载变量，所以调用showValue前必须要先调用 request 方法加载延迟变量
     		* 否则会 报 kotlin.UninitializedPropertyAccessException: lateinit property value has not been initialized
     		*/
    		fun showValue(){
        		//如果没有初始化只要用到就报错，就算判null也不行，比如 if(value==null) ,
        		println("value : $value")
    		}

    		/**
     		* 如果想要避免延迟加载带来的错误，需要判断变量是否初始化
     		* ::value.isInitialized
     		*/
    		fun showValue2(){
        		if(::value.isInitialized){
            			println("value:$value")
        		}else{
            			println("value延迟加载，当前request方法还没有执行");
        		}
    		}
	}

70、惰性初始化
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassI.kt
	
	/**
 	* lateinit延迟加载是在使用的时候，手动加载的懒加载方式，然后再使用
 	* 惰性初始化 by lazy，是自动加载，然后再使用
 	*/
	class ClassI {

    		//不使用惰性初始化，普通方式初始化一个耗时操作的变量
    		val data:String = readbyDatabase()

    		private fun readbyDatabase(): String {
        		println("readbyDatabase....")
        		println("readbyDatabase....")
        		println("readbyDatabase....")
        		println("readbyDatabase....")
        		println("readbyDatabase....")
        		println("readbyDatabase....")
        		println("readbyDatabase....")
        		return "database load success"
    		}

    		//使用惰性加载
    		val data2 by lazy {
        		readbyDatabase()
    		}
	}

	调用：
	    	val ci = ClassI()
    		Thread.sleep(1000)
    		//从结果看实例化时候，类成员就已经加载，如果类成员是耗时的，实例化也会是耗时的
    		//没有任何懒加载的特点
    		println("not lazy load : ${ci.data}")

    		val ci2 = ClassI()
    		Thread.sleep(1000)
    		println("sleep finish")
    		//懒加载，成员变量在使用的时候才加载，否则不加载，成员变量的加载不会影响实例化的效率
    		println("lazy load : ${ci.data2}")

71、kt初始化陷阱
	源码见project/KotlinStart项目 oop.KTClass.kt、oop.classes.ClassJ.kt
	class ClassJ(_name:String) {
   		private val name = _name
    		//常见错误三：因为因为getNameStr在内部使用了 name成员变量
    		//所以getNameStr()必须写在name赋值后面，否则会空指针，这里不如java那么灵活，需要考虑到生成的java顺序
    		val nameLen:Int = getNameStr()
    		fun getNameStr(): Int {
        		return name.length
    		}


    		var number = 10
    		val info:String
    		init {
        		//常见错误一：init中使用的变量，需要放到init块之前定义，否则编译会失败：Variable cannot be initialized before declaration
        		number += 10

        		//常见问题二：java.lang.NullPointerException，要注意构造执行顺序，如果getInfoWord写在info赋值之前会空指针
        		info="hello world"
        		getInfoWord()
    		}

    		fun getInfoWord() {
        		println("info[0] : ${info[0]}");
    		}
	}

72、继承与重载
	源码见project/KotlinStart项目 oop.KTClassInherit.kt、oop.inheritClasses.BaseClass1、oop.inheritClasses.BaseClass1Sub1
	/**
	 * 所有的类默认是被final修饰的不能被继承 ，和java相反
	 * 如果要被继承需要使用 open
	 *
	 * 所有的函数默认也是final修饰的
	 * 如果要被继承需要使用open
	 */
	open class BaseClass1(var name:String, val age:Int) {

    		constructor(_name:String) : this(_name,20) {
        		name = _name
    		}

    		private fun showName() = "name :$name"

    		open fun printName() = println(showName())
	}
	
	
	/**
	 * 使用:继承类
	 * 子类使用临时变量接受name，并用父类的构造函数传值
	 * 继承的父类可以使用主构造函数，也可以使用任何次要构造函数
	 */
	class BaseClass1Sub1(tmpName:String) : BaseClass1(tmpName){

    		override fun printName() {
        		println("BaseClass1Sub1->name : ${super.name}");
    		}
	}

73、类型转换
	源码见project/KotlinStart项目 oop.KTClassInherit.kt、oop.inheritClasses.BaseClass1、oop.inheritClasses.BaseClass1Sub1
    
	val bcSub = BaseClass1Sub1("sandro")

    	//使用is判断对象类型
    	println("bcSub is BaseClass1Sub1 :  ${bcSub is BaseClass1Sub1}")//true
    	println("bcSub is BaseClass1 :  ${bcSub is BaseClass1}")//true
    	//println("bc is String :  ${bc is String}") is 用于有继承关系的类的判断，如果类型和bc可能的继承关系无关，编译器就直接能判断出来了

    	if(bcSub is BaseClass1Sub1){
        	//通过as 明确表示当前实例是子类
        	(bcSub as BaseClass1Sub1).printName()
    	}

    	if(bcSub is BaseClass1){
        	//通过as 明确当前调用是父类的方法
        	(bcSub as BaseClass1).printName()//此时父类方法被子类重写所以还是调用子类的方法了
        	(bcSub as BaseClass1).printInfo()
        	bcSub.printInfo()//因为子类可以继承父类的public方法，所以也可以直接调用父类的方法
    	}

    	val bc:BaseClass1 = BaseClass1Sub1("tony")
    	if(bc is BaseClass1Sub1){
        	//bc此时是用父类声明的，即使赋值的是子类，也无法直接调用子类方法，必须用 is 判断
        	//因为用了is判断，所以代码块里直接就转化为子类实例，并调用子类实例的方法了
        	bc.showSubInfo()
        	bc.printInfo()//子类可以直接调用父类的public方法
    	}

    	val bc2:BaseClass1 = BaseClass1Sub1("lily")
    	//这里不能直接调用子类方法，必须用as转换后才能调用
    	(bc2 as BaseClass1Sub1).showSubInfo()
    	//一旦转换后，后面就可以省略转换了，就可以直接调用了
    	bc2.showSubInfo()

74、Any超类
	源码见project/KotlinStart项目 oop.KTClassInherit.kt

	Any相当于java的Object,kt中任何类都是隐式继承这个Any超类
 	class Obj1 : Any(),一般声明的时候都省略  ":Any()",
 	Any源码里会看到，只有类和方法的声明，并没有实现，实际上kt中有各平台的实现，内部已经自动匹配到对应平台的实现类中了
	
	val bc : Any = BaseClass1Sub1("sandro")
    	println("bc.toString() : ${bc.toString()}" )//toString就是Any超类提供的

75、对象的声明
	源码见project/KotlinStart项目 oop.KTObjectiv.kt  oop.object.ObjectTest1.kt

	/**
	 * 对象的声明
	 * 单例类，只能有一个默认的空构造，不能传参数,如果设置参数会提示：Constructors are not allowed for objects
	 *
	 */
	object ObjTest1 {
    		//object的init代码块在生成java代码时，是放在一个static代码块里
    		//这里和class不一样，class中init代码块是放在 java类的构造里面
    		init {
        		println("ObjTest1 init")
    		}

    		fun show() = println("ObjTest1.show()")
	}	

	调用：
    		//objective ObjTest1即是单例实例，又是类名
    		//多次调用init块只执行了一次，返回的引用都是一个
    		println(ObjTest1)
    		println(ObjTest1)
    		ObjTest1.show()//因为是对象,所以不用实例化，直接当成变量使用

76、对象表达式
	源码见project/KotlinStart项目 oop.KTObjectiv.kt  oop.object.ExpressionClass.kt

	1)匿名对象表达式方式
    	//使用 “object :” 修饰类名， 可以直接继承出来一个匿名的子类，这个子类没有类名
    	//同时返回一个实例
    	val ec = object : ExpressionClass() {
       			override fun add(info: String) {
            		super.add(info)
            		println("------------")
        	}

        	override fun del(info: String) {
            		super.del(info)
            		println("------------")
        	}
    	}
    	ec.del("hello")
    	ec.add("world")

	2)具名对象表达式

	/**
 	* 定一个具名子类
 	*/
	class SubEC:ExpressionClass(){
    		override fun add(info: String) {
        		super.add(info)
        		println("~~~~~~~~~~")
    		}

    		override fun del(info: String) {
        		super.del(info)
        		println("~~~~~~~")
    		}
	}
	
	调用：
    		val sub = SubEC()
    		sub.add("start")
    		sub.del("end")

		
	3）接口实例化
	对于java接口实例化，可以使用 object: 对象表达式，也可以使用 lmbda简化方式
	对于kt接口实例化，只能使用object:对象表达式
	    	//对java的接口，使用对象表达式方式
    		val p3 = object : Runnable{
        			override fun run() {
            			println("java Runnable instance run ...")
        		}
   		 }
    		p3.run()

    		//对java的接口，使用lmbda表达式实例化简化写法
    		val p4 = Runnable {
        		println("java Runnable short run ... ")
    		}
    		p4.run()

    		//对kt接口只能使用对象表达式匿名实例化，不能像java接口一样使用lmbda方式实例化
    		val p5 = object : KTRunnable{
        		override fun run1() {
            			println("KTRunnable run1...")
        		}

        		override fun run2() {
            			println("KTRunnable run2...")
        		}
    		}
    		p5.run1()
    		p5.run2()

	kt接口定义：
		interface KTRunnable{
    			fun run1()
    			fun run2()
		}
	
77、伴生对象
	源码见project/KotlinStart项目 oop.KTObjectiv.kt  oop.object.CompainObjClass.kt

	/**
	 * 伴生对象
	 * 由来：在kt中是没有static静态修饰符的，伴生很大程度上和java的static差不多
	 */
	class CompainObjClass {

   		//CompainObjClass构建多少次，companion object中只有一次加载
    		companion object{
        		//相当于java中的静态变量
        		val VERSION = "1.0"

        		//相当于java 中的静态方法
        		fun SHOWINFO(){
            			println("CompainObjClass info ,version : $VERSION")
        		}
    		}
	}	

	调用：	
	   	println("verison : ${CompainObjClass.VERSION}")
    		CompainObjClass.SHOWINFO()

78、嵌套类、内部类
	源码见project/KotlinStart项目 oop.KTInnerClass.kt

	class Body(_info:String){

   		private val bodyInfo = _info

    		fun show(){
        		Heart().run()//外部类可以访问内部类
        		Foot().work()//外部类可以访问嵌套类
    		}

    		//默认情况下 内部类不能访问外部的类，需要增加inner修饰符后，才能访问外部类
    		inner class Heart{
        		fun run() = println(" $bodyInfo ,heart run")
    		}

    		//因为没有使用inner修饰符，Foot这个类实际上并不是内部类，也就无法访问外部类Body中的变量和函数
    		//这种类叫做嵌套类
    		class Foot{
        		fun work(){
            			println("Foot -> work")
        		}
    		}

    		inner class Hand{
        		inner class LeftHand{
            			//LeftHand这个类要想访问外部的变量，需要让所有的嵌套类都用inner修饰才可以
            			fun use(){
                			println(" $bodyInfo ,leftHand use")
            			}
        		}
        		
			//Hand是inner修饰，那么Hand内部的所有类都必须用inner修饰，否则编译报错
        		inner class RightHand{}
    		}
	}

	调用：
	    	 Body("sandro").show()
   		 Body("sandro").Hand().LeftHand().use()

    		//嵌套类使用
    		Body.Foot().work()

79、数据类
	源码见project/KotlinStart项目 oop.KTDataClass.kt
	/**
	 * 数据类
	 * 使用data修饰符 修饰的类
	 * 一般用于类似 java bean形式的类，比如pojo
	 * 普通类一般只会生成privte的成员变量，以及这些成员变量的set get方法
	 * 数据类还会增加更多的方法，比如解构函数，克隆函数，toString（把所有成员变量都组成一个字符串）,hashCode,equals函数
         * 
         * 默认生成的toString hashCode,equals,copy等，只负责主构造中声明的成员变量
 	 * 常用于数据封装，类似与java的 pojo
 	 * 数据类至少必须有一个参数的主构造函数
 	 * 数据类必须有 var val的参数，不能是临时变量
 	 * 数据类不能使用open abstract sealed，inner等修饰 只能用为一 data修饰class 
	 */
	data class DataBean(val name:String ,val age:Int){
	
	}

	/**
	 * 普通类
	 */
	class DataBean2(val name:String ,val age:Int){
	
	}


	调用：
    		val bean = DataBean("sandro",43)
    		val bean2 = DataBean("sandro",43)
    		println(bean)//DataBean(name=sandro, age=43)  数据类自动生成的成员字符串

    		//普通类实例，如果没有复写equals,只会使Any的 equals，hashCode不一样，所以不等
    		println("DataBean2(\"sandro\",43) == DataBean2(\"sandro\",43) :  ${DataBean2("sandro",43) == DataBean2("sandro",43)}")

    		//数据类中会自动生成equals函数，并且逐一比对成员变量的值，所以相等
    		//也就是说数据类的实例使用==时，判断的时所有数据的值是否相等
    		println("bean == bean2 : ${bean == bean2}")

80、copy函数
        源码见project/KotlinStart项目 oop.KTDataClass.kt

	data class DataBean(val name:String ,val age:Int){

    		//info不在主构造中声明，toString copy,hashCode等都不会使用这个变量
    		var info:String = ""

    		init {
        		println("主构造被调用")
    		}

    		constructor(name:String):this(name,20){
        		println("次构造被调用")
        		info = "次构造生成的内容"
    		}

    		override fun toString(): String {
        		return  "name:$name, age:$age, info:$info"
    		}
	}

	调用：
		//info不在主构造中声明，所以copy的时候没有赋值，
    		//当数据类使用copy的时候，必须要考虑到次构造生成对象的情况是否会有问题
    		val bean3 = DataBean("tony")
    		println("bean3[${bean3}]") //bean3[name:tony, age:20, info:次构造生成的内容]
    		val bean4 = bean3.copy()
    		println("bean4[${bean4}]")//bean4[name:tony, age:20, info:]

81、解构的声明
	源码见project/KotlinStart项目 oop.KTDeconstruction.kt
	
	class Student(var name:String,var age:Int){

    		//解构函数特点
    		// 使用 operator修饰
    		// 函数名以compent为前缀，从1开始，逐一顺序添加
    		// 和成员一一对应
    		operator fun component1() = name
    		operator fun component2() = age

    		override fun toString(): String {
        		return "Student[name:$name , age:$age]"
    		}
	}

	/**
 	* 数据类自动生成主构造的解构函数
 	*/
	data class Student2(var name: String, var age: Int){
    		var info="info_"

    		//次构造中新增的参数不会自动生成解构函数
    		constructor(_info:String):this("未知", 0,){
        		info = _info
    		}
	}

	调用：
    		val p = Student("lily",20)
    		val(name,age) = p //解构参数 和 component1 component2 ...一一对应
    		println(p)
    		println("普通类解构获取成员变量的值 name:$name,age:$age")

    		val p2 = Student2("lily", 20,)
    		val(_,age2) = p2//使用 _ 占位符，拒收对应的值
    		println(p2)
    		println("数据类获取成员变量的值 age2:$age2")

82、运算符重载
	源码见project/KotlinStart项目 oop.KTOperator.kt
	
	data class AddClass2(val number:Int)
	
	data class AddClass(val n1:Int,val n2:Int){

    		//kt 中运算符的重载需要使用每个符号对应的特定函数名
    		//比如 “+” 对应 plus,这里不像c++中可以直接使用符号作为函数名称
   		operator fun plus(p2:AddClass2):Int{
       			return n1 + n2 + p2.number
   		}

   		operator fun minus(p2:AddClass):Int{
       			return n1 + n2 - p2.n1 - p2.n2
   		}
	}	
	
	调用:
	    	//+号前面的类 需要实现运算符的重载，加号后面的类，通过重载函数的参数进行传递
    		println("AddClass(1,2) + AddClass2(3) = ${AddClass(1,2) + AddClass2(3)}")

    		println("AddClass(10,20) + AddClass(1,2) = ${AddClass(10,20) - AddClass(1,2)}")
    	
83、枚举
	源码见project/KotlinStart项目 oop.KTEnum.kt
	/**
	 * 在kt中枚举也是一个类
	 */
	enum class Week{
	    星期一, 星期二,星期三,星期四,星期五,星期六,星期日
	}

	调用：
	    	println(Week.星期一)

	    	//枚举的值等价于枚举本身
    		println("Week.星期一 is Week : ${Week.星期一 is Week}")//true

84、使用枚举类 定义函数
	源码见project/KotlinStart项目 oop.KTEnum.kt	

	data class BodyInfo(var info:String,var length: Int)
	/**
 	* 因为是类，所以枚举也可以有构造
 	* 并且可以把构造中的参数赋值给每一个枚举值中
 	*
 	* 每一个枚举值参数必须一致，也要要跟构造中的声明一致
 	* 构造中定义类型，值中要实例化
 	*
 	*/
	enum class EnumBody(private val bi:BodyInfo){
    		LEFT_HAND(BodyInfo("左手",80)),
    		RIGHT_HAND(BodyInfo("右手",81)),

    		LEFT_FOOT(BodyInfo("左腿",95)),
    		RIGHT_FOOT(BodyInfo("右腿",94)); //注意这里，如果后面要定义函数，最后一个枚举值后面需要用“;”

    		/**
     		* 枚举中定义的函数，使用时需要通过具体的枚举值才能调用
     		* 在函数中可以直接使用构造里定义的成员变量
     		*/
    		fun getBodyInfo(): String {
        		return "${bi.info} ，长度： ${bi.length}"
    		}

    		fun updateData( _bi:BodyInfo){
        		this.bi.info = _bi.info
        		this.bi.length = _bi.length
    		}
	}
	
	调用：
    		println("EnumBody.LEFT_FOOT.getBodyInfo() : ${EnumBody.LEFT_FOOT.getBodyInfo()}")
    		EnumBody.LEFT_FOOT.updateData(BodyInfo("left foot",96))
    		println("EnumBody.LEFT_FOOT.getBodyInfo() : ${EnumBody.LEFT_FOOT.getBodyInfo()}")

85、代数数据类型
	源码见project/KotlinStart项目 oop.KTEnum.kt
	
	enum class ExamResult{
    		A,B,C,D;
    
	}

	class Teacher(private val examResult: ExamResult){
    		fun show():String{
        		//这种使用枚举对象的方式叫做 代数数据类型
        		//代数数据类型作为when的参数时，只要列出所有枚举值，就不需要else了
        		return when(this.examResult){
            			ExamResult.A -> "优秀"
            			ExamResult.B -> "良好"
            			ExamResult.C -> "及格"
            			ExamResult.D -> "不及格"
        		}
    		}

    		fun msg() = when(this.examResult){
        		ExamResult.A -> "学习优秀，掌握所有知识"
        		ExamResult.B -> "能够顺利完成学习任务"
        		ExamResult.C -> "基本掌握"
        		ExamResult.D -> "无法顺利掌握基本知识"
    		}
	}

	调用：
		println("Teacher(ExamResult.A).show() :  ${Teacher(ExamResult.A).show()}")
    		println("Teacher(ExamResult.B).msg() :  ${Teacher(ExamResult.B).msg()}")

86、密封类
	源码见project/KotlinStart项目 oop.KTSealed.kt
	/**
	 * 密封类
	 * 成员变量 必须要继承自己
	 */
	sealed class ExamResult2{
    		//使用object，保证单例，主要用于分类
    		object A :ExamResult2()
    		object B :ExamResult2()
    		object C :ExamResult2()
    		object D :ExamResult2()

    		//使用class，说明这个成员变量是多例的，并且可以传递参数
    		class APlus(val name:String): ExamResult2() //A+
	}

	class Teacher2(private val examResult: ExamResult2){
    		fun show():String{
        		//这种使用枚举对象的方式叫做 代数数据类型
        		//代数数据类型作为when的参数时，只要列出所有枚举值，就不需要else了
        		return when(this.examResult){
            			is ExamResult2.A -> "优秀"
            			is ExamResult2.B -> "良好"
            			is ExamResult2.C -> "及格"
            			is ExamResult2.D -> "不及格"
            			is ExamResult2.APlus -> "第一名，该学生的姓名是：${this.examResult.name}"
        		}
    		}
	}

	调用：
	    	//密封类ExamResult2 中的 A B C D 由于是单例对象，所以可以直接当成变量使用
    		println(Teacher2(ExamResult2.A).show())
    		println(Teacher2(ExamResult2.B).show())
    		println(Teacher2(ExamResult2.C).show())
    		//密封类ExamResult2 中的 APlus 由于是class类，所以需要实例化，
    		println(Teacher2(ExamResult2.APlus("lily")).show())

    		//false 因为APlus是class 所以每次实例化都是独立的引用，所以两个实例对象不是一个引用
    		println(ExamResult2.APlus("lily") === ExamResult2.APlus("lily"))

    		//true A 是object单例对象，所以是同一个引用
    		println(ExamResult2.A === ExamResult2.A)

87、接口定义
	源码见project/KotlinStart项目 oop.KTInterface.kt
	
	
	/**
	 * 接口类和函数默认都是 open的，不需要显示定义
	 * 接口没有构造
	 */
	interface IUSB{
    		var usbInfo:String
    		var usbDevice:String

    		fun link():Boolean
	}

	/**
	 * 接口实现类，不仅需要重写接口的方法，还需要重写成员变量
	 * 接口实现必须要使用override修饰
	 */
	class Mouse(override var usbInfo: String):IUSB{
    		override var usbDevice: String = "mouse"
    		constructor(_usbInfo: String,_device:String):this(_usbInfo){
        		this.usbDevice = _device
    		}

    		override fun link(): Boolean {
        		println("usbInfo:$usbInfo , usbDevice:$usbDevice")
        		return !(usbInfo.isBlank() || usbDevice.isBlank())
    		}
	}

	class KeyBoard:IUSB{

    		//因为重写了get方法，而且方法中使用了field，所以必须初始化一个值，否则编译出错
    		//注意get方法里，如果想要对成员函数判断，一定要使用field，如果使用成员变量，有可能会栈溢出
    		//因为在使用成员变量的时候 实际上是调用getxxx方法，所以实际上就变成了无限的递归调用了
    		//set方法默认会有实现，如果没有特殊需求，可以不用显式实现
    		override var usbDevice: String = ""
        		get() = if (field.isNullOrBlank()) "keyboard" else field

    		override var usbInfo: String = ""
        		get() {
            			return if (field.isNullOrBlank()) "3.0" else field
        		}

    		override fun link(): Boolean {
        		println("usbInfo:$usbInfo , usbDevice:$usbDevice")
        		return !(usbInfo.isBlank() || usbDevice.isBlank())
    		}
	}

	调用:
	    	val m:IUSB = Mouse("")
    		println("mouse link : ${m.link()}")

    		val k = KeyBoard()
    		k.usbInfo = "2.0"
    		k.usbDevice = "huawei keyboard"
    		println("keyboard link : ${k.link()}")

    		println("k is IUSB : ${k is IUSB}")//true


88、接口默认实现
	源码见project/KotlinStart项目 oop.KTInterface.kt	
	/**
 	* 接口中的成员变量是无法直接赋值的，var类型的也不行
 	* 但是可以通过get机制，提供一个默认的值返回,但是该成员变量必须是val的
 	* kt中接口中的函数也可以有默认实现
 	* 
 	* 因为默认实现以后，实现类在实现的时候编译器不会提示哪些成员或者函数需要实现，可能会造成误解，一般不推荐这种方式
 	*/
	interface IUSB2{
    		val usbInfo:String
        		get()= "2.0"
    		var usbDevice:String
    
    		fun link():Boolean{
        		return false
    		}
	}

	调用：
    	val m2:IUSB2 = object :IUSB2{
        	//usbInfo在IUSB2中由于有了默认实现，所以可以不用写，如果有特殊需求，也可以重写
        	override var usbDevice: String=""
            		get() = if (field.isNullOrBlank()) "keyboard" else field

        	override fun link(): Boolean {
            		println("usbInfo:$usbInfo , usbDevice:$usbDevice")
            		return !(usbInfo.isBlank() || usbDevice.isBlank())
        	}

    	}
    	println("mouse2 link : ${m2.link()}")	

89、抽象类
	源码见project/KotlinStart项目 oop.KTAbstract.kt
	
	/**
 	* 抽象类
 	* kt的抽象类和java没有区别
 	*/
	abstract class KTAbstract {

    		abstract fun getSubData():String

    		fun onCreate() = setData(getSubData())

    		private fun setData(data:String) = println("get data : $data")
	}

	class Sub: KTAbstract() {
    		override fun getSubData(): String = "sub data"
	}
	
	调用：
		Sub().onCreate()

90、泛型的定义
	源码见project/KotlinStart项目 generic.KTgeneric.kt,generic.classes.GenericClass1
	
	/**
	 * T代表类型 types
	 * kt的泛型定义和java一样
	 */
	class GenericClass1<T>(private val obj:T) {
   		//定义一个万能输出器
    		fun show() = println("万能输出器：${obj}")
	}

	data class StudentData1(val name:String,val age:Int,val isMale:Boolean)
	data class TeacherData1(val name:String,val age:Int,val isMale:Boolean,val salary:Int)
	
	调用：
	    	val st1 = StudentData1("lily",18,false)
    		val tea2 = TeacherData1("Tony",30,true,5000)
    		GenericClass1(st1).show()
    		GenericClass1(tea2).show()
    		GenericClass1(100).show()
    		GenericClass1("data").show()

91、泛型函数
	源码见project/KotlinStart项目 generic.KTgeneric.kt,generic.classes.GenericClass1
	/**
 	* 如果isTrue 运用takeIf判断obj
 	*/
	class GenericClass2<T>(private val isTrue:Boolean,private val obj:T) {
    		fun getObj():T? = obj.takeIf { isTrue }
	}

	/**
 	* 泛型是包括null的，所以参数没有指定可空，外部传参依然可以传null
 	*/
	private fun<T> show(obj:T){
    		obj?.also {
        		println("show $it")
    		}?:println("show param is null")
	}

	调用：
		show(GenericClass2(true, 1000).getObj())

92、使用泛型实现一个类型转换功能
	源码见project/KotlinStart项目 generic.KTgeneric.kt,generic.classes.GenericClass2
	/**
 	* 如果isTrue 运用takeIf判断obj
 	*/
	class GenericClass2<T>(private val isTrue:Boolean,private val obj:T) {
    		fun getObj():T? = obj.takeIf { isTrue }
	}

	调用：
	    	val d = Data<Int>(true,123)
    		val r:String? = d.revertAction {
        		"[$it]"
    		}
    		println("revert -> $r")
    		val strD = Data<String>(true,"333")
    		var strR:Int? = strD.revertAction {
        		it.toIntOrNull()?:0+ 111
    		}
    		println("revert -> $strR")

    		val stu = Student("tony",24)
    		val tea:Teacher? = Data<Student>(true,stu).revertAction {
        		Teacher(it.name,it.age,1000)
    		}
    		println(tea)

93、泛型的类型约束
	源码见project/KotlinStart项目 generic.KTgeneric.kt
	open class GBase(private val name:String){
    		fun work(){
        		println("cur name : $name")
    		}
	}
	open class GPerson(name:String) : GBase(name=name)
	class GStu(name:String):GPerson(name = name )
	class GTeacher(name:String):GPerson(name = name)

	//限定泛型必须是GBase的子类
	private fun <T : GBase> printName(obj:T) {
    		obj.work()
	}
	
	调用:
	    	val base = GBase("base")
    		val person = GPerson("person")
    		val stu = GStu("student")
    		val tea = GTeacher("teacher")
    		printName(base)
    		printName(person)
    		printName(stu)
    		printName(tea)	

94、动态参数 vararg
	源码见project/KotlinStart项目 generic.KTVararg.kt

	//vararg:多个动态参数
	//isMulti ： true代表是有多个类型
	class VarargClass<T>(vararg objs: T, val isMulti:Boolean){
    		//必须要使用out修饰泛型类型，代表只能泛型T一旦传入后 就只能读取不能修改
    		private val objArray : Array<out T> = objs

    		fun showIndexData(index : Int): T? {
        		val data = objArray.elementAtOrNull(index)

        		if(this.isMulti){
            			data?.let {
                			println("cur data is ${data.javaClass}")
            			}
        		}
        		return data
    		}

    		fun <K> revertObj(index:Int,action:(T?) -> K) = action(objArray.elementAtOrNull(index))
	}

	调用：
    		//如果动态参数只有一种类型，可以手动写上类型,比如：val b:VarargClass<Int> = VarargClass(1,2,3, isMulti =true)
    		//但是当参数的类型很复杂有String,double,char等，所以这里p对象的类型泛型是非常复杂的,
    		//实际上是{Comparable<*>&java.io.Serializable}，kt语法不支持在这里使用这种类型的写法，
    		//所以要么使用自动推导类型的方式定义变量，要么使用Any来指定泛型，如果参数里有null,则需要用Any?来指定泛型 例如 val p:VarargClass<Any?>
    		//另外动态参数是可以传值null的，所以要注意判空的使用
    		val p = VarargClass("1",2,3.3f,4.4444444444,false,'A',null, isMulti =true)
    		println("p.showIndexData(0) : ${p.showIndexData(0)}")
    		println("p.showIndexData(1) : ${p.showIndexData(1)}")
    		println("p.showIndexData(2) : ${p.showIndexData(2)}")
    		val x = p.revertObj(6){
        		"{$it}"
    		}

    		x?.let { println("x is $x") }

    		val p2:VarargClass<String?> = VarargClass("1",null, isMulti =true)
    		val p3:VarargClass<String> = VarargClass("1","2", isMulti =true)
    		val p4:VarargClass<Any?> = VarargClass("1","2",4,null, isMulti =true)
    		val p5:VarargClass<Any> = VarargClass("1","2",4, isMulti =true)

    		val s = p5.revertObj(1){
        		it.toString()
    		}
    		println(s)

95、泛型的[]操作符重载
	源码见project/KotlinStart项目 generic.KTBracket.kt
	/**
 	* 重载[]运算符
 	*/
	class BracketClass<T > (vararg objs:T){
    		private val dataArray:Array<out T> = objs

    		//默认get方法可以用[]读值
    		operator fun get(index:Int):T? =  dataArray.getOrNull(index)

	调用：
    		val p = BracketClass("1",2,3.3f,true,null)
    		for(i in 0..5){
        		val data = p[i]
        		data?.let {
            			println("$i : ${data} is ${data.javaClass}")
        		}?:println("取值失败")
    		}

    		println("------")
    		val p2:BracketClass<String?> = BracketClass("A","B","C","D",null)
    		for(i in 0..5){
        		val data = p2[i]
        		data?.let {
            			println("$i : ${data} is ${data.javaClass}")
        		}?:println("取值失败")
    		}
	}

96、out-协变 、in-逆变
	源码见project/KotlinStart项目 generic.KTOutAndIn.kt
	协变，父类（泛型声明处）接收子类（泛型具体处）的赋值 父类=子类
	逆变，子类（泛型声明处）接收父类（泛型具体处）的赋值 子类=父类
	

	/**
	 * 声明处泛型使用in修饰，这种写法java是不支持的，？extends xxx,是部分能放到类声明里
	 * 当前类里面所有成员函数根泛型相关的只能修改，不能读取
	 */
	class SetClass<in T>( _data:T){
    		private val data = _data//因为使用in来修饰反省了，所以必须用private，否则get方法会返回，导致编译处辍
    
   		 fun set1(item:T){
        		println("set1 : $item")
    		}
    
    		//Type parameter T is declared as 'in' but occurs in 'out' position in type T
    		//在in 声明的类里面，所有成员函数都无法返回根泛型相关的值
		//fun get1item():T{ return data}
	}

	/**
	 * 声明处泛型使用out修饰，
	 * 当前类里面所有成员函数根泛型相关的只能读取，不能修改
	 */
	class GetClass<out T>(_data:T){
   		val  data = _data//因为不能让外部修改，所以这里需要用val，或者private var
    		//Type parameter T is declared as 'out' but occurs in 'in' position in type T
   		//不能让外界修改，编译失败
		//fun set1(item:T) = println("set1 : $item")

   	 	fun get1item():T{ return data}
	}
		
97、reified
	源码见project/KotlinStart项目 generic.KTReified.kt

	data class ObjectClass1(val name:String,val age:Int,val info:String)
	data class ObjectClass2(val name:String,val age:Int,val info:String)
	data class ObjectClass3(val name:String,val age:Int,val info:String)

	//所有功能写在函数上
	class Manager{
    		/**
    		* 默认随机输出一个对象，如果此对象和用户指定的对象不一致，我么就启用备用对象
     		* reified一般用在方法的泛型声明，使用reified的泛型可以通过as is 来比较当前对象的类和泛型声明的类
     		* 使用reified的函数，需要声明为 inline函数
     		*/
    		inline fun<reified T> randomOrDefault() : T?{
        		val list:List<Any> = listOf(ObjectClass1("sandro",43,"working"),
            			ObjectClass2("tony",12,"playing"),
            			ObjectClass3("cici",22,"studying"))

        		val obj:Any = list.shuffled().first()
        		println("get random obj : $obj, class : ${obj.javaClass}" )

        		//注意这里要返回 T？,因为takeIf(false)会返回null ,然后再返回 null as T? 才可以，
        		// null as T 会抛异常 null cannot be cast to non-null type generic.ObjectClass1
        		// null必须要转化为可空类型才行
        		return obj.takeIf { it is T } as T?
    		}
	}

	调用：
	    	val data:ObjectClass1? = Manager().randomOrDefault<ObjectClass1>()
    		println("get data : ${data}")
	


