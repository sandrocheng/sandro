1、kotlin语言和jvm虚拟机
	
		Kotlin语言             Java语言           Groovy语言
		    |                      |                  |
                    +----------------------+------------------+	  
                                          ⇩
                                       编译环节
       				          ⇩
                                       产生字节码
				          ⇩
                         JVM产生指令对，操作系统进行命令式执行

  kotlin也可以直接生成二进制代码。就是说kotlin可以通过在jvm上运行达到跨平台的能力，也可以直接生成某个平台的字节码来运行。
  
2、kotlin语言声明变量与内置数据
	源码见project/KotlinStart项目 base.MainVarTest
	
	2.1）定义一个String类型的变量
		/**
     		*  代表可读可改  变量名   变量类型    值
     		*  var           name  :  String   =  "Hello World! "
     		*/
		var name:String = "Hello World! "
	
	2.2）内置数据类型	
		String      字符串
     		Char        单字符
		Byte        字节类型
		Short       短整形
     		Boolean     true/false
     		Int         整形
     		Double      双精度小数
     		Float       单精度小数
     		List        集合
     		Set         无重复的元素集合
     		Map         键值对集合

3、kotlin语言的只读变量
	源码见project/KotlinStart项目 base.MainVarTest
	
	只读变量   变量名  变量类型     值
	val        data  : Int       =  20

4、kotlin语言的类型推断
	源码见project/KotlinStart项目 base.MainVarTest

	当定义变量时，比如：
		var name:String = "Hello World! "
		val data : Int = 20
	编译器会提示 ：Explicitly given type is redundant here，类型不需要定义，因为kotlin会根据值推导出变量类型，此时类型部分就可以不需要写了

5、编译时常量
	源码见project/KotlinStart项目 base.MainVarTest
	编译时常量只能时常用的基本数据类型：String,Int,List,Set,Map等
	val是只读变量，使用const修饰表示编译时常量
	const不适用于局部变量,因为在函数内定义一个变量的时候，就必须在运行时才能调用函数赋值，不属于编译时的范围


6、查看kotlin反编译后的字节码
	kotlin编译成字节码后可以在jvm上运行，在idea中 tools->kotlin->Show Kotlin Bytecode,可以查看字节码
	通过反编译可以大致了解没有类型的变量具体是什么类型的
	比如 : const val data2 = 100 反编译后是   public final static I data2 = 100，I 就是 int类型
	在Kotlin Bytecode中点击Decompile,可以看反编译的java代码。相对容易理解
	从反编译的类型验证，kotlin的基本类型（引用类型）， 比如Int ,Double等虽然是类，但是在编译成java字节码的时候都转化成了java基本类型，所以不用担心效率问题。

7 、kotlin语言的range表达式
	源码见project/KotlinStart项目 base.MainVarTest
	用于数字范围判断的表达式
	例如：
		 if(number in 1..200){
		     ...
       		 }
	使用关键字 in 表示 ..用于表示闭合区间 相当于 if(number >=1 and number <= 100)
	也可以结合取反符号“!” , 例如 ：if(number !in 1..100)
	
8、kotlin语言的when表达式
	源码见project/KotlinStart项目 base.MainVarTest
	when表达是类似于java 的 switch表达式，但是功能更强大
	因为是表达式，所以可以返回数据,如果使用{} ,则可以执行其他业务语句
	例1：
		val week=5
		val info = when(week){
			6->"星期六"
			7->"星期日"
			else-> {
				"工作日"
			}
		}
	此时所有返回值都是String 的，则info会自动类型推断为String类型
	
	例子2
          	val week=5
          	val info = when(week){
                 	 6->"星期六"
                  	7->"星期日"
                  	else-> {
                        	println("工作日")
                  	}
         	 }
	此时，else中的返回值不是String，info会自动推断为Any类型，Any类型类似java中的Object类型

9、kotlin语言的String 模板
	源码见project/KotlinStart项目 base.MainVarTest
	    val garden = "黄石公园"
    	    val time = 6
    	    //如果用空格隔开可以直接接如其他字符串，如果没有空格隔开就需要使用{}把变量包裹起来
	    println("今天天气很晴朗，去$garden 玩，玩了${time}个小时")
	
            val isLogin = true
            //kt的if是表达式可以更灵活的使用，java的if是语句，有局限性
            println("server response result : ${if(isLogin) "恭喜你登陆成功" else "登陆失败"}")

10、函数
	源码见project/KotlinStart项目 base.MainVarTest
	/**
 	* private : 默认是public修饰符
	* fun : 函数声明关键字
 	* method1 : 函数名
 	* age:Int,name:String  函数参数
 	* : Int ,返回类型
 	*/
	private fun method1(age:Int,name:String) : Int {
    		println("name $name , age : $age");
    		return 200
	} 

11、函数参数中的默认参数
	源码见project/KotlinStart项目 base.FunEx.kt
	private fun action3(name:String = "NoName",age:Byte = 18){
    		println("action3 name :$name , age : $age");
	}


12、具名函数参数
	源码见project/KotlinStart项目 base.FunEx.kt
	
	private fun action3(name:String = "NoName",age:Byte = 18){
                 println("action3 name :$name , age : $age");
        }
	该方法在使用具名参数调用时如：
		action3(age=11) : 此时第一个参数name会使用默认值，使用具名参数方式传参时，可以忽略顺序，只要保证所有参数都有值/默认值就行

13、Unit函数特点
	源码见project/KotlinStart项目 base.FunEx.kt
	//:Unit不写，默认也有，相当于Java中的void关键字，但是Uint实际上是一个类
	Unit比void更高级，因为void不能打印，也不能判断，Unit实际上是返回一个类对象，更有利于程序的编写
	private fun action1(name:String,age:Byte):Unit{
    		println("action1 name :$name , age : $age");
	}

14、Nothing类型特点
	源码见project/KotlinStart项目 base.FunEx.kt
	private fun show(number:Int){
   		 when(number){
        		in 0..59 -> println("不及格")
        		in 60..69 -> println("及格")
        		in 70..100 ->println("优秀")
        		else -> {
            			//TODO会返回一个Nothing类型的对象，并抛出异常，程序会终止
            			TODO("没有这种分数 $number")
        		}
    		}
	}

15、反引号中函数名的特点
	源码见project/KotlinStart项目 base.FunEx.kt
	1) 可以使用特殊符号定义方法名，比如使用中文。一般用于测试方法
		private fun `测试`(){
    			println("测试反引号函数名")
		}
	2）跟java互相调用时用到
		JavaTest.`in`()//in是java类中的方法名，但是在kt中 in 是关键字，此时为了执行调用方法，需要用``

	3) 一些核心功能的方法为了提高反编译的门槛使用特殊字符作为函数名称

16、匿名函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	//count后面可以使用匿名函数增加逻辑，it 是 每个字符，判断每个字符是否是“r”，如果是"r"才计数
    	val len2 = "Sandro".count(){
        	it == 'r'
    	}
    	println("r in Sandro is $len2");

17、匿名函数类型与隐式返回
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	//1、函数输入输出的声明 ，定一个了一个返回值是String的methodAciton函数
    	val methodAciton : ()-> String

    	//2、函数实现
    	methodAciton = {
        	val prefix = "kt_"
        	"${prefix}sandro"//最后一行的值就是返回值，匿名函数不能用return返回
    	}

    	//3、调用函数
    	println(methodAciton())

18、带参数的匿名/隐式函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	//1、定义函数的声明并直接实现,参数部分只定义类型，不定义变量名
    	val methodAction2:(Int ,String)->String = {
        	age,name-> //2、按参数类型顺序指定对应的变量名
        	"age : $age , name : $name"
    	}
    	println(methodAction2(12,"cici"));

19、匿名函数中it关键字特点
	源码见project/KotlinStart项目 base.AnonymousFun.kt
    	//匿名函数参数只有一个参数时，it就是代表这个参数的参数名称，类型会根据这个参数的类型变化
    	val methodAction3 : (Int) ->String = {
        	var result = it +1
        	"methodAction3 param is $it ,result is $result"
    	}
    	println(methodAction3(3))	

20、匿名函数的类型推断
	源码见project/KotlinStart项目 base.AnonymousFun.kt
    	//匿名函数中的类型一般不需要指定，kt可以自动推断
    	//使用自动推断，不需要用“:” ,直接 方法名={} 就可以了
    	val methodAction4 = {
        	v1:Double,v2:Int -> //方法参数定义
        	val result = v1+v2//这里会自动推导返回类型是double，不需要显示声明名返回类型了
        	result
    	}
    	println("methodAction4 ${methodAction4(3.3,5)}");


   	//这个匿名函数返回值由于无法确定是字符串还是Int，所以会统一返回一个Any类型的实例
    	val methodAction5 = {
        	number : Int ->
        	when(number){
            		6->"休息日"
            		7->"休息日"
            		in 1 .. 5 -> "工作日"
            		else -> -1
        	}
    	}
    	println("methodAction5 ${methodAction5(5)}");

21、kt中使用lamdba		
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	kt中匿名函数等价于lamdba表达式


22、使用函数A作为函数b的参数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	函数：
		/**
		 * 参数callBack是一个函数
		 * callBack函数参数是String和一个int,返回值是Unit
		 */
		private fun funWithMParam(callBack:(String,Int) -> Unit){
   			callBack("success",0);
		}	

	调用：
   		 //类似于c++的函数指针，或者java中接口回调
    		val callBack = {
        		result : String,code : Int ->
        		println("funWithMParam return result : $result , code : $code");
    		}
    		funWithMParam(callBack);	

    		//简化写法2
    		//直接使用匿名函数作为参数
    		funWithMParam("call funWithMParam 2 ", callBack = { result: String, code: Int ->
        		println("funWithMParam callBack2 result : $result , code : $code");
    		})

    		//简化写法3
    		//直接使用匿名函数作为参数 ，此时匿名函数参数是放在函数调用的后面,并包裹在{}中
    		funWithMParam("call funWithMParam 3 "){
            		result : String ,code : Int ->
        		println("funWithMParam callBack3 result : $result , code : $code");
    		}

23、函数内联
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	当函数参数中有lambda语句，可以使用内联函数（inline修饰符）对其优化，减少调用栈
	反编译class文件，可以看到如果使用lambda作为函数参数，编译成java字节码时，在调用端会调用多个对象，造成性能损耗。
	使用内联函数后相当于使用了c++的宏定义和宏替换，在编译期间将函数代码替换到调用的地方，从而减少了对象的使用
	
	/**
 	 * 使用内联函数可以提高效率
 	 */
	private inline fun funWithMParam2(msg:String,callBack:(String,Int) -> Unit){
    		println(msg);
    		callBack("funWithMParam2",1);
	}
	
24、函数引用
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	1）定义一个参数是匿名函数的内联函数
	private inline fun funWithMParam2(msg:String,callBack:(String,Int) -> Unit){
    		println(msg);
    		callBack("funWithMParam2",1);
	}

	2）实现一个函数对应callBack()参数
		private fun funWithMParam2Back(result:String,code :Int){
    		println("funWithMParam2Back result : $result , code : $code")
	}
	
	3）调用
	//使用 “::” 将funWithMParam2Back()转换成一个函数引用，作为lambda函数参数
    	funWithMParam2("call funWithMParam2",::funWithMParam2Back)	
	或者
	val obj = ::funWithMParam2Back
    	funWithMParam2("call funWithMParam2",::obj)


25、函数类型作为返回类型
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	kt支持一个函数的返回值是一个函数。在java中一般是通过返回一个接口实例来实现这样的功能

	定义：
		/**
 		* 返回一个函数类型的值
 		* showAction的参数是 String 和 Int
 		* 返回一个匿名函数
 		* 匿名函数的参数是String,返回值是String
 		*/
		private fun showAction(name:String,age:Int):(String) -> String {
    			return {
        			world : String ->
        			"name : $name , age: $age,world:$world"
    			}
		}

	调用：
   		 val obj = showAction("bob" , 18);
    		 println(obj(" is a student "));		

26、匿名函数和具名函数
	源码见project/KotlinStart项目 base.AnonymousFun.kt
	
	1)定一个参数是函数的内联函数
		private inline fun showStudentInfo(name:String,age:Int,isMale:Boolean,callback:(String)->Unit){
    			callback("name:$name,age:$age,isMale:$isMale");
		}	
	
 	2)使用匿名函数调用这个方法，相当于java中在函数参数里直接new了一个接口对象
		 showStudentInfo("kk",28,true,callback={
       	 		//因为callback参数只有一个，所以在实现这个callback的时候不需要显式的定义一个参数，直接用$it引用这个值
       			 println("使用匿名函数 ：$it ")
    		 })
	
	3)使用具名函数调用这个方法，相当java中先实现了接口的成员变量，当调用的时候，把这个成员变量当成传参。
		//先定一个具体名函数
		private fun showStudentInfoCallBack(result:String){
   			 println("使用showStudentInfoCallBack具名函数：$result");
		}
	  调用：
		//使用具名函数showStudentInfoCallBack作为callback参数
    		//注意，使用的时候需要用 “::”把函数声明为一个函数对象才能作为参数使用
    		showStudentInfo("lily",16,false,::showStudentInfoCallBack);
	
27、kt的可空性特点
	源码见project/KotlinStart项目 base.KTnull.kt
	java在运行期间才会遇到空指针异常，kt优化了该问题，编译期间能在一定程度上减少空指针的出现

    	第一种情况：默认是不可控类型：不能随意给null
    		var name : String = "sandro"
    		//name = null , 如果手动赋null，编译其会提示：Null can not be a value of a non-null type String

    	第二种情况：使用修饰符 “？” 声明变量时指定为可空类型
    		var name2:String ?
    		name2 = null//此时就可以赋值为null了
    
28、安全调用操作符	
	源码见project/KotlinStart项目 base.KTnull.kt
		 var name3:String ? = "sandro"
   	 	//name3.capitalize()因为name3是可空类型，想要使用name3,必须给出补救措施,否则编译失败
    		name3?.capitalize()//使用修饰符"?"，如果真的是null ?后面这一段代码就不执行，从而避免空指针异常

29、使用带let的安全调用
	源码见project/KotlinStart项目 base.KTnull.kt
	
	1)判空操作
		var name4:String ?=null//定义一个可空变量		
		name4?.let {
        		//在let的代码块中 使用 it 代替 name4本身
        		//这种写法，相当于对nam4进行了判空，如果name4为空，代码块不执行
        		println(name4);
    		}
	
	2）判空赋默认值
	    	name4=""
    		var name5 = name4?.let{
        		if(it.isBlank()){//如果name没有内容
            			"default" // 返回一个新值给外部
        		}else{
            			it
        		}
    		}
    		println("name5 : $name5");

30、非空断言操作符特点
	源码见project/KotlinStart项目 base.KTnull.kt
  
     	//!!表示不管name是否为空都执行，这种情况下和java一样有可能空指针异常
     	//如果能保证name是有值的才建议使用断言，否则有空指针的风险
     	var name6:String?=""
     	var n = name6!!.capitalize()
     	println(n)30、非空断言操作符特点

31、使用if判断null值的情况
	源码见project/KotlinStart项目 base.KTnull.kt
    	//if也算是补救措施，编译器能够通过编译，这种写法和java一样
	if(name6 != null){
        	println(name6.capitalize())
    	}

32、空合并操作符
	源码见project/KotlinStart项目 base.KTnull.kt

   	 //使用?:判断变量是否为空，如果为空执行“:”后面的语句
    	var info:String? = null
    	println(info?:"sundro")

    	//let + 空合并操作符
    	println(info?.let { "[$it]" } ?: "[sandro]")	

33、异常处理和自定义异常
	源码见project/KotlinStart项目 base.KTEXception.kt
	
	//定义一个异常类继承IllegalArgumentException
	class MyException : IllegalArgumentException("没有赋值")

	//异常检查方法，如果为空抛出一个自定义异常
	private fun checkExeption(info:String?){
    		info ?: throw MyException()
	}

	调用：
    	try {
        	var info:String? = null;
        	checkExeption(info);
        	println(info!!.length);
    	}catch (e:Exception){
        	println("出现异常 $e");
    	}	

34、先决条件函数
	源码见project/KotlinStart项目 base.KTEXception.kt
    	
	//使用checkNotNull 和 requireNotNull 判空
    	var value:String?=null
    	try {
        	checkNotNull(value)
    	}catch (e:Exception){
        	println("$e");//java.lang.IllegalStateException: Required value was null.
    	}
    	try {
        	requireNotNull(value)//java.lang.IllegalArgumentException: Required value was null.
    	}catch (e:Exception){
        	println("$e");
    	}

	//Boolean变量 可以用require判断是否是false,false会抛异常
    	var b = false
    	try {
        	require(b)//java.lang.IllegalArgumentException: Required value was null.
    	}catch (e:Exception){
        	println("require exception : $e");//java.lang.IllegalArgumentException: Failed requirement.
    	}	






