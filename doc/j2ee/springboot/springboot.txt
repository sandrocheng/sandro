1、什么是spring
	spring是一个开源框架，2003年兴起的一个轻量级的java开发框架，作者：Rod Johnson。
	Spring是为了解决企业级应用开发的复杂性而创建的，简化开发的框架

2、spring是如何简化开发的
	为了降低java开发的复杂性，spring采用了以下4种关键策略：
	1）基于POJO的轻量级和最小侵入性编程
	2）通过IOC，依赖注入(DI)和面向接口实现松耦合
	3）基于切面(AOP)和惯例进行声明式编程
	4）通过切面和模板减少样式代码

3、什么是springboot
	-开发web应用，最开始是使用Servlet结合Tomcat，跑出一个hello wrold程序，需要经历特别多的步骤
	 后来使用了structs，再后来是springMVC,目前流行的是springboot
	 springboot就是一个java web的开发框架，和springMVC类似，对比其他java web框架的好处是简化开发，约定大于配置，能迅速开发web应用

	-所有的计数框架似乎都遵循了一条主线规律：从一个复杂应用场景衍生出一种框架，人们只需要进行各种配置而不需要亲自实现它，这时候强大的配置功能就成为了有点
	 发展到一定程度之后，人们根据实际生产应用情况，选取其中使用功能和设计精华，重构出了一些轻量级的框架
	 之后为了提高效率，嫌弃原先的各种配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案
	 这就是java企业级应用->j2ee->spring->springboot的过程
	
	-随着spring不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，甚至人称配置地狱。
	 springboot正是在这样的一个背景下被抽象出来的开发框架，目的是为了让大家更容易的使用spring，更容易的集成各种常用的中间件、开源软件

	-springboot 基于 spring开发，spring boot本身并不提供spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于spring框架的应用程序。
	 也就是说它并不是用来替代spring的解决方案，而是和spring框架紧密结合用于提升spring开发者体验的工具。spring boot以约定大于配置的核心思想，默认帮我们进行了很多配置
	 多数spring boot应用只需要很少的spring配置。同时它集成了大量常用的第三方库配置(例如：Redis,MongoDB,Jpa,RabbitMQ,Quartz等等)，spring boot应用中这些第三方库几乎可以零配置的开箱即用
	
	-简单来说，就是springboot其是不是什么新鲜的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架
         springboot出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善。

4、springboot的主要优点
	-为所有spring开发者更快的如门
	-开箱即用，提供各种默认配置来简化项目配置
	-内嵌式容器简化web项目
	-没有冗余代码生成和xml配置的要求

5、什么是微服务
	-微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合
	 可以通过http的方式进行互通。
	
 	-单体应用架构
	 所为单体应用架构(all in one)是指，我们将一个应用中的所有服务都封装在一个应用中。
	 无论是ERP，CRM或是其他什么系统，都把数据库访问，web访问，等等各个功能都放在一个war包中
	
	 这样做的好处是易于开发和测试，也十分方便部署，当需要扩展时，只需要将war包复制多份，然后放到多个服务器上，再做个负载均衡就可以了
	
	 缺点是，哪怕要修改一个微笑的地方，都需要停掉所有服务，重新打包，部署这个war包。特别对于大型应用，我们不可能把所有内容都放在一个应用里面，如何维护如何分工合作都是问题

6、微服务架构
	all in one的架构方式，我们把所有的功能单元放在一个应用里面，然后把整个应用部署到服务器上。如果负载能力不行，我们会将整个应用水平复制，然后扩展，然后再负载均衡
	所为微服务架构，就是打破之前的all in one的架构方式，把每个功能元素都独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合
	需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制

	这样做的好处是
		1)节省了调度资源
		2)每个功能元素的服务都是一个可替换的、可独立升级的软件代码

7、如何构建微服务	
	-一个大型的微服务架构，就像一个复杂交织的神经网络，每个神经元就是一个功能元素，他们各自完成自己的功能，然后通过http相互请求调用。
	 比如一个电商系统，查缓存，连数据库，浏览页面，结帐，支付等服务都是一个个独立的功能服务，都被微化了，他们做为一个个微服务共同构建了一个庞大的系统。
	 如果修改其中一个功能，只需要更新升级其中一个功能服务单元即可。

	-但是这种庞大的系统架构给部署和运维带来很大的难度。于是,spring为我们带来了构建大型分布式的全套、全程产品：
		-构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用
		-大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式
		-在分布式中间，进行流式数据计算，批处理，我们有spring cloud data flow
		-spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案

8、spring boot helloworld
	jdk + maven + springboot
	IDE:IDEA
	-官网生成springbootdemo：spring.io -> project -> springboot,在首页上可以找到最新的GA版本，找到 Quickstart Your Project，点击Spring Initlalizr
	 在这里选择环境，工程名 包名等信息 dependencies 选择一个Spring Web，点击generate会自动构建项目，并提示下载

	-IDEA生成springboot项目,需要下载spring boot helper插件(收费插件)，在new project的时候，选择 Spring Initializr，可以方便的生成springboot初始项目
	 	 
	-详见：/projects_j2ee/springboot_exam/springbootDemo
	
	-默认的主入口是Demo1Application，这个主入口不能删，也不要改
	 直接运行这个文件就可以启动tomcat服务了：
		main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'
	 访问 http://localhost:8080/
	      因为没有配置根页面，所以可以看到服务返回的错误提示，这个时候，一个基本的web应用框架已经可以使用了
	
	 @SpringBootApplication表示当前的类就是spring的一个组件
	 
	-/src/main/resources/application.properties，这个是springboot的核心配置文件
	 1）更改端口号
		server.port=8083
	 2）自定义banner，服务启动的时候，有一个spring banner的输出如下：
		  .   ____          _            __ _ _
		 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
		( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
		 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
		  '  |____| .__|_| |_|_| |_\__, | / / / /
		 =========|_|==============|___/=/_/_/_/
		
		 :: Spring Boot ::                (v3.3.1)
	    这个banner也可以修改，可以在baidu上搜 springboot banner生成器，会有很多生成器，
	    比如：https://www.bootschool.net/ascii，把生成的内容贴到properties同目录的banner.txt中即可，不需要配置
	
	 
	-建包，因为springboot是基于约定的，所以这里必须在Demo1Application同级别建包，在其他地方建包，会出问题
         常规的包，domain,dao,service,controller

	-在controller下创建HelloController类,定义一个返回字符串的http请求接口hello,只需要配置上spring相关的注解，其他的springboot已经自动配置了，
	 之后就可以通过/localhost:8080/hello 访问这个接口的页面了

	-打包，使用maven的package命令就可以直接打成jar包，打出来的jar包，可以直接运行，内部包含了tomcat，因此服务就可以启动了
		java -jar xxx.jar
	-总结
	 如上所示，主要有4个部分
		-项目元数据信息：创建的时候输入的project metadata部分，也就是maven的项目基本元素，包括:groupId,artifaciId,version,name,description等
		-parent：继承spring-boot-start-parent的依赖管理，控制版本与打包内容等
		-dependencies:项目具体依赖，这里包含了spring-boot-start-web，用户实现http接口(该依赖包含了spring MVC)
			      官网对它的描述是:使用spring MVC构建web(包含RESTful)应用程序入门者，使用tomcat做为默认嵌入式容器
			      spring-boot-starter-test用于编写单元测试的依赖包。
		-build：构建配置部分。默认使用了spring-boot-maven-plugin,配合spring-boot-starter-parent就可以把spring boot应用打包成jar来直接运行
		
9、springboot自动装配原理
	-pom文件内容分析
	 1)parent标签内容是spring-boot-starter-parent，点击打开这个pom文件发现还有一个根的parent org.springframework.boot
	   properties标签中可以看到管理了的大量的依赖库的版本以及核心依赖的第三方库，一般在springboot依赖的包这里都有，外部继承以后不需要指定版本
	   resource标签中指定了资源文件的位值和命名规范	

	 2)启动器
	   spring-boot-starter-web，它会自动装配web环境相关的依赖
	   springboot会将所有的功能场景，都封装成一个个的启动器，如果要使用什么功能就只需要找到对应的启动器就可以了，一般都以'spring-boot-stater..'来命名
	   官网->projec->springboot:learn->找到对应版本的Reference Doc 搜索 starters，在Build System里面能找到所有的启动器

	-主程序
	 @SpringBootApplication，用来标注这个类是springboot的应用
	 这是个组合注解主要包括
	 	-@SpringBootConfiguration:springboot的配置，它内部由@Configuraton 和 @Component来管理的，这是两个spring注解，说明这个类是个配置类，同时也是一个组件
		-@EnableAutoConfiguration:自动配置
			->@AutoConfigurationPackage:自动配置包
				->@Import({AutoConfigurationPackages.Registrar.class}) 自动配置'包配置'
			->@Import({AutoConfigurationImportSelector.class}) : 自动配置导入选择
				->getCandidateConfigurations，通过这个函数导入了配置资源文件，这里可以看到被SpringBootApplication标注的类会做为当前资源的classloader
							      其实目的就是为了把启动类下的所有资源都加载。
							      这里面在Assert里提到了  META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
							      这个文件在对应类的包里的META-INF下，里面可以看到所有配置的需要自动加载的类	 
		-@ComponentScan
	 如图：9_自动配置原理分析,springboot所有的自动配置都在启动类中被扫描并加载,同时还得导入对应的**start** 启动器就会自动装配并生效 	

	-总结
	 1)springboot在启动的时候，从类路径下/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports获取指定的值
	 2)将这些自动配置的类导入容器，自动配置就会生效
	 3)以前在使用spring的时候需要自动配置的组件，现在springboot自动去做了
	 4)整合javaEE,解决方案和自动配置的东西都在spring-boot-autoconfigure-x.x.x.jar这个包下
	 5)它会把所有需要导入的组件，以类名的方式返回，使用classloader加载
	 6)容器中也会存在非常多的命名为xxxAutoConfiguation类，导入这些类，就会自动配置相关的组件
	 7)有了自动配置类，就免去了很多手动工作

10、主启动类
	主启动类运行后，会启动一个服务
	-SpringApplication这个类组要做了以下4个事情,如图:10_主启动类启动流程
	 1)推断应用类型是普通的项目还是web项目
	 2)查找并加载所有可用初始化器，设置到initializers属性中
	 3)找出所有的应用程序监听器，设置到linterners属性中
	 4)推断并设置main方法的定义类，找到主运行的类，根据主运行类路径找到其他业务类，所以其他业务类必须在主类包之下
	 
11 springboot的全局配置文件
	-Spring Boot允许您将配置外部化，以便您可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括Java properties文件、YAML文件、环境变量和命令行参数。	
	-配置的文档在 官网->Spring Boot->Reference->Core Features->Externalized Configuration中
	 一般来讲官方推荐使用YAML配置文件，不推荐proterties文件来配置

	-详见：/projects_j2ee/springboot_exam/springbootDemo
	-删除springboot自动生成的 application.properties文件，新建一个application.yaml文件

	-springboot使用一个全局的配置文件，配置文件名称是固定的
		-application.properties，语法结构： key=value
		-application.yaml ，语法结构：key:[空格]value
         配置文件作用：修改springboot自动配置的默认值

	-YAML 是 "YAML Ain't a Markup Language"（YAML 不是一种标记语言）的递归缩写。
	 在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。
	 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。
	 它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。
	 YAML 的配置文件后缀为 .yml，如：runoob.yml 。
	
	-标记语言
	 以前的配置文件，大多使用xml来配置，比如一个简单的端口配置
	 YAML：
		#修改默认的端口号
		server:
		  port: 8083	
	 xml:
		<server>
			<port>8083</port> 
		</server> 
	
12、YAML语法
	-详见：/projects_j2ee/springboot_exam/springbootDemo
	-基础语法：k:[空格]v
	 以此来表示一个键值对(空格不能省略)，以空格的缩进来控制层级关系，只要是左边对齐的一类数据都是同一个层级的。
	 注意：属性和值的大小写都是十分敏感的，例子
		#修改默认的端口号
		server:
		  port: 8083
		  path: /hello		

	-值的写法
	 字面量:普通的值[数字，布尔值，字符串]
	 	k: v
	 字面量直接写在后面就可以，字符串默认不用加上双引号或者单引号
	 "" 双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思
	 比如：
		name: "hello \n world" ,输出 ： hello 换行 world

	-对象的写法
		#对象的写法
		student:
		  name: sandro
		  age: 44
		 
		#对象的另一种写法  
		student: {name: sandro,age : 44}    

	-数组的写法
		#数组的写法
		names:
		  - sandro
		  - joy
		  - jess
		#数组的另一种写法
		names: [sandro,joy,jess]	
	
	-YAML 不直接支持 el 表达式，因为 YAML 是一种非常简洁的数据描述语言，而 el 表达式是一种用于在 Java 应用程序中进行表达式求值的语言。
	 如果需要在 YAML 配置文件中使用类似 el 表达式的功能，可以使用 Spring 的 ${} 占位符功能，这与 el 表达式的功能类似。
	 	uuid: ${random.uuid}


	-注意：YAML对空格和缩进的要求及其严格，一定要注意

	-YAML是可以方便的注入到java对象中
	 使用spring源生的注解方式注入数据：
	 sandro.springboot.demo1.domain包下定义两个类User和UserInfo都是普通的pojo其中有各种类型的属性，使用@Component注解添加到spring的组件中，由spring统一管理
	 	-使用spring源生的注解方式注入数据：
	 	 UserInfo使用@Value注解，当声明对象时候可以使用@Autowired 注解初始化数据。
	 	 在Demo1ApplicationTests测试类中可以声明UserInfo对象(使用@Autowired注解托管给spring管理)，并输出UserInfo对象的值。
	 	 使用spring注解的方式注入数据，数据分散在代码各处，十分影响可读性。

		-使用YAML注入数据,可以在yaml配置文件中统一配置数据，更便于管理
	         在application.yaml文件中初始化数据
			defaultuser:
			  name: sandro
			  age: 44
			  male: true
			  birthday: 2024/07/04
			  map: {key1: value1,key2: value2}
			  list:
			    - code
			    - music
			    - girl
			  userInfo:
			    desc: 默认信息${random.uuid}
			    money: 10			
		 在User类上使用@ConfigurationProperties(prefix = "defaultuser")注解，该注关联了User类和YAML中的属性名，这样就可以在yaml文件中定义数据并注入对象了
		 测试类Demo1ApplicationTests.testUser中测试效果

		-松散绑定
		 sandro.springboot.demo1.domain.Manager类中定义了两个变量，变量名称由两个单词组成第二个单词首字母大写如下：
			private String managerName;
			private int managerId;

		 yaml数据绑定的时候可以使用 “-” 连接变量中的两个单词
			default-manager:
			  manager-name: 管理员
			  manager-id: 88
		 松散绑定让变量名称在java源码和yaml配置文件中都更易读 
	 
	-spring-boot-configuration-processor依赖，
		<dependency><!--yaml文件中属性检查工具，不接入的话，yaml在使用自定义的属性时会爆红-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
		</dependency>

13、JSR303校验
	-详见：/projects_j2ee/springboot_exam/springbootDemo
	-测试方法：Demo1ApplicationTests.testPerson();
	-springboot中可以用@validated来指定需要校验数据的类或者方法，如果数据异常则会统一抛出异常，方便异常中心统一处理
	 JSR303校验是一组javax提供的规范，由各种注解组成，比如@Email使用来校验邮箱格式的。@NotEmpty，被注释的字符不能为空
	 比较常用的是@Pattern，验证字符串是否满足正则表达式
	-pom依赖:
		<dependency><!--springboot提供的 JSR303校验starter-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		
	 比如：sandro.springboot.demo1.domain.Person类，让email字段只支持Email格式
		@Component
		@ConfigurationProperties(prefix = "person")
		@Validated //JSR303数据校验
		public class Person {
		
		    @Email //email格式校验
		    private String email;		
		    ...
	        }

	       为了便于测试，使用yaml配置文件初始化数据，也可以直接new 一个Person对象，给email赋值来测试
			person:
			  email: abcd
	 @Email注解是用来校验字符串是否是email格式的 ，此时会抛出异常 Field error in object 'person' on field 'email': rejected value [abcd]; 
	 改成正常的email格式之后就可以正常赋值了			
