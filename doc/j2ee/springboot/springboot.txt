1、什么是spring
	spring是一个开源框架，2003年兴起的一个轻量级的java开发框架，作者：Rod Johnson。
	Spring是为了解决企业级应用开发的复杂性而创建的，简化开发的框架

2、spring是如何简化开发的
	为了降低java开发的复杂性，spring采用了以下4种关键策略：
	1）基于POJO的轻量级和最小侵入性编程
	2）通过IOC，依赖注入(DI)和面向接口实现松耦合
	3）基于切面(AOP)和惯例进行声明式编程
	4）通过切面和模板减少样式代码

3、什么是springboot
	-开发web应用，最开始是使用Servlet结合Tomcat，跑出一个hello wrold程序，需要经历特别多的步骤
	 后来使用了structs，再后来是springMVC,目前流行的是springboot
	 springboot就是一个java web的开发框架，和springMVC类似，对比其他java web框架的好处是简化开发，约定大于配置，能迅速开发web应用

	-所有的计数框架似乎都遵循了一条主线规律：从一个复杂应用场景衍生出一种框架，人们只需要进行各种配置而不需要亲自实现它，这时候强大的配置功能就成为了有点
	 发展到一定程度之后，人们根据实际生产应用情况，选取其中使用功能和设计精华，重构出了一些轻量级的框架
	 之后为了提高效率，嫌弃原先的各种配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案
	 这就是java企业级应用->j2ee->spring->springboot的过程
	
	-随着spring不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，甚至人称配置地狱。
	 springboot正是在这样的一个背景下被抽象出来的开发框架，目的是为了让大家更容易的使用spring，更容易的集成各种常用的中间件、开源软件

	-springboot 基于 spring开发，spring boot本身并不提供spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于spring框架的应用程序。
	 也就是说它并不是用来替代spring的解决方案，而是和spring框架紧密结合用于提升spring开发者体验的工具。spring boot以约定大于配置的核心思想，默认帮我们进行了很多配置
	 多数spring boot应用只需要很少的spring配置。同时它集成了大量常用的第三方库配置(例如：Redis,MongoDB,Jpa,RabbitMQ,Quartz等等)，spring boot应用中这些第三方库几乎可以零配置的开箱即用
	
	-简单来说，就是springboot其是不是什么新鲜的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架
         springboot出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善。

4、springboot的主要优点
	-为所有spring开发者更快的如门
	-开箱即用，提供各种默认配置来简化项目配置
	-内嵌式容器简化web项目
	-没有冗余代码生成和xml配置的要求

5、什么是微服务
	-微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合
	 可以通过http的方式进行互通。
	
 	-单体应用架构
	 所为单体应用架构(all in one)是指，我们将一个应用中的所有服务都封装在一个应用中。
	 无论是ERP，CRM或是其他什么系统，都把数据库访问，web访问，等等各个功能都放在一个war包中
	
	 这样做的好处是易于开发和测试，也十分方便部署，当需要扩展时，只需要将war包复制多份，然后放到多个服务器上，再做个负载均衡就可以了
	
	 缺点是，哪怕要修改一个微笑的地方，都需要停掉所有服务，重新打包，部署这个war包。特别对于大型应用，我们不可能把所有内容都放在一个应用里面，如何维护如何分工合作都是问题

6、微服务架构
	all in one的架构方式，我们把所有的功能单元放在一个应用里面，然后把整个应用部署到服务器上。如果负载能力不行，我们会将整个应用水平复制，然后扩展，然后再负载均衡
	所为微服务架构，就是打破之前的all in one的架构方式，把每个功能元素都独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合
	需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制

	这样做的好处是
		1)节省了调度资源
		2)每个功能元素的服务都是一个可替换的、可独立升级的软件代码

7、如何构建微服务	
	-一个大型的微服务架构，就像一个复杂交织的神经网络，每个神经元就是一个功能元素，他们各自完成自己的功能，然后通过http相互请求调用。
	 比如一个电商系统，查缓存，连数据库，浏览页面，结帐，支付等服务都是一个个独立的功能服务，都被微化了，他们做为一个个微服务共同构建了一个庞大的系统。
	 如果修改其中一个功能，只需要更新升级其中一个功能服务单元即可。

	-但是这种庞大的系统架构给部署和运维带来很大的难度。于是,spring为我们带来了构建大型分布式的全套、全程产品：
		-构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用
		-大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式
		-在分布式中间，进行流式数据计算，批处理，我们有spring cloud data flow
		-spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案

8、spring boot helloworld
	jdk + maven + springboot
	IDE:IDEA
	-官网生成springbootdemo：spring.io -> project -> springboot,在首页上可以找到最新的GA版本，找到 Quickstart Your Project，点击Spring Initlalizr
	 在这里选择环境，工程名 包名等信息 dependencies 选择一个Spring Web，点击generate会自动构建项目，并提示下载

	-IDEA生成springboot项目,需要下载spring boot helper插件(收费插件)，在new project的时候，选择 Spring Initializr，可以方便的生成springboot初始项目
	 	 
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	
	-默认的主入口是Demo1Application，这个主入口不能删，也不要改
	 直接运行这个文件就可以启动tomcat服务了：
		main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'
	 访问 http://localhost:8080/
	      因为没有配置根页面，所以可以看到服务返回的错误提示，这个时候，一个基本的web应用框架已经可以使用了
	
	 @SpringBootApplication表示当前的类就是spring的一个组件
	 
	-/src/main/resources/application.properties，这个是springboot的核心配置文件
	 1）更改端口号
		server.port=8083
	 2）自定义banner，服务启动的时候，有一个spring banner的输出如下：
		  .   ____          _            __ _ _
		 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
		( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
		 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
		  '  |____| .__|_| |_|_| |_\__, | / / / /
		 =========|_|==============|___/=/_/_/_/
		
		 :: Spring Boot ::                (v3.3.1)
	    这个banner也可以修改，可以在baidu上搜 springboot banner生成器，会有很多生成器，
	    比如：https://www.bootschool.net/ascii，把生成的内容贴到properties同目录的banner.txt中即可，不需要配置
	
	 
	-建包，因为springboot是基于约定的，所以这里必须在Demo1Application同级别建包，在其他地方建包，会出问题
         常规的包，domain,dao,service,controller

	-在controller下创建HelloController类,定义一个返回字符串的http请求接口hello,只需要配置上spring相关的注解，其他的springboot已经自动配置了，
	 之后就可以通过/localhost:8080/hello 访问这个接口的页面了

	-打包，使用maven的package命令就可以直接打成jar包，打出来的jar包，可以直接运行，内部包含了tomcat，因此服务就可以启动了
		java -jar xxx.jar
	-总结
	 如上所示，主要有4个部分
		-项目元数据信息：创建的时候输入的project metadata部分，也就是maven的项目基本元素，包括:groupId,artifaciId,version,name,description等
		-parent：继承spring-boot-start-parent的依赖管理，控制版本与打包内容等
		-dependencies:项目具体依赖，这里包含了spring-boot-start-web，用户实现http接口(该依赖包含了spring MVC)
			      官网对它的描述是:使用spring MVC构建web(包含RESTful)应用程序入门者，使用tomcat做为默认嵌入式容器
			      spring-boot-starter-test用于编写单元测试的依赖包。
		-build：构建配置部分。默认使用了spring-boot-maven-plugin,配合spring-boot-starter-parent就可以把spring boot应用打包成jar来直接运行
		
9、springboot自动装配原理
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-pom文件内容分析
	 1)parent标签内容是spring-boot-starter-parent，点击打开这个pom文件发现还有一个根的parent org.springframework.boot
	   properties标签中可以看到管理了的大量的依赖库的版本以及核心依赖的第三方库，一般在springboot依赖的包这里都有，外部继承以后不需要指定版本
	   resource标签中指定了资源文件的位值和命名规范	

	 2)启动器
	   spring-boot-starter-web，它会自动装配web环境相关的依赖
	   springboot会将所有的功能场景，都封装成一个个的启动器，如果要使用什么功能就只需要找到对应的启动器就可以了，一般都以'spring-boot-stater..'来命名
	   官网->projec->springboot:learn->找到对应版本的Reference Doc 搜索 starters，在Build System里面能找到所有的启动器

	-主程序
	 @SpringBootApplication，用来标注这个类是springboot的应用
	 这是个组合注解主要包括
	 	-@SpringBootConfiguration:springboot的配置，它内部由@Configuraton 和 @Component来管理的，这是两个spring注解，说明这个类是个配置类，同时也是一个组件
		-@EnableAutoConfiguration:自动配置
			->@AutoConfigurationPackage:自动配置包
				->@Import({AutoConfigurationPackages.Registrar.class}) 自动配置'包配置'
			->@Import({AutoConfigurationImportSelector.class}) : 自动配置导入选择
				->getCandidateConfigurations，通过这个函数导入了配置资源文件，这里可以看到被SpringBootApplication标注的类会做为当前资源的classloader
							      其实目的就是为了把启动类下的所有资源都加载。
							      这里面在Assert里提到了  META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
							      这个文件在对应类的包里的META-INF下，里面可以看到所有配置的需要自动加载的类	 
		-@ComponentScan
	 如图：9_自动配置原理分析,springboot所有的自动配置都在启动类中被扫描并加载,同时还得导入对应的**start** 启动器就会自动装配并生效 	

	-总结
	 1)springboot在启动的时候，从类路径下/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports获取指定的值
	 2)将这些自动配置的类导入容器，自动配置就会生效
	 3)以前在使用spring的时候需要自动配置的组件，现在springboot自动去做了
	 4)整合javaEE,解决方案和自动配置的东西都在spring-boot-autoconfigure-x.x.x.jar这个包下
	 5)它会把所有需要导入的组件，以类名的方式返回，使用classloader加载
	 6)容器中也会存在非常多的命名为xxxAutoConfiguation类，导入这些类，就会自动配置相关的组件
	 7)有了自动配置类，就免去了很多手动工作
	 8)每个自动装配的组件springboot都对应了一个starter，官网文档：Spring Boot->Reference->Developing with Spring Boot->Build Systems:Starters
	   中列举了所有支持的starter



10、主启动类
	主启动类运行后，会启动一个服务
	-SpringApplication这个类组要做了以下4个事情,如图:10_主启动类启动流程
	 1)推断应用类型是普通的项目还是web项目
	 2)查找并加载所有可用初始化器，设置到initializers属性中
	 3)找出所有的应用程序监听器，设置到linterners属性中
	 4)推断并设置main方法的定义类，找到主运行的类，根据主运行类路径找到其他业务类，所以其他业务类必须在主类包之下
	 
11 springboot的全局配置文件
	-Spring Boot允许您将配置外部化，以便您可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括Java properties文件、YAML文件、环境变量和命令行参数。	
	-配置的文档在 官网->Spring Boot->Reference->Core Features->Externalized Configuration中
	 一般来讲官方推荐使用YAML配置文件，不推荐proterties文件来配置

	--详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-删除springboot自动生成的 application.properties文件，新建一个application.yaml文件

	-springboot使用一个全局的配置文件，配置文件名称是固定的
		-application.properties，语法结构： key=value
		-application.yaml ，语法结构：key:[空格]value
         配置文件作用：修改springboot自动配置的默认值

	-YAML 是 "YAML Ain't a Markup Language"（YAML 不是一种标记语言）的递归缩写。
	 在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。
	 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。
	 它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。
	 YAML 的配置文件后缀为 .yml，如：runoob.yml 。
	
	-标记语言
	 以前的配置文件，大多使用xml来配置，比如一个简单的端口配置
	 YAML：
		#修改默认的端口号
		server:
		  port: 8083	
	 xml:
		<server>
			<port>8083</port> 
		</server> 
	
12、YAML语法
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-基础语法：k:[空格]v
	 以此来表示一个键值对(空格不能省略)，以空格的缩进来控制层级关系，只要是左边对齐的一类数据都是同一个层级的。
	 注意：属性和值的大小写都是十分敏感的，例子
		#修改默认的端口号
		server:
		  port: 8083
		  path: /hello		

	-值的写法
	 字面量:普通的值[数字，布尔值，字符串]
	 	k: v
	 字面量直接写在后面就可以，字符串默认不用加上双引号或者单引号
	 "" 双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思
	 比如：
		name: "hello \n world" ,输出 ： hello 换行 world

	-对象的写法
		#对象的写法
		student:
		  name: sandro
		  age: 44
		 
		#对象的另一种写法  
		student: {name: sandro,age : 44}    

	-数组的写法
		#数组的写法
		names:
		  - sandro
		  - joy
		  - jess
		#数组的另一种写法
		names: [sandro,joy,jess]	
	
	-YAML 不直接支持 el 表达式，因为 YAML 是一种非常简洁的数据描述语言，而 el 表达式是一种用于在 Java 应用程序中进行表达式求值的语言。
	 如果需要在 YAML 配置文件中使用类似 el 表达式的功能，可以使用 Spring 的 ${} 占位符功能，这与 el 表达式的功能类似。
	 	uuid: ${random.uuid}


	-注意：YAML对空格和缩进的要求及其严格，一定要注意

	-YAML是可以方便的注入到java对象中
	 使用spring源生的注解方式注入数据：
	 sandro.springboot.demo1.domain包下定义两个类User和UserInfo都是普通的pojo其中有各种类型的属性，使用@Component注解添加到spring的组件中，由spring统一管理
	 	-使用spring源生的注解方式注入数据：
	 	 UserInfo使用@Value注解，当声明对象时候可以使用@Autowired 注解初始化数据。
	 	 在Demo1ApplicationTests测试类中可以声明UserInfo对象(使用@Autowired注解托管给spring管理)，并输出UserInfo对象的值。
	 	 使用spring注解的方式注入数据，数据分散在代码各处，十分影响可读性。

		-使用YAML注入数据,可以在yaml配置文件中统一配置数据，更便于管理
	         在application.yaml文件中初始化数据
			defaultuser:
			  name: sandro
			  age: 44
			  male: true
			  birthday: 2024/07/04
			  map: {key1: value1,key2: value2}
			  list:
			    - code
			    - music
			    - girl
			  userInfo:
			    desc: 默认信息${random.uuid}
			    money: 10			
		 在User类上使用@ConfigurationProperties(prefix = "defaultuser")注解，该注关联了User类和YAML中的属性名，这样就可以在yaml文件中定义数据并注入对象了
		 测试类Demo1ApplicationTests.testUser中测试效果

		-松散绑定
		 sandro.springboot.demo1.domain.Manager类中定义了两个变量，变量名称由两个单词组成第二个单词首字母大写如下：
			private String managerName;
			private int managerId;

		 yaml数据绑定的时候可以使用 “-” 连接变量中的两个单词
			default-manager:
			  manager-name: 管理员
			  manager-id: 88
		 松散绑定让变量名称在java源码和yaml配置文件中都更易读 
	 
	-spring-boot-configuration-processor依赖，
		<dependency><!--yaml文件中属性检查工具，不接入的话，yaml在使用自定义的属性时会爆红-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
		</dependency>

13、JSR303校验
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-测试方法：Demo1ApplicationTests.testPerson();
	-springboot中可以用@validated来指定需要校验数据的类或者方法，如果数据异常则会统一抛出异常，方便异常中心统一处理
	 JSR303校验是一组javax提供的规范，由各种注解组成，比如@Email使用来校验邮箱格式的。@NotEmpty，被注释的字符不能为空
	 比较常用的是@Pattern，验证字符串是否满足正则表达式
	-pom依赖:
		<dependency><!--springboot提供的 JSR303校验starter-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		
	 比如：sandro.springboot.demo1.domain.Person类，让email字段只支持Email格式
		@Component
		@ConfigurationProperties(prefix = "person")
		@Validated //JSR303数据校验
		public class Person {
		
		    @Email //email格式校验
		    private String email;		
		    ...
	        }

	       为了便于测试，使用yaml配置文件初始化数据，也可以直接new 一个Person对象，给email赋值来测试
			person:
			  email: abcd
	 @Email注解是用来校验字符串是否是email格式的 ，此时会抛出异常 Field error in object 'person' on field 'email': rejected value [abcd]; 
	 改成正常的email格式之后就可以正常赋值了			

14、配置文件的位值
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-一般来讲配置文件的存放位值是：springbootDemo/demo1/src/main/resources/application.yaml
	 根据官网的描述配置文件也可以方在其他位值：Spring Boot->Reference->Core Features->Externalized Configuration
	 1)The classpath root,这个就是resources/目录，默认就是这个目录
	 2)The classpath /config package, 比如:  /springbootDemo/demo1/src/main/resources/config/application.yaml
	 3)The current directory : 比如：/springbootDemo/demo1/application.yaml
	 4)The config/ subdirectory in the current directory,比如: /springbootDemo/demo1/config/application.yaml
	 5)Immediate child directories of the config/ subdirectory,config目录下的直接子目录,比如：/springbootDemo/demo1/config/xx/application.yaml
	
	-这5个位值都有优先级，如果都配置了，列表按优先级排序（较低项目的值将覆盖较早项目的值），比如5)config目录下的直接子目录会覆盖前4个位值的配置文件
	 默认的位值，实际上是最容易被覆盖的。

15、多环境配置文件
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-实际开发中可能会有多个配置文件用于不同的环境，比如开发环境，正式环境等
	 可以使用多个配置文件，配置文件要以application开头

	-比如新建一个yaml文件用于测试环境：/springbootDemo/demo1/src/main/resources/application-test.yaml	 
	 再建立一个发布环境的配置文件：/springbootDemo/demo1/src/main/resources/application-release.yaml
	 默认springboot会找application.yaml,因此在默认配置文件指定一下当前用哪个文件即可
		#springboot的多环境配置，可以选择激活哪个配置文件
		spring:
		  profiles:
		    active: release #不需要写文件的全名，只要写"application-"后面的部分就可以		

	-使用一个yaml配置文件配置多环境
         yaml可以使用"---"来分隔多个部分，给每个部分命名，第一个部分优先级最高，通过指定spring.profiles.active来激活某个部分的配置信息

		spring:
		  profiles:
		    active: release #激活release环境名对应的部分
		
		---
		person:
		  email: test@163.com
		spring:
		  config:
		    activate:
		      on-profile: test #定义test环境名
		
		---
		person:
		  email: release@163.com
		spring:
		  config:
		    activate:
		      on-profile: release #定义release环境名	
	
16、配置文件生效的基本原理
	-在第9部分，springboot自动装配原理，中提到过，springboot在启动的时候装配的类在下面这个文件中
	 /spring-boot-autoconfigure/3.3.1/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
		org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration
		org.springframework.boot.autoconfigure.aop.AopAutoConfiguration
		org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
		org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration
		org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration
		org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration
		org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration
		org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration
		org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration
	        ....
	 这里列出了所有xxxAutoConfiguration都是自动装配的接口类，springboot会根据实际情况逐个执行，把对应的组件装配的容器中并自动配置
	 这些xxxAutoConfig都预留出了接口可以在application.yaml配置文件使用
 	 比如：org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration
	 找到这个类的代码可以看到如下部分:
		@AutoConfiguration //表示这是一个自动配置类
		@EnableConfigurationProperties({ServerProperties.class})//自动配置的配置属性,
		@ConditionalOnWebApplication( //这是spring的底层注解，根据不同的条件来判断当前配置或者类是否生效
		    type = Type.SERVLET
		)
		@ConditionalOnClass({CharacterEncodingFilter.class})//是否有CharacterEncodingFilter.class，如果没有不能配置
		@ConditionalOnProperty(////是否有server.servlet.encoding的值是enabled，如果不是不能配置
		    prefix = "server.servlet.encoding",
		    value = {"enabled"},
		    matchIfMissing = true
		)
		public class HttpEncodingAutoConfiguration {
			...
		}
	 @ConditionalOnxxx是spring判断环境的注解，如图：16_spring的ConditionalOnxxx注解
	 从这里可以看到ServerProperties.class是用来关联属性的，在这个类里可以看到下面的内容
		@ConfigurationProperties(
		    prefix = "server",
		    ignoreUnknownFields = true
		)
		public class ServerProperties {
			...
		}
	 这里可以看到prefix是server,因此在application.yaml中输入server. 就会提示这个类可以配置的全部参数了,如图：16_IDEA中yaml提示
	 这些配置接口可以在官网中查到具体说明： Spring Boot->Appendix->Common Application Properties

	-总结：
		1)springboot启动会加载大量的自动配置类
		2)确定一下需要的功能有没有在springboot默认写好的自动配置类中
		3)再去看这个自动配置类中配置了哪些组件(只要是要用的组件存在其中，就不需要手动配置了)
		4)给容器中自动配置类添加组件的时候会从properties类中获取某些属性，只需要在配置文件中指定这些属性的值即可
          		xxxAutoConfiguratrion:自动配置类，给容器添加组件
	  		xxxxProperties:封装配置文件中相关属性 这些属性 和application.yaml中的属性值都是一一对应的
	
	-debug
	 在application.yaml中设置 
		debug: true #设置debug可以看到哪些装配类是生效的
	 执行后会看到 CONDITIONS EVALUATION REPORT,分为三类 
		-Positive matches,自动配置类启用并且生效的组件，使用不同启动器生效的组件都是不一样的
				  通过启动的组件可以大概分析当前的框架可以使用哪些组件
		-Negative matches，自动配置类没有启用的组件
				   分析出哪些组件没有生效，就去找对应的包，看哪些starter启动器能包含这个包，通过启动器来自动装载这些包
		-Exclusions，没有条件被排除的组件

17、springboot web开发			
	-使用springboot开发的基本步骤
		1)创建应用，选择模块
		2)修改基本配置
		3)业务开发
	
	-springboot自动装配：通过xxxAutoConfiguration向容器中自动装配组件
			     装配的过程中根据@ConditionalOnxxx,判断是否需要装配
	-通过application.yaml的配置对应xxxProperties进行自定义内容

	-web开发还需要做的事情
	 静态资源导入：比如html,css,js脚本等
	 首页定制
	 模板引擎，比如freemarker Thymeleaf等
	 装配扩展springMVC
	 数据的增删改查
	 拦截器
	 国际化

18、springboot web开发-静态资源导入
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	 
	-resources目录下默认有两个目录
		static:放资源，css,html,js等
		templates:放模板，比如freemarker的模板，Themeleaf模板等
	 除此之外还有其他很多地方可以放置静态资源

	-从源码处查找资源目录
	 通过maven依赖可以看到，spring-boot-starter-web 启动器会自动装配spring MVC(org.springframework:spring-webmvc),关于项目的资源也都由spring MVC来管理
	 自动装配配置文件中 spring-boot-autoconfigure-3.3.1.jar/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
	 可以看到org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration这个装配类
	 在这个类里可以找到  @EnableConfigurationProperties({WebProperties.class}) 
	 继续在WebProperties类中可以看到 配置属性别名 ：@ConfigurationProperties("spring.web")

	-webjars
	 springboot支持自动加载webjars的静态库
	 在WebMvcAutoConfiguration中的addResourceHandlers方法：
		//这是一个资源目录查找的方法
	        public void addResourceHandlers(ResourceHandlerRegistry registry) {
	            if (!this.resourceProperties.isAddMappings()) {//这里判断如果用户使用application.yaml配置了资源路径，那么就不会再使用默认路径了
	                logger.debug("Default resource handling disabled");
	            } else {
			//这里先去加载webjar路径
	                this.addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(), "classpath:/META-INF/resources/webjars/");
			//这里是通过mvcProperties获取静态资源路径
	                this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
	                    registration.addResourceLocations(this.resourceProperties.getStaticLocations());
	                    if (this.servletContext != null) {
	                        ServletContextResource resource = new ServletContextResource(this.servletContext, "/");
	                        registration.addResourceLocations(new Resource[]{resource});
	                    }
	
	                });
	            }
	        }
	 webjars是一套通过maven来管理静态资源的技术方案，官网https://www.webjars.org/，在这里可以查找比如jquery,extjs,vue等js库
	 比如jquery的坐标
		<dependency>
		    <groupId>org.webjars.npm</groupId>
		    <artifactId>jquery</artifactId>
		    <version>3.7.1</version>
		</dependency>
	 配置到pom后，下载，会看到jquery是以jar包的形式引入到项目中的，如图:18_webjars资源目录
	 可以看到jquery的资源库就在/META-INF/resources/webjars/下，this.mvcProperties.getWebjarsPathPattern() 返回的是"/webjars/**"
	 因此如果要通过web访问这个js路径就是：/webjars/jquery/3.4.1/dist/jquery.js，比如：http://localhost:8083/webjars/jquery/3.4.1/dist/jquery.js

	-mvcProperties的静态资源路径
	 除了webjars以外，springboot还会加载mvcProperties.getStaticPathPattern()的静态资源路径，这个路径是/**,
	 mvcProperties对应的是WebMvcProperties中定义的路径，这里可以看到使用的是WebProperties.Resources resourceProperties中默认的路径
		private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"};
	 
	-总结
	 springboot可以识别以下几个静态资源的目录
	 1)/resources/public,它对应的web路径是根路径，比如:http://localhost:8083/hello1.js
	 2)/resources/static,它对应的web路径是根路径，比如:http://localhost:8083/hello2.js
	 3)/resources/resources,它对应的web路径是根路径，比如:http://localhost:8083/hello3.js
	 4)classpath:/META-INF/resources/webjars/,这个是springboot自动加载webjar库的路径，对应的路径是/webjar/**,比如：http://localhost:8083/webjars/jquery/3.4.1/dist/jquery.js
	 5)/** ,/resources/目录下的所有路径也可以包含进来

	 resources/resources里的优先级最高，其次是/resources/static，最后是/resources/public
	 一般来讲，public放一些库文件，比如js库，static放一些资源文件比如图片等，resources下放的是upload上传的文件

	 官网文档路径 Spring Boot->Reference->Web->Servlet Web Applications : Static Content


	 
	-自定义路径
	 如果在application.yaml文件中自定义了路径，则不会加载默认路径了
		#自定义资源文件路径  
		  mvc:
		    static-path-pattern: /sandro/**,classpath:/hello/

18、springboot web开发-首页定制
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	-官网文档：Spring Boot->Reference->Web->Servlet Web Applications:Welcome Page
	 Spring Boot同时支持静态和模板化欢迎页面。它首先在配置的静态路径中查找一个index.html文件。如果找不到索引模板，则会查找索引模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。
	 首页index.html可以放在任意静态路径下，比如放在 /resources/public中，springboot就会自动加载了。

	-源码
	 在WebMvcAutoConfiguration类中的welcomePageHandlerMapping方法，定义了首页的创建，这个方法被注入到@Bean里了，被springboot管理
	 	
        	private <T extends AbstractUrlHandlerMapping> T createWelcomePageHandlerMapping(ApplicationContext applicationContext, 
											FormattingConversionService mvcConversionService, 
											ResourceUrlProvider mvcResourceUrlProvider,
											WelcomePageHandlerMappingFactory<T> factory) {
            		TemplateAvailabilityProviders templateAvailabilityProviders = new TemplateAvailabilityProviders(applicationContext);
			//这里可以看到首页的资源文件是可以使用WebMvcProperties映射的属性，在application.yaml文件中自定义
            		String staticPathPattern = this.mvcProperties.getStaticPathPattern();
            		T handlerMapping = factory.create(templateAvailabilityProviders, applicationContext, this.getIndexHtmlResource(), staticPathPattern);
            		handlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider));
            		handlerMapping.setCorsConfigurations(this.getCorsConfigurations());
            		return handlerMapping;
        	}	 
		
	 在WebMvcAutoConfiguration类中的getIndexHtmlResource方法中可以看到首页的文件名是index.html

	-使用controller跳转templates目录下的index.html
	 除了把静态的index.html放到资源文件夹下由springboot自动匹配以外，常规的使用方法是把index.html放到templates目录下，配合模板引擎(比如freemarker,thymeleaf等)动态加载
	 放在templates目录下的index.html必须使用controller跳转
	 
	 新建一个IndexController类，放在sandro.springboot.web.controller包下，对应的index.html放到template下

19、默认图标配置
         -详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
         -官网文档：Spring Boot->Reference->Web->Servlet Web Applications:Custom Favicon
	  与其他静态资源一样，Spring Boot会在配置的静态内容位置中检查favicon.ico。如果存在这样的文件，它将自动用作应用程序的图标。

20、thymeleaf模板引擎
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	-springboot打包是jar包，同时使用的是嵌入式的tomcat，因此暂时不支持jsp
	 因此springboot需要结合模板引擎来制作页面，比较常见的是freemarker，thymeleaf,springboot推荐使用thymeleaf
	
	-因为springboot已经集成了thymeleaf的自动装配所以使用thymeleaf只要maven依赖对应的启动器即可，不需要额外配置
	 	<dependency><!--springboot推荐的模板引擎thymeleaf启动器，相比freemarker功能更强大，-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>

	-模板引擎的主要功能是将java中的数据注入到页面中，返回给使用者，如图20_模板引擎

	-thymeleaf官网：https://www.thymeleaf.org/
	 github中 thymeleaf主页：https://github.com/thymeleaf/thymeleaf
	 springbboot官网：Spring Boot->How-to Guides->Hot Swapping：Thymeleaf Templates  ，这里也只是提供相关的配置类名，让使用者自己读代码去了解如何配置
	
	-ThymeleafAutoConfiguration自动装配
	 在这个类上可以看到@EnableConfigurationProperties({ThymeleafProperties.class})注解
	 说明ThymeleafProperties是绑定application.yaml中的属性，这个类里声明的属性名是spring.thymeleaf，因此可以使用spring.thymeleaf提供的相关接口修改默认配置了
		@ConfigurationProperties(prefix = "spring.thymeleaf")
	 从这里可以看到，默认的模板后缀是.html,模板文件要放到templates目录下，默认编码是UTF-8。
	
21、thymeleaf基础语法
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	 controller:/springbootDemo/web_demo/src/main/java/sandro/springboot/web/controller/IndexController.java
	 模板：/springbootDemo/web_demo/src/main/resources/templates/index.html

	-thymeleaf可以替换所有的html元素，在html中必须要引入它的约束和命名空间
	 使用thymeleaf的语法必须要使用“th:“来接管html元素 ，比如 th:元素名

	
	 
	 
