1、什么是spring
	spring是一个开源框架，2003年兴起的一个轻量级的java开发框架，作者：Rod Johnson。
	Spring是为了解决企业级应用开发的复杂性而创建的，简化开发的框架

2、spring是如何简化开发的
	为了降低java开发的复杂性，spring采用了以下4种关键策略：
	1）基于POJO的轻量级和最小侵入性编程
	2）通过IOC，依赖注入(DI)和面向接口实现松耦合
	3）基于切面(AOP)和惯例进行声明式编程
	4）通过切面和模板减少样式代码

3、什么是springboot
	-开发web应用，最开始是使用Servlet结合Tomcat，跑出一个hello wrold程序，需要经历特别多的步骤
	 后来使用了structs，再后来是springMVC,目前流行的是springboot
	 springboot就是一个java web的开发框架，和springMVC类似，对比其他java web框架的好处是简化开发，约定大于配置，能迅速开发web应用

	-所有的计数框架似乎都遵循了一条主线规律：从一个复杂应用场景衍生出一种框架，人们只需要进行各种配置而不需要亲自实现它，这时候强大的配置功能就成为了有点
	 发展到一定程度之后，人们根据实际生产应用情况，选取其中使用功能和设计精华，重构出了一些轻量级的框架
	 之后为了提高效率，嫌弃原先的各种配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案
	 这就是java企业级应用->j2ee->spring->springboot的过程
	
	-随着spring不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，甚至人称配置地狱。
	 springboot正是在这样的一个背景下被抽象出来的开发框架，目的是为了让大家更容易的使用spring，更容易的集成各种常用的中间件、开源软件

	-springboot 基于 spring开发，spring boot本身并不提供spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于spring框架的应用程序。
	 也就是说它并不是用来替代spring的解决方案，而是和spring框架紧密结合用于提升spring开发者体验的工具。spring boot以约定大于配置的核心思想，默认帮我们进行了很多配置
	 多数spring boot应用只需要很少的spring配置。同时它集成了大量常用的第三方库配置(例如：Redis,MongoDB,Jpa,RabbitMQ,Quartz等等)，spring boot应用中这些第三方库几乎可以零配置的开箱即用
	
	-简单来说，就是springboot其是不是什么新鲜的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架
         springboot出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善。

4、springboot的主要优点
	-为所有spring开发者更快的如门
	-开箱即用，提供各种默认配置来简化项目配置
	-内嵌式容器简化web项目
	-没有冗余代码生成和xml配置的要求

5、什么是微服务
	-微服务是一种架构风格，它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合
	 可以通过http的方式进行互通。
	
 	-单体应用架构
	 所为单体应用架构(all in one)是指，我们将一个应用中的所有服务都封装在一个应用中。
	 无论是ERP，CRM或是其他什么系统，都把数据库访问，web访问，等等各个功能都放在一个war包中
	
	 这样做的好处是易于开发和测试，也十分方便部署，当需要扩展时，只需要将war包复制多份，然后放到多个服务器上，再做个负载均衡就可以了
	
	 缺点是，哪怕要修改一个微笑的地方，都需要停掉所有服务，重新打包，部署这个war包。特别对于大型应用，我们不可能把所有内容都放在一个应用里面，如何维护如何分工合作都是问题

6、微服务架构
	all in one的架构方式，我们把所有的功能单元放在一个应用里面，然后把整个应用部署到服务器上。如果负载能力不行，我们会将整个应用水平复制，然后扩展，然后再负载均衡
	所为微服务架构，就是打破之前的all in one的架构方式，把每个功能元素都独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合
	需要多一些时可以整合多个功能元素。所以微服务架构是对功能元素进行复制，而没有对整个应用进行复制

	这样做的好处是
		1)节省了调度资源
		2)每个功能元素的服务都是一个可替换的、可独立升级的软件代码

7、如何构建微服务	
	-一个大型的微服务架构，就像一个复杂交织的神经网络，每个神经元就是一个功能元素，他们各自完成自己的功能，然后通过http相互请求调用。
	 比如一个电商系统，查缓存，连数据库，浏览页面，结帐，支付等服务都是一个个独立的功能服务，都被微化了，他们做为一个个微服务共同构建了一个庞大的系统。
	 如果修改其中一个功能，只需要更新升级其中一个功能服务单元即可。

	-但是这种庞大的系统架构给部署和运维带来很大的难度。于是,spring为我们带来了构建大型分布式的全套、全程产品：
		-构建一个个功能独立的微服务应用单元，可以使用springboot，可以帮我们快速构建一个应用
		-大型分布式网络服务的调用，这部分由spring cloud来完成，实现分布式
		-在分布式中间，进行流式数据计算，批处理，我们有spring cloud data flow
		-spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案

8、spring boot helloworld
	jdk + maven + springboot
	IDE:IDEA
	-官网生成springbootdemo：spring.io -> project -> springboot,在首页上可以找到最新的GA版本，找到 Quickstart Your Project，点击Spring Initlalizr
	 在这里选择环境，工程名 包名等信息 dependencies 选择一个Spring Web，点击generate会自动构建项目，并提示下载

	-IDEA生成springboot项目,需要下载spring boot helper插件(收费插件)，在new project的时候，选择 Spring Initializr，可以方便的生成springboot初始项目
	 	 
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	
	-默认的主入口是Demo1Application，这个主入口不能删，也不要改
	 直接运行这个文件就可以启动tomcat服务了：
		main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'
	 访问 http://localhost:8080/
	      因为没有配置根页面，所以可以看到服务返回的错误提示，这个时候，一个基本的web应用框架已经可以使用了
	
	 @SpringBootApplication表示当前的类就是spring的一个组件
	 
	-/src/main/resources/application.properties，这个是springboot的核心配置文件
	 1）更改端口号
		server.port=8083
	 2）自定义banner，服务启动的时候，有一个spring banner的输出如下：
		  .   ____          _            __ _ _
		 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
		( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
		 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
		  '  |____| .__|_| |_|_| |_\__, | / / / /
		 =========|_|==============|___/=/_/_/_/
		
		 :: Spring Boot ::                (v3.3.1)
	    这个banner也可以修改，可以在baidu上搜 springboot banner生成器，会有很多生成器，
	    比如：https://www.bootschool.net/ascii，把生成的内容贴到properties同目录的banner.txt中即可，不需要配置
	
	 
	-建包，因为springboot是基于约定的，所以这里必须在Demo1Application同级别建包，在其他地方建包，会出问题
         常规的包，domain,dao,service,controller

	-在controller下创建HelloController类,定义一个返回字符串的http请求接口hello,只需要配置上spring相关的注解，其他的springboot已经自动配置了，
	 之后就可以通过/localhost:8080/hello 访问这个接口的页面了

	-打包，使用maven的package命令就可以直接打成jar包，打出来的jar包，可以直接运行，内部包含了tomcat，因此服务就可以启动了
		java -jar xxx.jar
	-总结
	 如上所示，主要有4个部分
		-项目元数据信息：创建的时候输入的project metadata部分，也就是maven的项目基本元素，包括:groupId,artifaciId,version,name,description等
		-parent：继承spring-boot-start-parent的依赖管理，控制版本与打包内容等
			 集成praent后，springboot会统一管理大部分开发第三方库版本，只要是springboot管理的库，在依赖的时候尽量不要设置version
			 官网:Spring Boot->Appendix->Dependency Versions->Version Properties
			 比如log4j2,在官网上可以查到已经由springboot管理了，因此在pom依赖的时候，是不用设置version的


		-dependencies:项目具体依赖，这里包含了spring-boot-start-web，用户实现http接口(该依赖包含了spring MVC)
			      官网对它的描述是:使用spring MVC构建web(包含RESTful)应用程序入门者，使用tomcat做为默认嵌入式容器
			      spring-boot-starter-test用于编写单元测试的依赖包。
		-build：构建配置部分。默认使用了spring-boot-maven-plugin,配合spring-boot-starter-parent就可以把spring boot应用打包成jar来直接运行
		
9、springboot自动装配原理
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-pom文件内容分析
	 1)parent标签内容是spring-boot-starter-parent，点击打开这个pom文件发现还有一个根的parent org.springframework.boot
	   properties标签中可以看到管理了的大量的依赖库的版本以及核心依赖的第三方库，一般在springboot依赖的包这里都有，外部继承以后不需要指定版本
	   resource标签中指定了资源文件的位值和命名规范	

	 2)启动器
	   spring-boot-starter-web，它会自动装配web环境相关的依赖
	   springboot会将所有的功能场景，都封装成一个个的启动器，如果要使用什么功能就只需要找到对应的启动器就可以了，一般都以'spring-boot-stater..'来命名
	   官网->projec->springboot:learn->找到对应版本的Reference Doc 搜索 starters，在Build System里面能找到所有的启动器

	-主程序
	 @SpringBootApplication，用来标注这个类是springboot的应用
	 这是个组合注解主要包括
	 	-@SpringBootConfiguration:springboot的配置，它内部由@Configuraton 和 @Component来管理的，这是两个spring注解，说明这个类是个配置类，同时也是一个组件
		-@EnableAutoConfiguration:自动配置
			->@AutoConfigurationPackage:自动配置包
				->@Import({AutoConfigurationPackages.Registrar.class}) 自动配置'包配置'
			->@Import({AutoConfigurationImportSelector.class}) : 自动配置导入选择
				->getCandidateConfigurations，通过这个函数导入了配置资源文件，这里可以看到被SpringBootApplication标注的类会做为当前资源的classloader
							      其实目的就是为了把启动类下的所有资源都加载。
							      这里面在Assert里提到了  META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
							      这个文件在对应类的包里的META-INF下，里面可以看到所有配置的需要自动加载的类	 
		-@ComponentScan
	 如图：9_自动配置原理分析,springboot所有的自动配置都在启动类中被扫描并加载,同时还得导入对应的**start** 启动器就会自动装配并生效 	

	-总结
	 1)springboot在启动的时候，从类路径下/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports获取指定的值
	 2)将这些自动配置的类导入容器，自动配置就会生效
	 3)以前在使用spring的时候需要自动配置的组件，现在springboot自动去做了
	 4)整合javaEE,解决方案和自动配置的东西都在spring-boot-autoconfigure-x.x.x.jar这个包下
	 5)它会把所有需要导入的组件，以类名的方式返回，使用classloader加载
	 6)容器中也会存在非常多的命名为xxxAutoConfiguation类，导入这些类，就会自动配置相关的组件
	 7)有了自动配置类，就免去了很多手动工作
	 8)每个自动装配的组件springboot都对应了一个starter，官网文档：Spring Boot->Reference->Developing with Spring Boot->Build Systems:Starters
	   中列举了所有支持的starter



10、主启动类
	主启动类运行后，会启动一个服务
	-SpringApplication这个类组要做了以下4个事情,如图:10_主启动类启动流程
	 1)推断应用类型是普通的项目还是web项目
	 2)查找并加载所有可用初始化器，设置到initializers属性中
	 3)找出所有的应用程序监听器，设置到linterners属性中
	 4)推断并设置main方法的定义类，找到主运行的类，根据主运行类路径找到其他业务类，所以其他业务类必须在主类包之下
	 
11 springboot的全局配置文件
	-Spring Boot允许您将配置外部化，以便您可以在不同的环境中使用相同的应用程序代码。您可以使用各种外部配置源，包括Java properties文件、YAML文件、环境变量和命令行参数。	
	-配置的文档在 官网->Spring Boot->Reference->Core Features->Externalized Configuration中
	 一般来讲官方推荐使用YAML配置文件，不推荐proterties文件来配置

	--详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-删除springboot自动生成的 application.properties文件，新建一个application.yaml文件

	-springboot使用一个全局的配置文件，配置文件名称是固定的
		-application.properties，语法结构： key=value
		-application.yaml ，语法结构：key:[空格]value
         配置文件作用：修改springboot自动配置的默认值

	-YAML 是 "YAML Ain't a Markup Language"（YAML 不是一种标记语言）的递归缩写。
	 在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。
	 YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。
	 它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。
	 YAML 的配置文件后缀为 .yml，如：runoob.yml 。
	
	-标记语言
	 以前的配置文件，大多使用xml来配置，比如一个简单的端口配置
	 YAML：
		#修改默认的端口号
		server:
		  port: 8083	
	 xml:
		<server>
			<port>8083</port> 
		</server> 
	
12、YAML语法
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-基础语法：k:[空格]v
	 以此来表示一个键值对(空格不能省略)，以空格的缩进来控制层级关系，只要是左边对齐的一类数据都是同一个层级的。
	 注意：属性和值的大小写都是十分敏感的，例子
		#修改默认的端口号
		server:
		  port: 8083
		  path: /hello		

	-值的写法
	 字面量:普通的值[数字，布尔值，字符串]
	 	k: v
	 字面量直接写在后面就可以，字符串默认不用加上双引号或者单引号
	 "" 双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思
	 比如：
		name: "hello \n world" ,输出 ： hello 换行 world

	-对象的写法
		#对象的写法
		student:
		  name: sandro
		  age: 44
		 
		#对象的另一种写法  
		student: {name: sandro,age : 44}    

	-数组的写法
		#数组的写法
		names:
		  - sandro
		  - joy
		  - jess
		#数组的另一种写法
		names: [sandro,joy,jess]	
	
	-YAML 不直接支持 el 表达式，因为 YAML 是一种非常简洁的数据描述语言，而 el 表达式是一种用于在 Java 应用程序中进行表达式求值的语言。
	 如果需要在 YAML 配置文件中使用类似 el 表达式的功能，可以使用 Spring 的 ${} 占位符功能，这与 el 表达式的功能类似。
	 	uuid: ${random.uuid}


	-注意：YAML对空格和缩进的要求及其严格，一定要注意

	-YAML是可以方便的注入到java对象中
	 使用spring源生的注解方式注入数据：
	 sandro.springboot.demo1.domain包下定义两个类User和UserInfo都是普通的pojo其中有各种类型的属性，使用@Component注解添加到spring的组件中，由spring统一管理
	 	-使用spring源生的注解方式注入数据：
	 	 UserInfo使用@Value注解，当声明对象时候可以使用@Autowired 注解初始化数据。
	 	 在Demo1ApplicationTests测试类中可以声明UserInfo对象(使用@Autowired注解托管给spring管理)，并输出UserInfo对象的值。
	 	 使用spring注解的方式注入数据，数据分散在代码各处，十分影响可读性。

		-使用YAML注入数据,可以在yaml配置文件中统一配置数据，更便于管理
	         在application.yaml文件中初始化数据
			defaultuser:
			  name: sandro
			  age: 44
			  male: true
			  birthday: 2024/07/04
			  map: {key1: value1,key2: value2}
			  list:
			    - code
			    - music
			    - girl
			  userInfo:
			    desc: 默认信息${random.uuid}
			    money: 10			
		 在User类上使用@ConfigurationProperties(prefix = "defaultuser")注解，该注关联了User类和YAML中的属性名，这样就可以在yaml文件中定义数据并注入对象了
		 测试类Demo1ApplicationTests.testUser中测试效果

		-松散绑定
		 sandro.springboot.demo1.domain.Manager类中定义了两个变量，变量名称由两个单词组成第二个单词首字母大写如下：
			private String managerName;
			private int managerId;

		 yaml数据绑定的时候可以使用 “-” 连接变量中的两个单词
			default-manager:
			  manager-name: 管理员
			  manager-id: 88
		 松散绑定让变量名称在java源码和yaml配置文件中都更易读 
	 
	-spring-boot-configuration-processor依赖，
		<dependency><!--yaml文件中属性检查工具，不接入的话，yaml在使用自定义的属性时会爆红-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
		</dependency>

13、JSR303校验
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-测试方法：Demo1ApplicationTests.testPerson();
	-springboot中可以用@validated来指定需要校验数据的类或者方法，如果数据异常则会统一抛出异常，方便异常中心统一处理
	 JSR303校验是一组javax提供的规范，由各种注解组成，比如@Email使用来校验邮箱格式的。@NotEmpty，被注释的字符不能为空
	 比较常用的是@Pattern，验证字符串是否满足正则表达式
	-pom依赖:
		<dependency><!--springboot提供的 JSR303校验starter-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		
	 比如：sandro.springboot.demo1.domain.Person类，让email字段只支持Email格式
		@Component
		@ConfigurationProperties(prefix = "person")
		@Validated //JSR303数据校验
		public class Person {
		
		    @Email //email格式校验
		    private String email;		
		    ...
	        }

	       为了便于测试，使用yaml配置文件初始化数据，也可以直接new 一个Person对象，给email赋值来测试
			person:
			  email: abcd
	 @Email注解是用来校验字符串是否是email格式的 ，此时会抛出异常 Field error in object 'person' on field 'email': rejected value [abcd]; 
	 改成正常的email格式之后就可以正常赋值了			

14、配置文件的位值
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-一般来讲配置文件的存放位值是：springbootDemo/demo1/src/main/resources/application.yaml
	 根据官网的描述配置文件也可以方在其他位值：Spring Boot->Reference->Core Features->Externalized Configuration
	 1)The classpath root,这个就是resources/目录，默认就是这个目录
	 2)The classpath /config package, 比如:  /springbootDemo/demo1/src/main/resources/config/application.yaml
	 3)The current directory : 比如：/springbootDemo/demo1/application.yaml
	 4)The config/ subdirectory in the current directory,比如: /springbootDemo/demo1/config/application.yaml
	 5)Immediate child directories of the config/ subdirectory,config目录下的直接子目录,比如：/springbootDemo/demo1/config/xx/application.yaml
	
	-这5个位值都有优先级，如果都配置了，列表按优先级排序（较低项目的值将覆盖较早项目的值），比如5)config目录下的直接子目录会覆盖前4个位值的配置文件
	 默认的位值，实际上是最容易被覆盖的。

15、多环境配置文件
	-详见：/projects_j2ee/springboot_exam/springbootDemo/工程的 demo1模块
	-实际开发中可能会有多个配置文件用于不同的环境，比如开发环境，正式环境等
	 可以使用多个配置文件，配置文件要以application开头

	-比如新建一个yaml文件用于测试环境：/springbootDemo/demo1/src/main/resources/application-test.yaml	 
	 再建立一个发布环境的配置文件：/springbootDemo/demo1/src/main/resources/application-release.yaml
	 默认springboot会找application.yaml,因此在默认配置文件指定一下当前用哪个文件即可
		#springboot的多环境配置，可以选择激活哪个配置文件
		spring:
		  profiles:
		    active: release #不需要写文件的全名，只要写"application-"后面的部分就可以		

	-使用一个yaml配置文件配置多环境
         yaml可以使用"---"来分隔多个部分，给每个部分命名，第一个部分优先级最高，通过指定spring.profiles.active来激活某个部分的配置信息

		spring:
		  profiles:
		    active: release #激活release环境名对应的部分
		
		---
		person:
		  email: test@163.com
		spring:
		  config:
		    activate:
		      on-profile: test #定义test环境名
		
		---
		person:
		  email: release@163.com
		spring:
		  config:
		    activate:
		      on-profile: release #定义release环境名	
	
16、配置文件生效的基本原理
	-在第9部分，springboot自动装配原理，中提到过，springboot在启动的时候装配的类在下面这个文件中
	 /spring-boot-autoconfigure/3.3.1/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
		org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration
		org.springframework.boot.autoconfigure.aop.AopAutoConfiguration
		org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
		org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration
		org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration
		org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration
		org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration
		org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration
		org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration
	        ....
	 这里列出了所有xxxAutoConfiguration都是自动装配的接口类，springboot会根据实际情况逐个执行，把对应的组件装配的容器中并自动配置
	 这些xxxAutoConfig都预留出了接口可以在application.yaml配置文件使用
 	 比如：org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration
	 找到这个类的代码可以看到如下部分:
		@AutoConfiguration //表示这是一个自动配置类
		@EnableConfigurationProperties({ServerProperties.class})//自动配置的配置属性,
		@ConditionalOnWebApplication( //这是spring的底层注解，根据不同的条件来判断当前配置或者类是否生效
		    type = Type.SERVLET
		)
		@ConditionalOnClass({CharacterEncodingFilter.class})//是否有CharacterEncodingFilter.class，如果没有不能配置
		@ConditionalOnProperty(////是否有server.servlet.encoding的值是enabled，如果不是不能配置
		    prefix = "server.servlet.encoding",
		    value = {"enabled"},
		    matchIfMissing = true
		)
		public class HttpEncodingAutoConfiguration {
			...
		}
	 @ConditionalOnxxx是spring判断环境的注解，如图：16_spring的ConditionalOnxxx注解
	 从这里可以看到ServerProperties.class是用来关联属性的，在这个类里可以看到下面的内容
		@ConfigurationProperties(
		    prefix = "server",
		    ignoreUnknownFields = true
		)
		public class ServerProperties {
			...
		}
	 这里可以看到prefix是server,因此在application.yaml中输入server. 就会提示这个类可以配置的全部参数了,如图：16_IDEA中yaml提示
	 这些配置接口可以在官网中查到具体说明： Spring Boot->Appendix->Common Application Properties

	-总结：
		1)springboot启动会加载大量的自动配置类
		2)确定一下需要的功能有没有在springboot默认写好的自动配置类中
		3)再去看这个自动配置类中配置了哪些组件(只要是要用的组件存在其中，就不需要手动配置了)
		4)给容器中自动配置类添加组件的时候会从properties类中获取某些属性，只需要在配置文件中指定这些属性的值即可
          		xxxAutoConfiguratrion:自动配置类，给容器添加组件
	  		xxxxProperties:封装配置文件中相关属性 这些属性 和application.yaml中的属性值都是一一对应的
	
	-debug
	 在application.yaml中设置 
		debug: true #设置debug可以看到哪些装配类是生效的
	 执行后会看到 CONDITIONS EVALUATION REPORT,分为三类 
		-Positive matches,自动配置类启用并且生效的组件，使用不同启动器生效的组件都是不一样的
				  通过启动的组件可以大概分析当前的框架可以使用哪些组件
		-Negative matches，自动配置类没有启用的组件
				   分析出哪些组件没有生效，就去找对应的包，看哪些starter启动器能包含这个包，通过启动器来自动装载这些包
		-Exclusions，没有条件被排除的组件

17、springboot web开发			
	-使用springboot开发的基本步骤
		1)创建应用，选择模块
		2)修改基本配置
		3)业务开发
	
	-springboot自动装配：通过xxxAutoConfiguration向容器中自动装配组件
			     装配的过程中根据@ConditionalOnxxx,判断是否需要装配
	-通过application.yaml的配置对应xxxProperties进行自定义内容

	-web开发还需要做的事情
	 静态资源导入：比如html,css,js脚本等
	 首页定制
	 模板引擎，比如freemarker Thymeleaf等
	 装配扩展springMVC
	 数据的增删改查
	 拦截器
	 国际化

18、springboot web开发-静态资源导入
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	 
	-resources目录下默认有两个目录
		static:放资源，css,html,js等
		templates:放模板，比如freemarker的模板，Themeleaf模板等
	 除此之外还有其他很多地方可以放置静态资源

	-从源码处查找资源目录
	 通过maven依赖可以看到，spring-boot-starter-web 启动器会自动装配spring MVC(org.springframework:spring-webmvc),关于项目的资源也都由spring MVC来管理
	 自动装配配置文件中 spring-boot-autoconfigure-3.3.1.jar/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
	 可以看到org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration这个装配类
	 在这个类里可以找到  @EnableConfigurationProperties({WebProperties.class}) 
	 继续在WebProperties类中可以看到 配置属性别名 ：@ConfigurationProperties("spring.web")

	-webjars
	 springboot支持自动加载webjars的静态库
	 在WebMvcAutoConfiguration中的addResourceHandlers方法：
		//这是一个资源目录查找的方法
	        public void addResourceHandlers(ResourceHandlerRegistry registry) {
	            if (!this.resourceProperties.isAddMappings()) {//这里判断如果用户使用application.yaml配置了资源路径，那么就不会再使用默认路径了
	                logger.debug("Default resource handling disabled");
	            } else {
			//这里先去加载webjar路径
	                this.addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(), "classpath:/META-INF/resources/webjars/");
			//这里是通过mvcProperties获取静态资源路径
	                this.addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
	                    registration.addResourceLocations(this.resourceProperties.getStaticLocations());
	                    if (this.servletContext != null) {
	                        ServletContextResource resource = new ServletContextResource(this.servletContext, "/");
	                        registration.addResourceLocations(new Resource[]{resource});
	                    }
	
	                });
	            }
	        }
	 webjars是一套通过maven来管理静态资源的技术方案，官网https://www.webjars.org/，在这里可以查找比如jquery,extjs,vue等js库
	 比如jquery的坐标
		<dependency>
		    <groupId>org.webjars.npm</groupId>
		    <artifactId>jquery</artifactId>
		    <version>3.7.1</version>
		</dependency>
	 配置到pom后，下载，会看到jquery是以jar包的形式引入到项目中的，如图:18_webjars资源目录
	 可以看到jquery的资源库就在/META-INF/resources/webjars/下，this.mvcProperties.getWebjarsPathPattern() 返回的是"/webjars/**"
	 因此如果要通过web访问这个js路径就是：/webjars/jquery/3.4.1/dist/jquery.js，比如：http://localhost:8083/webjars/jquery/3.4.1/dist/jquery.js

	-mvcProperties的静态资源路径
	 除了webjars以外，springboot还会加载mvcProperties.getStaticPathPattern()的静态资源路径，这个路径是/**,
	 mvcProperties对应的是WebMvcProperties中定义的路径，这里可以看到使用的是WebProperties.Resources resourceProperties中默认的路径
		private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{"classpath:/META-INF/resources/", "classpath:/resources/", "classpath:/static/", "classpath:/public/"};
	 
	-总结
	 springboot可以识别以下几个静态资源的目录
	 1)/resources/public,它对应的web路径是根路径，比如:http://localhost:8083/hello1.js
	 2)/resources/static,它对应的web路径是根路径，比如:http://localhost:8083/hello2.js
	 3)/resources/resources,它对应的web路径是根路径，比如:http://localhost:8083/hello3.js
	 4)classpath:/META-INF/resources/webjars/,这个是springboot自动加载webjar库的路径，对应的路径是/webjar/**,比如：http://localhost:8083/webjars/jquery/3.4.1/dist/jquery.js
	 5)/** ,/resources/目录下的所有路径也可以包含进来

	 resources/resources里的优先级最高，其次是/resources/static，最后是/resources/public
	 一般来讲，public放一些库文件，比如js库，static放一些资源文件比如图片等，resources下放的是upload上传的文件

	 官网文档路径 Spring Boot->Reference->Web->Servlet Web Applications : Static Content


	 
	-自定义路径
	 如果在application.yaml文件中自定义了路径，则不会加载默认路径了
		#自定义资源文件路径  
		  mvc:
		    static-path-pattern: /sandro/**,classpath:/hello/

18、springboot web开发-首页定制
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	-官网文档：Spring Boot->Reference->Web->Servlet Web Applications:Welcome Page
	 Spring Boot同时支持静态和模板化欢迎页面。它首先在配置的静态路径中查找一个index.html文件。如果找不到索引模板，则会查找索引模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。
	 首页index.html可以放在任意静态路径下，比如放在 /resources/public中，springboot就会自动加载了。

	-源码
	 在WebMvcAutoConfiguration类中的welcomePageHandlerMapping方法，定义了首页的创建，这个方法被注入到@Bean里了，被springboot管理
	 	
        	private <T extends AbstractUrlHandlerMapping> T createWelcomePageHandlerMapping(ApplicationContext applicationContext, 
											FormattingConversionService mvcConversionService, 
											ResourceUrlProvider mvcResourceUrlProvider,
											WelcomePageHandlerMappingFactory<T> factory) {
            		TemplateAvailabilityProviders templateAvailabilityProviders = new TemplateAvailabilityProviders(applicationContext);
			//这里可以看到首页的资源文件是可以使用WebMvcProperties映射的属性，在application.yaml文件中自定义
            		String staticPathPattern = this.mvcProperties.getStaticPathPattern();
            		T handlerMapping = factory.create(templateAvailabilityProviders, applicationContext, this.getIndexHtmlResource(), staticPathPattern);
            		handlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider));
            		handlerMapping.setCorsConfigurations(this.getCorsConfigurations());
            		return handlerMapping;
        	}	 
		
	 在WebMvcAutoConfiguration类中的getIndexHtmlResource方法中可以看到首页的文件名是index.html

	-使用controller跳转templates目录下的index.html
	 除了把静态的index.html放到资源文件夹下由springboot自动匹配以外，常规的使用方法是把index.html放到templates目录下，配合模板引擎(比如freemarker,thymeleaf等)动态加载
	 放在templates目录下的index.html必须使用controller跳转
	 
	 新建一个IndexController类，放在sandro.springboot.web.controller包下，对应的index.html放到template下

19、springboot web开发-默认图标配置
         -详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
         -官网文档：Spring Boot->Reference->Web->Servlet Web Applications:Custom Favicon
	  与其他静态资源一样，Spring Boot会在配置的静态内容位置中检查favicon.ico。如果存在这样的文件，它将自动用作应用程序的图标。

20、springboot web开发-thymeleaf模板引擎
	-官网：https://www.thymeleaf.org，文档：usingthymeleaf.pdf
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	-springboot打包是jar包，同时使用的是嵌入式的tomcat，因此暂时不支持jsp
	 因此springboot需要结合模板引擎来制作页面，比较常见的是freemarker，thymeleaf,springboot推荐使用thymeleaf
	
	-因为springboot已经集成了thymeleaf的自动装配所以使用thymeleaf只要maven依赖对应的启动器即可，不需要额外配置
	 	<dependency><!--springboot推荐的模板引擎thymeleaf启动器，相比freemarker功能更强大，-->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>

	-模板引擎的主要功能是将java中的数据注入到页面中，返回给使用者，如图20_模板引擎

	-thymeleaf官网：https://www.thymeleaf.org/
	 github中 thymeleaf主页：https://github.com/thymeleaf/thymeleaf
	 springbboot官网：Spring Boot->How-to Guides->Hot Swapping：Thymeleaf Templates  ，这里也只是提供相关的配置类名，让使用者自己读代码去了解如何配置
	
	-ThymeleafAutoConfiguration自动装配
	 在这个类上可以看到@EnableConfigurationProperties({ThymeleafProperties.class})注解
	 说明ThymeleafProperties是绑定application.yaml中的属性，这个类里声明的属性名是spring.thymeleaf，因此可以使用spring.thymeleaf提供的相关接口修改默认配置了
		@ConfigurationProperties(prefix = "spring.thymeleaf")
	 从这里可以看到，默认的模板后缀是.html,模板文件要放到templates目录下，默认编码是UTF-8。
	
21、springboot web开发-thymeleaf基础语法
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	 controller:/springbootDemo/web_demo/src/main/java/sandro/springboot/web/controller/IndexController.java
	 模板：/springbootDemo/web_demo/src/main/resources/templates/index.html

	-thymeleaf可以替换所有的html元素，在html中必须要引入它的约束和命名空间
	 使用thymeleaf的语法必须要使用“th:“来接管html元素 ，比如 th:元素名

22、springboot web开发-MVC配置原理
	-详见：/projects_j2ee/springboot_exam/springbootDemo 工程的web_demo
	 
	-mvc的官网文档：Spring Boot->How-to Guides->Spring MVC
	
	-Spring Boot有许多启动器，其中包括Spring MVC。请注意，不要直接maven依赖Spring MVC,最好直接依赖Spring MVC 的 starter
	 
	-sandro.springboot.web.config.MyMvcConfig,通过扩展spring mvc实现自定义视图解析器MVC配置类

	-在spring mvc自动装配类WebMvcAutoConfiguration中搜索@EnableConfigurationProperties注解，可以找到WebMvcProperties类它对应的application.yaml配置是“spring.mvc”
	 在WebMvcProperties可以看到spring mvc 提供了spring.mvc.format.date,spring.mvc.format.time和spring.mvc.format.date-time三种事件格式化的配置
	 每种配置都有默认的格式
	 在WebConversionService类种，对这三种格式进行了读取，比如默认date的格式是"yyyy-MM-dd" 
	
	-Springboot在自动配置很多组件的时候，先看容器中有没有用户自己配置的(如果用户字节配置@bean)，如果有就用用户配置的，如果没有就用自动配置的，
	 如果有些组件可以存在多个比如上面的视图解析器，就将用户配置的和自动配置的组件默认的组合起来

	-要想扩展使用spring MVC，需要编写一个@Configuration注解类，并且要实现WebMvcConfigurer接口类
	 MyMvcConfigForViewController，扩展一个controller
	 注意，不能在自定义WebMvcConfigurer的类上使用@EnableWebMvc，因为它会从容器中获取所有的webmvcconfig而在WebMvcAtuoConfiguration中使用了ConditionalOnMissingBean去判断
	 是否有WebMvcConfigurationSupport，如果有的话就不生效。

	-在springboot中有很多xxxConfiguration帮助用户仅进行扩展配置，只要有这个类，就需要关注扩展了哪些东西

23、springboot web开发-网站准备
	-详见:projects_j2ee/springboot_exam/web_site
	 在github上搜索一些静态html网页，新建项目放到对应的资源文件夹下

	-domain层，sandro.website.domain，使用Lombok
	 Lombok（Project Lombok）是一个用于 Java 编程语言的开源库，旨在减少 Java 代码中的冗余和样板代码，提高开发人员的生产力。
	 它通过使用注解来自动生成 Java 类的常见方法和代码，从而使开发人员能够编写更简洁、更具可读性和更易维护的代码。
	 Lombok 的主要目标是简化 Java 开发，减少样板代码，使代码更加精炼，从而提高开发效率。
	 Lombok的版本已经由springboot统一管理了，因此，依赖的时候不需要设置version
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</dependency>	
	 详见：sandro.website.domain.*	
	 
	-html模板 ，thymeleaf改造
	 html标签中加入 xmlns:th="http://www.thymeleaf.org"
	 link，img,script等标签里的当前项目的资源的 url 改造成 thymeleaf格式
		<link href="css/H-ui.css" rel="stylesheet" type="text/css"/> 改造成 <link th:href="@{/css/H-ui.css}" rel="stylesheet" type="text/css"/>
	 改完以后，如果根地址变化，比如在applicationl.yaml中
		server:
  		  servlet:
                    context-path: /manager
	 把根目录修改，也不影响页面的使用,所以尽量使用thymeleaf对资源路径进行标准化管理

24、springboot web开发-国际化
	-详见:projects_j2ee/springboot_exam/web_site
	-准备
	 1)确保IDEA的File Encodings是utf-8
	 2)在resources目录下建立多语言目录：i18n
	 3)在i18n下面建立两个多语言配置文件login.properties 和 login_zh_CN.properties,建立后，IDEA会自动把这两个文件聚合成一个虚拟目录Resources Bundle 'login'(实际上没有这个目录)
	   右键Resources Bundle 'login'->new ->Add Properties Files to Resource Bundle,在弹出的对话框内点击Locales to Add,下面的"+"设置文件名"en_US",在建立一个英文的配置文件
	   IDEA提供了一个Resource Bundle Editor插件能够方便的配置多语言文件settings >> Plugins >> 搜索Resource Bundle Editor >> 点击install进行插件安装就可以了，不需要重启。
	   如图：24_Resource_Bundle_Editor	 
	 4)新建一个LoginController的类，指定路径是login和模板login.html ,login.html资源文件中进行thymeleaf改造	

	-MessageSourceAutoConfiguration,国际化转换自动配置类
	 在这里可以看到配置属性名是
	    @Bean
	    @ConfigurationProperties(
	        prefix = "spring.messages"
	    )
	 对应的属性类是MessageSourceProperties，这里可以看到默认的编码格式是utf-8，basename设置多语言文件路径
	 在application.yaml中设置多语言文件路径：
		#设置登陆页面的多语言文件路径
		spring:
		  messages:
		    basename: i18n.login,i18n.index
	 spring.messages.basename支持逗号分隔的位置列表，可以是包限定符，也可以是从类路径根解析的资源。
	 默认文件是 messages.properties

	-在页面中使用thymeleaf国际化消息表达式 #{...}来设置语言
		<input name="" type="submit" class="btn radius btn-success btn-big" th:value="#{btn.login}">
		<input name="" type="reset" class="btn radius btn-default btn-big" th:value="#{btn.cancel}">

	-springboot多语言切换
	 -WebMvcAutoConfiguration.localeResolver是多语言解析器，这里可以看到如果用户有配置多语言信息，则使用用户的，没有则使用默认
	  这个默认的解析器是AcceptHeaderLocaleResolver
	  AcceptHeaderLocaleResolver实现了LocaleResolver解析器
	  因此实现一个自己的多语言解析器，并扩展spring mvc，来实现多语言切换的功能

	 -新建config包，在这个包下实现LocaleResolver这个类，MyLocaleResolver ,以及实现WebMvcConfigurer接口的MyMvcConfig类
	  实现LocaleResolver接口需要实现它的两个方法，可以参考spingboot中 AcceptHeaderLocaleResolver的写法
	  login.html页面实现如下，使用thymeleaf标签，参数 l 传递中英文 
    		<a th:href="@{/login.html(l='zh_CN')}">中文</a>
    		<a th:href="@{/login.html(l='en_US')}">English</a>	

25、springboot web开发-登陆功能实现
	-详见:projects_j2ee/springboot_exam/web_site
	-页面登陆的form表单改为thymeleaf标签
		<form th:action="@{user/login}" method="post">
	-LoginController中实现userLogin方法用于登陆业务,登陆成功后需要设置session，用于后续的页面判断
	 登陆失败需要在页面设置失败提示
	 <p th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p>
		 
26、springboot web开发-登陆拦截器
	-详见:projects_j2ee/springboot_exam/web_site
	
	-登陆拦截器的作用是只有登陆成功的用户才能访问用户页面，否则只能返回到登陆页面
	 
	-在config包下实现 LoginHandlerInterceptor，根据session中的登陆信息判断是否已经登陆
	 在MyMvcConfig中，接入LoginHandlerInterceptor拦截器
	 
	-在页面中可以直接使用thymeleaf的sesssion工具类获取登陆的用户名：[[${session.loginUser}]]

27、springboot web开发-提取公共页面
	-详见:projects_j2ee/springboot_exam/web_site
	-对应页面: 首页 > 用户中心 > 用户管理 ,user-list.html
	 controller:UserContorller
	
	-使用thymeleaf的fragment标签，定义通用页面元素
	 在首页默认页面"我的桌面"(welcome.html)中，<footer>标签定义了每个页面最下部分的内容，如果想把这部分内容统一定制，其他标签页面都统一使用，可以使用fragment
	 例如在welcome.html中的footer标签定义为thymeleaf 的 fragment
		<footer th:fragment="commonfooter">
		  <p>感谢jQuery、layer、Validform、UEditor、My97DatePicker、Font Awesome、Datatables、jquery.fileupload、Lightbox插件
		     <br>Copyright &copy;2015 H-ui.admin v2.0.1 All Rights Reserved.
		     <br>本后台系统由<a href="http://www.h-ui.net/" target="_blank" title="H-ui前端框架">H-ui前端框架</a>提供前端技术支持
		  </p>
		</footer>		 
	 定义好之后，比如想要在user-list.html中引用这个fragment
		<div th:insert="~{welcome::commonfooter}"></div>		
	 简单方法可以定义一个div标签，使用insert函数，~代表 是一个fragment，welcome是定义fragment的页面路径，commonfooter是fragment的id

	 更合理的方式是单独定一个html在这个html中定义所用通用标签页面,比如在templates目录下定一个common目录,新建一个commons.html
	 把通用的页面元素都放到这里，如下：
		<!DOCTYPE html>
		<html xmlns:th="http://www.thymeleaf.org">
		<footer th:fragment="commonfooter">
		    <p>感谢jQuery、layer、Validform、UEditor、My97DatePicker、Font Awesome、Datatables、jquery.fileupload、Lightbox插件
			<br>Copyright &copy;2015 H-ui.admin v2.0.1 All Rights Reserved.<br>
		        本后台系统由<a href="http://www.h-ui.net/" target="_blank" title="H-ui前端框架">H-ui前端框架</a>提供前端技术支持</p>
		</footer>
		</html>	
	 其他页面引用的时候使用
		<div th:insert="~{/common/commons::commonfooter}"></div>
	 来引用就可以了

	-使用thymeleaf的fragment标签，定义通用页面元素并传递参数
	 实际情况中往往更复杂，引用的时候会传递一些参数以保证一些个性化的展示
	 比如每个子页面中都有一个顶部的导航信息，把这部分拆出来放到commons.html中,把它定义为一个commontop的fragment标签，如下
		<nav class="Hui-breadcrumb" th:fragment="commontop">
		    <i class="icon-home"></i> 首页 <span class="c-gray en">&gt;</span>
		    用户中心 <span class="c-gray en">&gt;</span>
		    [[${pagename}]]  <!--外部调用commontop需要传递一个pagename参数在这里显示-->
		    <a class="btn btn-success radius r mr-20" style="line-height:1.6em;margin-top:3px" href="javascript:location.replace(location.href);" title="刷新" >
		        <i class="icon-refresh"></i>
		    </a>
		</nav>
	 调用的时候需要传递pagename参数，如下：
		<div th:insert="~{/common/commons::commontop(pagename='用户管理')}"></div>

28、springboot web开发-页面中显示列表内容
         -详见:projects_j2ee/springboot_exam/web_site
         -对应页面: 首页 > 用户中心 > 用户管理 ,user-list.html
          controller:UserContorller
	
	 -在user-list页面中需要显示所有后台查询的用户信息，可以使用thymeleaf的 th:each来轮询展示内容
	    <tbody>
	      <tr class="text-c" th:each="u:${allUser}">
	        <td><input type="checkbox" value="1" name=""></td>
	        <td >[[${u.getId()}]]</td>
	
	        <td>
	            <u style="cursor:pointer" class="text-primary" onclick="user_show('10001','360','','张三','user-show.html')">
	              [[${u.getUserName()}]]
	            </u>
	        </td>
	        <td>
	          [[${u.getGender()==1?'男':'女'}]]
	        </td>
	        <td>[[${u.getTelNo()}]]</td>
	        <td>[[${u.getEmail()}]]</td>
	        <td class="text-l">[[${u.getAddress()}]]</td>
	        <td>
	          [[${#dates.format(u.getBirth(),"yyyy-mm-dd HH:mm:ss")}]]
	        </td>
	        <td class="user-status"><span class="label label-success">已启用</span></td>
	        <td class="f-14 user-manage">
		  <a style="text-decoration:none" onClick="user_stop(this,'10001')" href="javascript:;" title="停用">
		    <i class="icon-hand-down"></i>
	         </a> 
	         <a title="编辑" href="javascript:;" onclick="user_edit('4','550','','编辑','user-add.html')" class="ml-5" style="text-decoration:none">
		    <i class="icon-edit"></i>
		 </a> 
		 <a style="text-decoration:none" class="ml-5" onClick="user_password_edit('10001','370','228','修改密码','user-password-edit.html')" href="javascript:;" title="修改密码">
		   <i class="icon-key"></i>
		 </a> 
		 <a title="删除" href="javascript:;" onclick="user_del(this,'1')" class="ml-5" style="text-decoration:none">
		   <i class="icon-trash"></i>
		 </a>
		</td>
	      </tr>
	    </tbody>	  	
	 其中[[${#dates.format(u.getBirth(),"yyyy-mm-dd HH:mm:ss")}]]，这里使用了thymeleaf的dates函数，用于格式化日期

29、springboot web开发-添加用户操作
	-详见:projects_j2ee/springboot_exam/web_site
	-对应页面: 首页 > 用户中心 > 用户管理 (user-list.html)中的“添加用户” 弹出 “添加用户”弹框(user-add.html)
	-controller:UserContorller

	-springboot时间格式
	 页面传递过来的时间格式,如果要使用Date来接收，默认的格式是yyyy/mm/dd
	 但是一般的页面js控件的格式都是 yyyy-mm-dd，因此需要重新配置时间格式，以方便接收日期数据
	 源码位值：
		WebMvcAutoConfiguration
		  ->@EnableConfigurationProperties({WebMvcProperties.class, WebProperties.class})
		      @ConfigurationProperties(
		         prefix = "spring.mvc"
		      )
		    ->WebMvcProperties
		      ->public static class Format
		这里定义了三种格式配置：date，time，dateTime
	 因此在application.yaml中通过配置这三个参数就能方便的使用Date类来接收时间字符串了
		spring:
		  mvc:
		    format:
		      date: yyyy-MM-dd  #设置时间格式	

30、springboot web开发-修改信息
         -详见:projects_j2ee/springboot_exam/web_site
         -对应页面: 首页 > 用户中心 > 用户管理 (user-list.html)中编辑按钮 弹出 “修改信息”弹框(user-edit.html)
         -controller:UserContorller

31、springboot web开发-删除用户信息
	-详见:projects_j2ee/springboot_exam/web_site
	-对应页面: 首页 > 用户中心 > 用户管理 (user-list.html)用户列表中点击删除
	-controller:UserContorller

32、springboot web开发-404页面配置
	-详见:projects_j2ee/springboot_exam/web_site

	-在templates目录下新建一个error文件夹
	 在这个文件夹下创建404.html，以后404错误都会展示这个页面，比如输入一个错误路径 http://localhost:8083/aaa
	 类似的500错误页面也是同样的方法

32、springboot web开发-用户退出
        -详见:projects_j2ee/springboot_exam/web_site	

	-对应页面，index.html中的“退出”按钮
	-controller:UserContorller
	
33、常见web前端公共资源
	-模板：别人写好的，拿过来修改即可
	-框架：组件，需要手动组合拼接，比如Bootstrap,Layui,semantci-ui，X-admin
	       使用组件，需要大概了解如下几个部分：
		-栅格系统，一般是把整个页面分成几个大的部分，要先了解每个部分是如何展示的
		-导航栏
		-侧边栏
		-表单

34、springboot JDBC
	-详见:/projects_j2ee/springboot_exam/spring_jdbc_demo

	-对于数据访问层，无论是SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Springboot底层都是采用Spring Data的方式进行统一处理。
	 Spring Data也是spring中与springboot,springcloud等齐名的知名项目
	 Spring Data官网：https://spring.io/  -> projects ->Spring Data
	
	-在springboot中使用数据库相关的启动器，参考文档 Spring Boot->Reference->Developing with Spring Boot->Build Systems中spring-boot-starter-data-xxx相关的启动器

	-springboot的快速建项工具建立一个新的项目
	 https://start.spring.io/  ，依赖的启动器包括JDBC API，MySQL Driver，spring-boot-starter-web

	-自动配置jdbc
	 在application中配置 jdbc和数据库的信息
		spring:
		  datasource:
		    username: sandro
		    password: 12#$qwer
		    url: jdbc:mysql://192.168.0.113:3306/sandro_database?useUnicode=true&characterEncoding=utf-8
		    driver-class-name: com.mysql.cj.jdbc.Driver		

	 com.mysql.cj.jdbc.Driver,是mysql 8的驱动
	 
	-jdbc测试
	 在测试类SpringJdbcDemoApplicationTests.contextLoads()中进行测试
	
	-springboot的默认数据源
	 由与springboot已经自动配置好数据源，因此可以使用@Autowired来注入DataSource实例
	 通过dataSource.getClass()返回的com.zaxxer.hikari.HikariDataSource，可以确认springboot默认的数据源是HikariCP
	 HikariCP 是一个高性能的 JDBC 连接池组件，号称性能最好的后起之秀，是一个基于BoneCP做了不少的改进和优化的高性能JDBC连接池。和它类似的还有druid
	 
	 在选择数据库连接池时。HikariCP和Druid都是优秀的选择，各有其独特的优势和适用场景。
	 HikariCP的主要优点包括：
    		性能优越：HikariCP以其高性能著称，能够最大限度地避免锁竞争，提供快速且稳定的连接服务。
    		轻量级：HikariCP的体积小，仅130kb，启动速度快，非常适合需要快速响应的应用场景。
    		配置简单：HikariCP的配置相对简单，易于部署和使用。

	 Druid的主要优点包括：
    		功能全面：Druid提供了丰富的功能，如性能监控、SQL审计、用户名密码加密等，具有良好的扩展性。
    		监控和扩展性：Druid集合了开源和商业数据库连接池的诸多优秀特性，提供了FilterChain模式的扩展API，便于自定义和监控。

	 选择哪个连接池取决于具体的应用需求。如果应用对性能有极高要求，且希望连接池尽可能轻量级，HikariCP可能是更好的选择。
	 如果应用需要更全面的功能支持和强大的监控工具，Druid则可能更适合。在实际应用中，可以根据具体的性能测试和功能需求来决定使用哪个连接池。
	
	-xxxTemplate:springboot已经配置好的Bean,即拿即用,这些template内部封装好了CURD操作
	 比如org.springframework.boot.autoconfigure.jdbc.JdbcTemplateConfiguration这个类就是自动配置JdbcTemplate实例的类，
	 调用者就可以直接使用@Autowired注解来注入JdbcTemplate类的实例，JdbcTemplate提供了sql语句执行的接口实现
	 redis等也是类似的

	 代码：JDBCController.java  
	 	 
35、springboot 整合Druid数据源
	-springboot jdbc除了默认的HikariCP数据源，也可以方便的配置其他第三方数据源，比如Druid

	-Druid是阿里巴巴开源平台上的一个数据库连接池的实现，结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控
	 号称java WEB当前速度最快的数据源，相比与传统的C3P0,DBCP,Tomcat jdbc等连接池更优秀
	 Druid可以很好的监控DB池连接和SQL的执行情况，天生就是针对监控而生的DB连接池
	 可以说Druid和Hikari都是当前java web上最优秀的数据源
	
	-新建springboot工程：/projects_j2ee/springboot_exam/springboot_druid_demo
	 依赖：Spring Web， JDBC API， MySQL Driver
	 druid依赖：https://mvnrepository.com/artifact/com.alibaba/druid

	-druid-x.x.xx.jar包下重要的一些类路径
		filter:过滤器
		mock:测试相关的类
		pool:池的实现
		     DruidDataSource:druid数据源，这里定义了需要配置的属性
		     DruidDataSourceC3P0Adapter：C3P0适配器 	
		proxy:代理
		sql:封装了CRUD的实现
		    SQLUtils:这里封装了一些sql相关的工具函数，可以使用
		support:提供了一些基础的支持
			比如 hibernate,http,ibatis,json,日志(logging),任务调度(quartz),spring

	-application.yaml配置
		spring:
		  datasource:
		    username: sandro
		    password: 12#$qwer
		    url: jdbc:mysql://192.168.0.113:3306/sandro_database?useUnicode=true&characterEncoding=utf-8&serverTimeZone=UTC
		    driver-class-name: com.mysql.cj.jdbc.Driver
		    type: com.alibaba.druid.pool.DruidDataSource
	 type，用来指定使用druid数据源，指定之后就不会再使用默认的HikariCP数据源了

	-SpringbootDruidDemoApplicationTests.contextLoads(),测试数据源
	 可以看到Autowired的DataSource返回的是com.alibaba.druid.pool.DruidDataSource
	 DataSource中得到的Connection是：com.alibaba.druid.pool.DruidStatementConnection

	-durid配置信息
	 出了常规的配置，druid还提供了更多的功能通过application来配置
    		#配置监控统计拦截的filters，stat:监控统计，log4j:日志记录，wall:防御sql注入
    		#druid日志需要依赖log4j，并配置property ,https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98
		filters: stat,wall,log4j 
	-JDBCController:实现CRUD的操作并映射地址，进行测试

	-DruidConfig,实现druid的配置类，托管给spring管理

36、springboot 整合Mybatis
	-mybatis有专门整合springboot的整合包：MyBatis Spring Boot Starter
	 maven仓库地址 https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter
	 文档：https://github.com/mybatis/spring-boot-starter
	 如果使用springboot的项目生成器建立项目，可以直接选择依赖MyBatis Framework自动依赖这样就不需要纠结版本的问题了。
	 Mybatis中文官网文档 https://mybatis.net.cn/

	-创建spring boot 项目，设置依赖：Spring Web,MySQL Driver,JDBC API,MyBatis Framework 
	 /projects_j2ee/springboot_exam/Mybatis_demo
	
	-配置application.yaml,数据库相关信息
	 在测试类MybatisDemoApplicationTests.contextLoads()中测试是否连接正常。

	-pojo类：User.java
	-Mybatis的 mapper接口类 ：UserMapper，这里定义CRUD等方法
	-resources目录下新建/mybatis/mapper/目录，新建 UserMapper.xml，用来配置UserMapper接口类的实现(参考Mybits中文官网文档-XML映射器)
	-在application.yaml中 配置mybatis 的包路径和.xml文件路径
		mybatis:
		  #配置pojo的包路径  
		  type-aliases-package: sandro.demo.springboot.mybatis.domain
		  #配置mapper.xml的文件路径  
		  mapper-locations:
		    - classpath:mybatis/mapper/*.xml 	 
	-UserController，调用对应方法

37、springboot 整合springSecurity
	-springsecurity是针对spring项目的安全框架，也是springboot底层安全模块默认的技术选型，他可以实现强大的web安全控制
	 相比于另外一个安全框架Shiro，它提供了丰富的功能，社区资源也比Shiro丰富，一般来说中大型的项目都是使用SpringSecurity来做安全框架。
	 小型项目Shiro的比较多，因为相比于SpringSecurity，Shiro的使用更加简单
	 springsecurity主要提供两个功能，以保证web或者java应用的安全
		-认证(Authentication)，验证当前访问系统的时不是本系统的用户，并且要确认具体是哪个用户
		-授权(Authorization)，比如功能权限，访问权限，菜单权限，通过简单的配置可以省略大量拦截器，过滤器的代码
	-官网：https://spring.io/projects/spring-security

	-创建springboot项目：/projects_j2ee/springboot_exam/springsecurity_demo
	 依赖spring web启动器，Thymeleaf,Spring Security


	-默认的登陆操作
	 创建RouterController，用于页面跳转
	 启动服务会看到一个log : Using generated security password: 7727fe31-ab7c-4d91-b47b-a47b4c38e98e
	 因为引入了spring security，默认访问任何路径都需要登陆(spring security内置了一个web的登陆页面),默认的用户是user,这个log就是密码

	-默认的退出登陆
	 根路径/logout,比如 ：localhost:8080/logout
	 登出后，无法再访问任何资源
	
38、springboot 整合 SpringDoc

	-前后端分离，松耦合，甚至可以部署在不同的服务器上
	 vue + springboot是常用的前后端分离的方案
	 后端：后端控制层，controller
	       服务层
	       数据访问层

	 前端：前端控制层，视图层
	 
	 前后端交互： api接口

	 问题：前后端集成联调的时候，前端人员和后端人员无法做到及时协调，最终会导致问题集中爆发
	 解决方案：制定schema，实时更新最新的api,降低集成风险
	           早期使用wrod文档等，但是大团队管理复杂度依然比较高
		   前端常用postman来测试api接口，后端提供接口，需要实时更新的消息及改动
	
	-SpringDoc是一款可以结合SpringBoot使用的API文档生成工具,基于OpenAPI 3
	 和SpringDoc相同的工具还有 smart-doc，swagger,也是目前比较流行的api框架
         swagger 2.0版本和spring boot 3.x版本整合暂时是不行的，因为swagger的依赖底层用的是javax依赖包，而spring boot 3.x版本都是jakarta依赖包
 
	-官网:https://springdoc.cn(中文)
	      https://springdoc.org(英文)	
	-创建springboot项目：/projects_j2ee/springboot_exam/springdoc_demo，依赖spring web
	 添加springdoc依赖	 
		   <dependency>
      			<groupId>org.springdoc</groupId>
      			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
      			<version>2.6.0</version>
   		   </dependency>

	
	 配置好以后，启动服务，并访问地址,http://localhost:8080/v3/api-docs,此时返回的是一个json格式的数据，不同浏览器展示的效果不太一样
         也可以使用swagger的页面展示内容:http://localhost:8080/swagger-ui/index.html          

	-创建MyApiController，使用springdoc的注解完善文档

39、springboot 使用异步任务
	-当一些耗时任务执行的时候，为了提升体验，一般使用异步任务执行，springboot本身就提供异步任务接口，便于使用
	 如果直接开始线程当请求多了以后，线程数太多，系统会不稳定

	-详细见/projects_j2ee/springboot_exam/async_demo
	 创建一个springboot项目，依赖spring web

	-springboot默认是不支持异步任务的，需要手动开启
	 开启方式:在主启动类中使用@EnableAsync注解，如：AsyncDemoApplication
	
	-创建一个Service,并实现一个耗时操作的方法，在方法上使用@Async注解，如:AsyncService
   	 @Async注解是Spring框架提供的一个功能，用于实现方法的异步执行。 通过在方法上添加@Async注解，可以指示Spring框架在另一个线程中异步执行该方法，从而避免阻塞主线程，提高系统的响应速度和吞吐量。
	 
	 @Async注解的工作原理基于Spring AOP（面向切面编程）机制。
	 当Spring容器初始化Bean时，会检查Bean中是否使用了@Async注解，并根据切点创建代理。在调用被@Async注解的方法时，实际上是调用了代理对象，由代理对象将方法的执行交给线程池进行异步执行。

	 在使用@Async注解时，需要注意一些常见的失效场景。
	 例如，主启动类需要添加@EnableAsync注解以开启异步支持；被@Async注解的方法必须是public方法，不能是static或private方法；需要通过@Autowired或@Resource进行注入，不能手动new实例。

	 为了支持@Async注解，通常需要配置线程池。
	 可以通过创建一个配置类（如ExecutorConfig），并在其中定义ThreadPoolTaskExecutor来配置线程池。例如，可以设置核心线程数、最大线程数、队列大小等参数，以满足不同的业务需求。
	 
