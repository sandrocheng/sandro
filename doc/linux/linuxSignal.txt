1、信号（signal）简介
	信号是信息的载体，linux/unix环境下非常古老并经典的通信方式，目前依然是主要的通信手段。
	信号特点：
		简单
		不能携带大量信息
		满足某个特定条件才会产生
	man 7 signal ，查看系统关于signal的介绍。

2、信号的机制
	进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位值，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似——异步模式。
	但信号是软件层面的中断，早期常被成为“软中断”。
	
	每个进程都到的所有信号，都是由内核负责发送的。
	进程A给进程B发送信号示意图：
			
                        +----------+                    +----------+                
		        |   进程A  |                    |   进程B  |
                        +----------+	                +----------+    当信号产生后，内核会执行信号处理
              用户区          |                              ^          函数，信号处理函数执行完以后，会   
            ------------------|------------------------------|--------  返回到信号发生的代码的位值继续往
              内核区          |                              |          下执行。
                              |                              |  
                              |        +----------+          |
                              +------->|   内核   |----------+
                                       +----------+
	
	信号的状态：产生，未决，递达
	1)信号的产生：
		按键产生,如：Ctrl+c ,Ctrl+z,Ctrl+\
		系统调用产生，如：kill,raise,abort
		软件条件产生，如：定时器 alarm
		硬件异常产生，如：非法访问内存（段错误），除0（浮点数例外），内存对齐出错（总线错误）
		命令产生，如：kill命令	
	2）未决：产生和递达之间的状态。主要由于阻塞（屏蔽）导致该状态。
	3）递达：递送并且到达进程。一旦信号递达，进程会暂停运行，一些阻塞的系统函数也会停止，比如sleep,read等函数都会不再阻塞。并产生EINTR错误（详见 man errno）。
	
	信号的处理方式：
		执行默认动作
		忽略信号（丢弃不处理）
		捕捉信号（调用用户自定义的处理函数）
		
	信号的特质：
		信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。
		linux内核的进程控制块（PCB）是一个结构体，task_struct,除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号的相关信息，主要值阻塞信号集和未决信号集。
					
	信号四要素:
		通过 man 7 signal可以查看信号相关信息 
		1)编号:使用kill -l命令可以产看当前系统有哪些信号，不存在编号为0的信号。其中 1~31号信号称为常规信号（也叫普通信号或者标准信号）34~64称为实时信号，驱动编成与硬件相关 
		2)名称 
		3)信号对应的事件 
		4)默认处理动作 
			Term,终止进程
			Ign，忽略信号（默认即时对该中信号忽略操作）
			Core，终止进程，生成Core文件。（查验死亡原因，用于gdb调试）。
			Stop,停止（暂停）进程
			Cont：继续运行进程
		特别需要注意的是：SIGKILL 和 SIGSTOP这两个信号不能被 caught(捕获)，blocked(阻塞) 和 ignored(忽略)	
	
	几个常用到的信号：SIGINT，SIGQUIT，SIGKILL，SIGSEGV，SIGUSR1，SIGUSR2，SIGPIPE，SIGALRM，SIGTERM，SIGCHLD，SIGSTOP，SIGCONT	

	阻塞信号集：每个进程都有一个阻塞集，它用来描述哪些信号递送到该进程的时候被阻塞(在信号发生时记住它，直到进程 准备好时再将信号通知进程)。所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。
		若将被阻塞的信号从信号阻塞集中删除，且对应的信号 在被阻塞时发生了，进程将会收到相应的信号。 
	
	
	未决信号集:
    		信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态；当信号被处理对应位翻转回为0，这一时刻往往非常短暂。
    		信号产生后由于某些原因主要是阻塞不能抵达，这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。
		未决信号集就是没有被处理的信号，未决信号集实际上是一个32位数，每一位代表一个信号，当信号产生的时候，就把对应的位反转为1，如果该信号未被处理就反转回0，处理了就保持为1。
	阻塞信号集会影响到未决信号集，比如说我在阻塞信号集中将2号信号为置为1，也就是将2号信号屏蔽，那么未决信号集中2号信号对应的位就会变为1（未决状态），一直阻塞在这种状态。
	

3、信号相关函数
	详见/c-pro/linuxProjects/linuxSignal项目

4、信号集相关
	4.1)未决信号集和阻塞信号集的关系
	阻塞信号集是当前进程要阻塞的信号的集合，未决信号集是当前进程中还处于未决状态的信号的集合，这两个集合存储在内核的PCB中。
	
	下面以SIGINT为例说明未决信号集和阻塞信号集的关系：
		当进程收到一个SIGINT信号，首先这个信号会保存在未决信号集中，此时SIGINT编号位置上置为1，表示处于未决状态；
		在这个信号需要被处理之前首先要在阻塞信号集中的SIGINT编号的位值上检查该值是否为1：
			a)如果为1，表示SIGINT信号被当前进程阻塞了，这个信号暂时不处理，所以未决信号集该位置上的值保持为1，表示该信号处于未决状态。
			b)如果为0，表示SIGINT信号没有被当前进程阻塞，这个信号需要被处理。内核会对SIGINT信号进行处理(执行默认动作，忽略或者执行用户自定义的信号处理函数)，
			  并将未决信号集中对应位值上的1变为0，表示该信号已经被处理了，这个时间非常短暂，用户感知不到
		当SIGINT信号从阻塞信号集中解除阻塞以后，该信号就会被处理
					
			内核
		+------------------------------------------------------------+	
		|      未决信号集                        阻塞信号集          |
                |   +----------------+                +----------------+     |
                |  1|                |               1|                |     |
                |   +----------------+                +----------------+     |
                |  2| SIGINT 1->0    |-------------> 2|    0           |     |
                |   | SIGINT 1       |                |    1           |     |
                |   +----------------+                +----------------+     |
                |  3|                |               3|                |     |
                |   +----------------+                +----------------+     |
                |   |                |                |                |     |
                |   +----------------+                +----------------+     |
                |   |                |                |                |     |
                |   +----------------+                +----------------+     |
                |   |                |                |                |     |
                |   +----------------+                +----------------+     |
                |   |                |                |                |     |
                |   +----------------+                +----------------+     |
                +------------------------------------------------------------|

		被阻塞期间如果产生多次信号，当阻塞解除以后，该信号只会被处理一次，多次发生的信号不会累积。

	4.2）信号集相关函数
		详见/c-pro/cProjects/linuxSignal项目

5、信号捕捉函数
	详见/c-pro/linuxProjects/linuxSignal项目	

6、SIGCHLD信号
	6.1)产生SIGCHLD信号的条件
		子进程结束的时候
		子进程收到SIGSTOP信号
		当子进程停止时，收到SIGCONT信号
	
	6.2）SIGCHLD信号的作用
		子进程退出后，内核会给他的父进程发送SIGCHLD信号，父进程收到这个信号后可以回收子进程
		使用SIGCHLD信号完成对子进程的回收，可以避免父进程阻塞等待而不能执行其他操作。
		只有当父进程收到SIGCHLD信号之后才会去调用信号捕捉函数完成对子进程的回收，未收到SIGCHLD信号之前可以处理其他操作。
	
	6.3)使用SIGCHLD完成对子进程的回收
		1）有可能未完成的信号处理函数时子进程都退出了，所以需要在fork之前先将SIGCHLD信号阻塞，当完成信号处理函数的注册以后在解除阻塞
		2）当SIGCHLD信号处理期间，SIGCHLD信号若再次产生是被阻塞的，而且，若产生了多次，则该信号只会被处理一次，这样可能会产生僵尸进程
		   解决方法：可以在信号处理函数里面使用while(1)循环回收，这样就有可能出现捕获一次SIGCHLD信号，但是回收了多个子进程的情况，从而避免产生僵尸进程。
		详见/c-pro/linuxProjects/linuxSignal项目

7、内核实现信号捕捉的过程
	如果信号的处理动作是用户的自定义函数，在信号递达时就调用这个函数，这称为捕捉信号。由于信号处理函数的代码是在用户空间的，处理过程比较复杂，举例如下
	1）用户注册了SIGXXX信号的处理函数sighandler
	2) 当前正在执行main函数，这时发生中断、异常或系统调用内核切换到内核态(printf,read,write,sleep等很多操作都会进入到内核)
	3）在中断处理完毕后要返回用户态的main函数之前，检查是否有SIGXXX信号递达(检查未决信号集)
	4）内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的对栈空间，他们之间不存在调用和被调用的关系，是两个独立的控制流程。
	5）sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态
	6）如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。


	+-----------------------------------------------------------------------------------------------------------------------+
	|用户态                                                                               void sighandler(int)              | 
	|1、在执行主控制                   int main()                                +----->  {                                 |
	|流程的某条指令时		   {	      <---------------------+        |         ....                             |
	|因为中断、异常或<-----------------  ...     	                    |        |        }                                 |
	|系统调用进入内核                  }                                |        | 	      4、信号处理函数返回时执行特殊的	|
	|        ↓                                                          |        |        系统调用sigreturn再次进入内核     |
	+--------↓----------------------------------------------------------|--------|------------------------↓-----------------+
	|内核态  ↓ 	                                                    |        |	                      ↓                 |
	|2、内核处理完异常准备回        do_signal()                         +---------------- 5、返回用户模式从主控制流程中     |
	|用户模式之前先处理当前--------> 3、如果信号的处理动作是自定义               |	      上次被中断的地方继续向下执行      |
	|进程中可以递送的信号		 的信号处理函数则回到用户模式，        ------+                                          |
	|				 执行信号处理函数(而不是回到主控制流程)	                                                |
	+-----------------------------------------------------------------------------------------------------------------------+
	
