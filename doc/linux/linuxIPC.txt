1、进程间通信概念
	linux环境下，进程地址空间相互独立，每个进程各自都有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能互相访问，要交换数据必须通过内核。
	在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC InterProcess Communication)。

			+----------+              +----------+
      	        	|          |              |          |
               	        | 进程1    |              | 进程2    |
                	|          |              |          |
                	+----------+              +----------+
		     	     |			       ^
                     	     |                         |
                     	     ￬                         | 
         	+-----------------------------------------------------+
         	|                                                     |
         	|                 内                核                |
         	|                                                     |
         	+-----------------------------------------------------+


2、进程间通信的方式
	在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、贡献内存、消息队列、套接字、命名管道等。
	随着计算机的发展，一些方法由于自身设计的缺陷被淘汰或者弃用，现在常用的进程间通信方法有：
		1）管道，使用最简单
		2）信号，开销最小，使用灵活，系统优先级比较高，异步方式
		3）共享映射区，无血缘关系的进程也可以使用
		4）本地套接字，最稳定


3、管道
	管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即创建一个管道。

                                        +------+                +-------+
			 用户区         |进程A |                |进程B  |  
				        +------+	        +-------+
                                           ^                        |
       			-------------------|------------------------|------------------------------------
                                           |                        ￬
                                      +-------------------------------------+   
			内核区        |    <----------------------------    |
                                      +-------------------------------------+
			               读端                              写端

	管道的特质：
		管道的本质是一块内核缓冲区
		由两个文件描述符引用，一个表示读端，一个表示写端
		规定数据从管道的写端流入管道，从读端流出
		当两个进程都终结的时候，管道也自动消失
		管道读端和写端，默认都是阻塞的。


	管道原理
		管道的实质是内核缓冲区，内部使用环形队列实现
		默认缓冲区大小为4k,可以使用ulimit -a 命令获取大小
		实际操作过程中缓冲区会根据数据压力作适当调整

	管道的局限性
		数据一旦被读走，便不再管道中存在，不可反复读取
		数据只能在一个方向上流动，若想实现双向流动，必须使用两个管道
		只能在有血缘关系的进程间使用管道,原因是管道通信需要在各自进程中使用对方的文件描述符，而只有父子，兄弟等有血缘关系的进程才可能共享文件描述符。
	
	创建管道-pipe函数
		详见/c-pro/cProjects/linuxIPC 项目


	管道的读操作
		有数据：
			read正常读，返回读出的字节数
		无数据：
			如果写端全部关闭，read解除阻塞，返回0，相当于读文件读到了尾部
			如果写端没有全关闭，read阻塞
	
	管道的写操作
		读端全部关闭：如果写端继续一直写入，管道会被写满，进程终止，内核给当前进程发 SIGPIPE信号
		读端没有全部关闭：
			缓冲区写满了，write阻塞
			缓冲区没写满，继续write
	
	管道设置非阻塞
		默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞可以使用如下三个步骤
			int flags = fcntl(fd[0],F_GETFL,0);
			flag |= O_NONBLOCK;
			fcntl(fd[0],F_SETFL,flag);，
		若是读端设置为非阻塞
			写端没有关闭，管道没有数据，read返回-1
			写端没有关闭，管道有数据，read返回实际读到的字节数
			写端已经关闭，管道有数据，read返回实际读到的字节数
			写端已经关闭，管道没有数据，read返回 0


 	查看管道缓冲区大小
		命令：ulimit -a
		函数 :  long fpathconf(int fd, int name);
		 	详见/c-pro/cProjects/linuxIPC 项目

