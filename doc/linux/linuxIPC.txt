1、进程间通信概念
	linux环境下，进程地址空间相互独立，每个进程各自都有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能互相访问，要交换数据必须通过内核。
	在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC InterProcess Communication)。

			+----------+              +----------+
      	        	|          |              |          |
               	        | 进程1    |              | 进程2    |
                	|          |              |          |
                	+----------+              +----------+
		     	     |			       ^
                     	     |                         |
                     	     ￬                         | 
         	+-----------------------------------------------------+
         	|                                                     |
         	|                 内                核                |
         	|                                                     |
         	+-----------------------------------------------------+


2、进程间通信的方式
	在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、贡献内存、消息队列、套接字、命名管道等。
	随着计算机的发展，一些方法由于自身设计的缺陷被淘汰或者弃用，现在常用的进程间通信方法有：
		1）管道，使用最简单
		2）信号，开销最小，使用灵活，系统优先级比较高，异步方式
		3）共享映射区，无血缘关系的进程也可以使用
		4）本地套接字，最稳定


3、管道
	管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即创建一个管道。

                                        +------+                +-------+
			 用户区         |进程A |                |进程B  |  
				        +------+	        +-------+
                                           ^                        |
       			-------------------|------------------------|------------------------------------
                                           |                        ￬
                                      +-------------------------------------+   
			内核区        |    <----------------------------    |
                                      +-------------------------------------+
			               读端                              写端

	管道的特质：
		管道的本质是一块内核缓冲区
		由两个文件描述符引用，一个表示读端，一个表示写端
		规定数据从管道的写端流入管道，从读端流出
		当两个进程都终结的时候，管道也自动消失
		管道读端和写端，默认都是阻塞的。


	管道原理
		管道的实质是内核缓冲区，内部使用环形队列实现
		默认缓冲区大小为4k,可以使用ulimit -a 命令获取大小
		实际操作过程中缓冲区会根据数据压力作适当调整

	管道的局限性
		数据一旦被读走，便不再管道中存在，不可反复读取
		数据只能在一个方向上流动，若想实现双向流动，必须使用两个管道
		只能在有血缘关系的进程间使用管道,原因是管道通信需要在各自进程中使用对方的文件描述符，而只有父子，兄弟等有血缘关系的进程才可能共享文件描述符。
	
	创建管道-pipe函数
		详见/c-pro/cProjects/linuxIPC 项目


	管道的读操作
		有数据：
			read正常读，返回读出的字节数
		无数据：
			如果写端全部关闭，read解除阻塞，返回0，相当于读文件读到了尾部
			如果写端没有全关闭，read阻塞
	
	管道的写操作
		读端全部关闭：如果写端继续一直写入，管道会被写满，进程终止，内核给当前进程发 SIGPIPE信号
		读端没有全部关闭：
			缓冲区写满了，write阻塞
			缓冲区没写满，继续write
	
	管道设置非阻塞
		默认情况下，管道的读写两端都是阻塞的，若要设置读或者写端为非阻塞可以使用如下三个步骤
			int flags = fcntl(fd[0],F_GETFL,0);
			flag |= O_NONBLOCK;
			fcntl(fd[0],F_SETFL,flag);，
		若是读端设置为非阻塞
			写端没有关闭，管道没有数据，read返回-1
			写端没有关闭，管道有数据，read返回实际读到的字节数
			写端已经关闭，管道有数据，read返回实际读到的字节数
			写端已经关闭，管道没有数据，read返回 0


 	查看管道缓冲区大小
		命令：ulimit -a
		函数 :  long fpathconf(int fd, int name);
		 	详见/c-pro/cProjects/linuxIPC 项目

4 、FIFO
	FIFO常被称为命名管道，用来区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间通信。但通过FIFO,不相关的进程也能通信
	FIFO是linux基础文件类型的一种(文件类型为p， ls -l可以查看文件类型) 但FIFO文件在磁盘上没有数据块，文件大小为0，仅仅用来表示内核中一条通道。
	进程可以打开这个文件进行read/wirte。实际上是在读写内核缓冲区。

	fifo创建：
		1)使用命令：mkfifo 管道名称，例如：mkfifo myfifo
		2)使用函数：
			 int mkfifo(const char *pathname, mode_t mode);
			 详见 man 3 mkfifo
	当创建了一个fifo，就可以使用open函数打开它，常见的文件IO函数都可用于fifo。如close, read,write,unlink等。
	fifo严格遵循先进现出，对fifo的读总是从开始处返回数据，对于他们的写怎是把数据添加到末尾。他们不支持诸如lseek等文件定位操作(因为fifo文件并没有文件内容，文件内容在内核缓冲区内)
		

	使用FIFO完成两个进程通信示意图，如下
		
	
        		+--------+                               +--------+
	                | 进程A  |                               | 进程B  |
	        	+--------+				 +--------+       					
                            |                                        ^ 
                            |                                        |
                            |            +---------------+           |  
          		    +----------->| 磁盘fifo文件  |-----------+
                                         +---------------+
                                               |    ^
                    用户区                     |    |
                 ------------------------------|----|-----------------------
                    内核区                     |    |
                                               ￬    |
                                        +------------------+
                                        |   内核缓冲区     |
                                        +------------------+

	思路：
		进程A：
			创建一个fifo文件，myfifo
			调用open函数打开myfifo文件
			调用write函数写入一个字符串 如“hello world” (其实是将数据写入到内核缓冲区)
			调用close函数关闭myfifo文件
		进程B:
			调用open函数打开myfifo文件，获得文件描述符
			调用read函数读取文件内容(起始就是从内核中读取数据)
			调用close函数关闭myfifo文件
	注意:myfifo文件是在进程A中创建的，如果先启动进程B就会报错。

5、内存映射区
	存储映射I/O(Memory-mapped I/O)使一个磁盘文件与存储空间中的一个缓冲区相映射。从缓冲区取数据，就相当于读文件中相应的字节；将数据写书缓冲区，则会将数据写入文件。
	这样就可在不使用read和write函数的情况下，使用地址(指针)完成I/O操作。
	使用存储映射这种方法，首先应通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过mmap函数来实现。
	linux通过将一个虚拟内存区域与文件描述符关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)如图：linuxIPC_5_MMAP

                                                  磁盘文件
                                              |            |
                    内存地址空间              |            |
               --- +------------+............>+------------+ ----
                ^  |            |             |            |  ^ 
                |  |            |             |mmap映射    |  | 
            len |  |            |             |的部分      |  | len
                |  |            |             |            |  | 
                ￬  |            |             |            |  ￬ 
       返回地址--->+------------+............>+------------+ ---
                                              |            |  ^
                                              |            |  |
                                              |            |  | off
                                              |            |  ￬
                                              |            | --- 

	mmap函数
		详见/c-pro/cProjects/linuxIPC 项目
	
	mmap注意事项
		创建映射区的过程中，隐含着一次对映射文件的读操作，将文件内容读到映射区
		
		当MAP_SHARED时，要求：映射区的权限应<=文件打开的权限(处于对映射区的保护)。而MAP_PRIVATE则无多为，因为mmap中的权限时对内存的限制。
		比如某文件只有读权限,或者open时候用的是O_RDONLLY，那么映射区对应的权限也只能读不能写。
		
		映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭。
		
 		特别注意，当映射区文件大小为0时，不能创建映射区。所以，用于映射的文件必须要有实际大小；mmap使用时常常会出现总线错误，通常时由于共享文件存储空间大小引起的
		
		munmap传入的地址一定时mmap的返回地址。坚决杜绝指针++操作
		
		文件偏移量必须为0或者4k的整数倍
		
		mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功在进行后续操作
	
	MMAP优势
		MMAP对文件的读写操作只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据拷贝次数，提高了文件操作效率
		MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件，不需要开启线程，操作MMAP的速度和操作内存的速度一样快

			写入内存       写入mmap      写入文件
		OS X      17ms            18ms         2685ms
		IOS       55ms            55ms         13116ms
		ANDROID   283ms           248ms        13583ms
