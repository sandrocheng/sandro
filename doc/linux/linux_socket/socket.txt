1、什么是socket
	socket可以看成是用户进程与内核网络协议栈的编程接口。
	socket不仅可以用于本级的进程间通信，还可以用于网络上不同主机/系统的进程间通信，如图：1_TCPIP四层模型	
	
2、IPv4套接字地址结构
	Ipv4套接口地址结构通常也称为“网际套接字地址结构”，它以"sockaddr_in"命名，定义在头文件<netinet/in.h>中
	可以通过 man 7 ip 命令查看ip协议的手册
		struct sockaddr_in{
			//整个sockaddr_in结构的长度，在4.3BSD-Reno版本之前的第一个成员是sin_family
			uint8_t sin_len;
			//指定该地址家族，在这里必须设为AF_INET，
			//socket不仅可以用于ipv4协议还可以用于linux域协议，ipv6协议等，设置为AF_INET，说明此时使用IPv4协议
			sa_family_t sin_family;
			//端口
			in_port_t sin_port; //2个字节
			//IPv4的地址
			struct in_addr sin_addr;//4字节
			//暂时不用，一般将其设置为0
			char sin_zero[8];
		};
		
		/* Internet address. */
           	struct in_addr {
               		uint32_t       s_addr;     /* 实际上是一个无符号的32位整数，并且是一个网络字节序 address in network byte order */
           	};

	通用地址接结构用来指定套接字关联的地址，由于不同协议会有不一样的地方，因此会有一个通用的协议，sockaddr_in只适用于ipv4的地址结构，而sockaddr可以用于任何协议的套接口
		struct sockaddr{
			//整个sockaddr结构体的长度
			uint8_t sin_len;
			
			//指定该地址家族
			sa_family_t sin_family;

			由sin_family决定它的形式
			char sa_data[14]
		};

3、字节序
	-大端字节序(Big Endian)
	 最高有效位(MSB: Most Significant Bit)存储于最低内存地址处，最低有效位(LSB:Lowest Significant Bit)存储于最高内存字节处。
	-小端字节序(Little Endian)
	 最高有效位(MSB:Most Significant Bit) 存储于最高内存地址处，最低有效位(LSB: Lowest Significant Bit)存储于最低内存地址处。
	-如图 3_大端字节序和小端字节序	

	-主机字节序
	 不同的主机有不同的字节序，比如x86为小端字节序列，Motorola 6800为大端字节序，ARM字节序是可配置的。

	-网络字节序
	 网络字节序规定为大端字节序
	
	-当两个主机之间进行数据通信的时候，数据在发送端发送前，需要先把数据的字节序转换成网络字节序也就是大端字节序才能发送，数据到达目的主机后，需要把网络字节序转换成目的主机上的字节序。

	-字节序转换函数
	 man 3 htonl,查看详细文档
		#include <arpa/inet.h>
        	uint32_t htonl(uint32_t hostlong);//将4个字节的整数从主机字节序转换称为网络字节序
        	uint16_t htons(uint16_t hostshort);//将2个字节的整数从主机字节序转换称为网络字节序
        	uint32_t ntohl(uint32_t netlong);
        	uint16_t ntohs(uint16_t netshort);
	 上述的函数中，h代表host;n代表network s代表short,l代表long
	
	-查看当前系统使用的哪种字节序代码 ：c-pro/linuxProjects/linuxSocket/socketFun.c --> checkEdian函数


4、地址转换
	man 3 inet_aton ,查看详细文档
		#include <netinet/in.h>
        	#include <arpa/inet.h>
		//将地址字符串cp转换为网络字节序的地址(inp)
		int inet_aton(const char *cp, struct in_addr *inp);
		
		//将标准ip地址转换为32位整数：比如192.168.0.1转换为一个32位整数
		in_addr_t inet_addr(const char *cp);

		//将整形地址结构数据转换为 标准ip地址字符串
		char *inet_ntoa(struct in_addr in);
	
	-代码 ：c-pro/linuxProjects/linuxSocket/socketFun.c --> addrRevert函数

5、套接字类型
	-流式套接字(SOCK_STREAM)	
	 提供面向连接的、可靠的数据传输服务，数据无差错，无重复的发送，且按发送顺序接收。
	 对应的是TCP协议
	
	-数据包式套接字(SOCK_DGRAM)
	 提供无连接服务。不提供无错保证，数据可能丢失或重复，并且接收顺序混乱。
	 
	-原始套接字(SOCK_RAM)
	 它提供一种能力，让我们直接跨于传输层，直接在IP层进行数据封装的套接字，通过原始套接字可以将应用层的数据直接封装成ip层能够认识的协议格式

6、c/s模型
	-TCP c/s模型 如图：6_TCPCS模型	
	
	-回射 C/S模型 如图：6_回射CS模型
	 回射 c/s模型是一种最简单的模型，数据通过输入输出流输入给客户端，客户端把数据通过网络发送给服务端，服务端收到后返回给客户端结果，客户端再把结果通过输入输出流返回

7、创建socket
	-创建socket用于通信，man 2 socket，查看手册
		#include <sys/types.h>          /* See NOTES */
       		#include <sys/socket.h>
		/**
		* domain:指定通信协议族(protocol family)
		* type:指定socket类型
		*      SOCK_STREAM：流式套接字
		*      SOCK_DGRAM：数据报套接字
		*      SOCK_RAW：原始套接字
		* protocol:协议类型,默认网络协议是tcpip的就用 0.
		*          The  protocol specifies a particular protocol to be used with the socket.  
		*          Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as 0	
		* return : 非负数成功
                *          失败返回 -1
		*          它于文件描述符类似，我们把他称为套接字描述字
		*/	
       		int socket(int domain, int type, int protocol);
	
	-bind函数，用来绑定一个本地地址到套接字，man 2 bind查看手册
		
		#include <sys/types.h>          /* See NOTES */
       		#include <sys/socket.h>

		/**
		* sockfd:socket函数返回的套接字
		* addr:要绑定的地址,sockaddr是通用地址结构体，如果使用的是ipv4协议，可以使用sockaddr_in结构体，赋值会比较方便
		* addrlen:地址长度
		* return: 0，成功；-1，失败
		*/
       		int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);

	-listen函数，监听socket是否有连接,监听成功以后socket才会从close状态转换成监听状态，之后才能够接受连接。
		listen函数调用成功以后，套接字sockfd就从主动套接字变成了被动套接字。
			主动套接字：用来发起连接的，可以调用connect来连接其他socket。
			被动套接字：用来接受连接的, 可以调用accpet等待其他socket来连接。
		一般来说，listen函数应该在调用socket和bind函数之后，调用函数accept之前调用
		对于给定的监听套接口，内核要维护两个队列：
			1.已由客户发出并到达服务器，服务器正在等待完成相应的TCP三次握手过程的连接队列，这些连接尚未完成，状态是SYN_RCVD。
		        2.已完成连接的队列。这些连接是ESTABLISHED状态
		这两个队列中的连接数之和不能大于backlog
		当连接close以后会从队列中移除。
		因此backlog实际上就是一个socket能够并发连接的最大套接字数。
		man 2 listen查看手册
		
		#include <sys/types.h>          /* See NOTES */
       		#include <sys/socket.h>
		/*
		* sockfd:socket返回的套接字
		* backlog:规定内核为次套接字排队的最大连接数,一般推荐SOMAXCONN作为参数
		* return: 0，成功；-1,失败
		*/
       		int listen(int sockfd, int backlog);

	-accept函数，从以完成连接队列中返回第一个连接，如果已完成连接队列为空则阻塞。
		man 2 accept，查看手册
			
		#include <sys/types.h>          /* See NOTES */
       		#include <sys/socket.h>
		/**
		* sockfd:服务器套接字
		* addr:将返回对等方的套接字地址
		* addrlen:返回对等方的套接字地址长度
		* 
		* return:成功，返回非负数文件描述符，可以使用read读取其中的数据了；失败返回-1
		*/
       		int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	
	-connect函数，建立一个连接至addr所指定的套接字
		#include <sys/types.h>          /* See NOTES */
       		#include <sys/socket.h>
		/**
		* sockfd:套接字
		* addr: 要连接的套接字地址
		* addrlen:addr的长度
		* 
		* return:成功，返回0；失败返回-1
		*/
       		int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);	

	-代码 ：c-pro/linuxProjects/linuxSocket/socketFun.c --> createSocketServer ,创建一个回射服务器
		c-pro/linuxProjects/linuxSocket/socketFun.c --> createSocketClient ,创建一个回射客户端

	









		
