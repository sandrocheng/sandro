1、linux网络服务器
	-web服务器
	-邮件服务器
	-数据库服务器
	-FTP服务器
	-游戏服务器
	-...
	都是基于TCP/IP或UDP网络协议的服务器

2、基础概念
	socket:套接字，对网络中不同主机上的应用进程之间进行双向通信的端点的抽象
	       例子：客户端将数据通过网线发送到服务端，客户端发送数据需要一个出口，服务端接收数据需要一个入口，这两个“口子”就是Socket。
	socket客户端服务端连接如图：2_socket连接

	FD:file descriptor，文件描述符
	   是一个非负整数。“一切皆文件”，linux中的一切资源都可以通过文件的方式访问和管理。而FD就是类似文件的索引(符号)，指向某个资源，内核(kernel)利用FD来访问和管理资源。
	
	socket建立以后就可以拿到这个socket的fd，后期就可以通过这个fd对socket进行操作。

		
3、linux多路复用介绍
	-相对与多路复用，比较简单的是单一客户tcp模型，也就是服务器每次都只会服务于一个客户端链接，其他客户端链接如果想要被服务，必须要等待当前客户端与服务断开才可以
	 单一客户tcp模型在处理并发问题的常规操作是，创建多个线程/进程，每个线程只负责一个客户端的链接，没有客户端连接的线程处于空闲状态，服务器根据linux线程抢占去并发服务于各个客户端
	 这种方式有一定资源浪费的情况，即使是空闲的线程依然会占有系统的开销

	-多路复用可以实现一个线程/进程连接多个客户端，也就是说一个线程/进程可以监听多个文件描述符(每个文件描述符可以理解为一个连接)，从而提高线程的利用率，以减少开销
	 多路复用可以使用以下3中手段实现：
		select:posix标准，很早实现的模型，几乎所有系统都支持select模型,如图：3_select原理
		       -select扫描关注表的方式是轮询扫描，而关注表最大只能关注1024个文件描述符，由于进程打开的时候linux默认0 1 2这三个文件描述符是标准输入、输出、错误通道，实际上能用的不到1021个
		        对于大型服务器来说监听1000多个连接还是太少了。即便如此相对于单一客户tcp模型并发处理时要开辟1000个线程/进程监听连接，还是要节省了很多的开销
		       -关注表的持续扫描相对比较占用cpu	
		       -select另外一个缺陷是进程向客户端接收/发送数据的时候，需要通过内核，因此会涉及到用户进程空间和linux内核空间之间的数据拷贝，导致效率较低，内存占用也比较大
		       -select 事件复杂度 O(n)
		       -同步的IO
		Poll：93年首次上线,poll相对与select只是把关注表的限制取消了，原理和执行效率上和select差不多，也不是特别理想
		      poll的事件复杂度 O(n)
		      同步的IO
		epoll ：2000年后上线的多路复用解决方案，是linux中高并发效率比较高的模型，少数操作系统支持，比如linux，windows就不支持
			epoll极大的优化了select和poll再效率和内存上的缺陷，它的时间复杂度实际上是O(1),它不会随着连接数增大而增大
			异步的IO

	-同步阻塞、同步非阻塞、select/poll、epoll的区别
	 例子：你是一个老师，让学生做作业，学生做完作业后收作业
		同步阻塞，逐个收作业，先收A,再收B，接着是C、D，如果有一个学生还没做完，就只能等待等他做完后，才能继续收下一个。
	 	同步非阻塞，逐个收作业，先收A,再收B，接着是C、D，如果有一个学生还没做完，则会跳过该学生，继续收下一个。
		select/poll,学生写完作业会喊报告，但是不知道是谁喊的报告，需要一个一个去询问。
		epoll，学生做完作业会举手，你也知道是谁举的手，直接去收作业

	-同步阻塞总结
		单线程：服务端是一个线程，多个客户端通过socket和服务端连接，当某个客户端的socket阻塞，服务端也会阻塞，从而影响到其他客户端的socket处理。
		多线程：服务端给每个客户端都单独分配一个线程处理，当客户端连接较多时，会造成资源浪费，全部socket可能每个时刻只有几个就绪。
			同时，线程的调度，上下文切换乃至他们占用的内存，都会成为瓶颈
			即便使用线程池来管理线程，也依然会有损耗，解决不了根本的问题。

	-同步非阻塞总结
		同步非阻塞，在系统调用(connect、read、write等)的时候是非阻塞的,他从操作系统层面解决了阻塞的问题
		优点：单个socket阻塞，不会影响到其他socket
		缺点：需要不断的遍历进行系统调用来检查数据是否到来，这个系统调用会不断的进行用户态和内核态的切换，当socket连接很多的时候会是一笔很大的开销
	
	-select简介
		/**
		* nfds : 3个监听集合的文件描述符最大值+1
		* readfds : 要监听的可读文件描述符集合
		* writefds : 要监听的可写文件描述符集合
		* exceptfds : 要监听的异常文件描述符集合
		* timeval : 本次调用的超时时间
		* return 大于0，以就绪的文件描述符数; 等与0，超时;小于0，出错
		**/
		int select (int nfs,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout)	
		由于返回的是可用fd的数量，并不是具体哪个fd是可用的，所以还需要逐个fd进行检查，找出可用的fd才能继续操作。
		fd_set:如图：3_select的fd_set

		总结：将socket是否就绪检查逻辑下沉到操作系统层面，避免大量系统调用。只通知有事件就绪，但是没告诉具体是哪个FD。
		优点：不需要每个FD都进行一次系统调用，解决了频繁的用户态内核态的切换问题
		缺点：
			单进程监听的FD存在限制，默认0～1024
			每次调用需要将FD从用户态拷贝到内核态
			不知道具体是哪个文件描述符就绪，需要遍历全部文件描述符
			入参的3个fd_set集合每次调用后都需要重置
		
	-poll简介
		/**
		* pollfd 要监听的文件描述符集合
		* nfds 文件描述符的数量
		* timeout 本次调用超时时间
		* return 大于0：已就绪的文件描述符数；等与0：超时；小于0：出错
		*/
		int poll(struct pollfd *fds,unsigned int nfds,int timeout);
		struct pollfd{
			int fd;//监听的文件描述符
			short events;//监听的事件
			short revents; //就绪的事件
		}		
		

		总结：根select基本类似，主要优化了监听1024的限制
		优点：不需要每个FD都进行一次系统调用，导致频繁的用户态内核态切换
		缺点：每次调用需要将FD从用户态拷贝到内核态
		      不知道具体是哪个文件描述符就绪，需要遍历全部文件描述符

		
4、Epoll介绍
	-Epoll的提出，
		-它所支持的文件描述符上限是整个系统最大可以打开的文件数目
		 例如，再1GB内存的机器上，这个限制大概是10万左右
		-每个fd上面有callback函数。只有活跃的socket才会主动去调用callback函数，其他idel状态socket则不会，它实际上采用的是通知机制，而不是select那种轮询的机制，因此效率更高
	 	-通过内核与用户空间mmap共享内存，避免了二者之间的数据拷贝
	-Epoll接口
		/**
		* 创建epoll
		* size : epoll要监听的文件描述符数量
		* return epoll的文件描述符，后面会根据这个文件描述符来操作epoll
		*/
		int epoll_create(int size)

		/**
		* 操作epoll
		* epfd : epoll的文件描述符，epoll_create创建时返回
		* op : 操作类型：新增(1) 、删除(2)、更新(3)
		* fd : 本次要操作的文件描述符
		* epoll_event 需要监听的事件：读事件、写事件等
		* return : 0,调用成功; -1，调用失败
		*/
		int epoll_ctl(int epfd,int op,int fd,struct epoll_event *event)

		/**
		*  获取就绪事件
		*  epfd : epoll的文件描述符，epoll_create创建时返回
		*  events : 用于回传就绪的事件
		*  maxevents : 每次能处理的最大事件数，比如监听100个文件，但是每次最多处理10个，此时maxevents就设置为10
		*  timeout : 等待I/O事件发生的超时时间。-1:相当于阻塞;0:相当于非阻塞
		*  return : 大于0,已经就绪的文件描述符数; 等于0，超时; 小于0，出错
		*/
		int epoll_wait(int epfd,struct epoll_event *events,int maxevents ,int timeout);

	-epoll 事件处理流程，如图:4_epoll事件处理流程

	-总结：高效处理高并发下的大量连接，同时拥有非常优异的性能
	 缺点：跨平台性能不够好，只支持linux,macOS等,windows等操作系统不支持
               相较于epoll，select更轻量可移植更强
               在监听连接数和事件较少的场景下，select可能更优

	-LE vs ET
	 LE：Level-triggered,水平(条件)触发，默认。epoll_wait检测到事件后，如果该事件没被处理完毕，后续每次epoll_wait调用都会返回该事件。
	 ET：Edge-triggered，边缘触发。epoll_wait检测到事件后，只会在当此次返回该事件，不管该事件是否被处理完毕。
	


