1、C库IO函数的工作流程
	
                  +----------[使用fopen打开]-------->{hello.txt}---------------------> {hello , world!}
	          |              ||                       ^              ^                    ^
		fopen            ||                       |              |                    | 
		fclose           ||                       |              |                    |
		fread     [返回值:FILE* fp]               |              |                    |                +---------------------------+
		fwrite           ||                       |              |                    |                |1、刷新缓冲区:fflush       |
		fgets            ||             [索引到对应的磁盘文件]   |            [数据内存刷新到磁盘]<----|2、缓冲区已满              |
	C库函数	fputs            ||                       |              |                    |                |3、正常关闭文件            |
		fscanf           ↓                        |  [读写过程中指针的实际位值]       |                |     1>fclose              |
		fprintf	 +--------------------+		  |              |                    |                |     2>return (main函数)   | 
		fseek	 |    (FILE结构体)    |           |              |                    |                |     3>exit(main函数)      |
		fgetc    | 文件描述符(整形值) |-----------+              |          +---------------------+    +---------------------------+
		fputc    | 文件读写指针位     |--------------------------+          |                     |
		ftell    | I/O缓冲区(内存地址)|-------------------------------------|   hello,world!      |
		feof     +--------------------+                                     | 默认Buffer 8192bytes|   
		flush                                                               +---------------------+
		...

	磁盘读写：
		大部分硬盘都是机械硬盘，读取寻道时间和写入寻道时间都是在毫秒级别
		相对来说内存读写都非常块，因为内存读速度时纳秒级别的
                二者相差100万倍
  
                               |                    |            |
                +-----------+  |                    |            |
         buf1	|           |-----------+           |            |
                +-----------+  |        ||          |            |
            fputs(buf1,n,fp)   |        ||          |    write   |  
                               |        ↓           |            | 
                               |   +-----------+    |    flush   |       +-----------+
	                       |   | IO buffer |<----------------------->|    文件   | 
	                       |   +-----------+    |            |       +-----------+
                               |        |           |            |
                               |        |           |    read    |
            fgets(buf2,n,fp)   |        |           |            |
                +-----------+  |        |           |            |
         buf2   |           |<----------+           |            |
                +-----------+  |                    |            |
                               |      C标准IO库     |    内核    |         磁盘
                               |                    |            |


	
	C语言操作文件：
		使用fopen函数打开一个文件，返回一个FILE* fp ，这个指针指向的结构体有三个重要成员
			文件描述符：通过文件描述符，可以找到文件的inode，通过inode可以找到对应的数据块
			文件指针：读和写共享一个文件指针，读或者写都会引起文件指针的变化
			文件缓冲区：读或者写都会先通过文件缓冲区，主要目的是为了减少对磁盘的读写次数，提高磁盘的效率

	源码位置：
		应该是2.4 或者 2.6的旧代码
			/usr/include$ ls -l stdio.h
			头文件 stdio.h , typedef struct _IO_FILE FILE;
			头文件 libio.h ，struct _IO_FILE ，这个结构体定义中有一个_fileno成员，这个就是文件描述符	
		
		最新代码：
			FILE 别名在/usr/include/x86_64-linux-gnu/bits/types/FILE.h中定义
				typedef struct _IO_FILE FILE;
			_IO_FILE的结构体在 /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h中可以声明了结构体
			文件描述符还是_fileno成员
			

2、C语言库函数和系统函数的关系
	C语言函数是对系统函数的进一步封装。
                                                                             +-----------+           	
	 +--------------------------------------+			     |     FD    |       
         |printf函数 —> 标准输出(stdout): FILE* |-----printf("hello")----->  |   FP_POS  |
         +--------------------------------------+                            |   BUFFER  |
                     |                                                       +-----------+
                     |     
                     |    
                     |
     调用write函数，将文件描述符传递过去
                     |
                     |
                     |               +--------------------------------------+
                     |               |                                      |
                     +-------------> |     应用层  write(fd,"hello",5)      |--------------+
                                     |                                      |              |
                                     +--------------------------------------+      用户空间->内核空间       
                                     |                                      |              |
                        +------------|     系统调用 sys_write()             |<-------------+ 
                        |            |                                      |
                   调用驱动设备      +--------------------------------------+
                        |            |                                      |
                        +----------->|     内核驱动 设备驱动函数            |--------------+
                                     |                                      |              |
                                     +--------------------------------------+              |
                                                                                           |
                                                                                           |
-------------------------------------------------------------------------------------------------------------------------
                                                     硬件层                         通过设备驱动操作硬件
                                     +--------------------------------------+              |
                                     |                                      |              | 
                                     |               显示器                 |<-------------+
                                     |                                      |
                                     +--------------------------------------+
	系统调用：
		由操作系统实现并提供给外部应用程序的编程接口，是应用程序同系统之间数据交互的桥梁。

3、虚拟地址空间
	Linux(32位)每一个运行的程序（进程）操作系统都会为其分配一个 0～4G的地址空间（虚拟地址空间）

                            _____________________________执行a.out,sys为其创建虚拟地址空间—————————————————+
	                   ||                                                                              |
                           ↓                                                                               | 
       4G  +-------------------------------+                                                               |
           |                               |                                                               |
       内  |               内存管理        |      内核空间是受保护的                                       |
           |linux          进程管理        |<====>用户不能对该空间读写                                     | 
       核  |kenrnl         设备驱动管理    |      操作，否则会出现段错误                                   |
           |               VFS虚拟文件系统 |                                                               |
       区  |                               |                                                               |
           |                               |                                                               |
       3G  +-------------------------------+                                                               |
           |        环境变量 env           |                                                               |
           +-------------------------------+       通过 ./programName arg1 arg2 arg3...传递参数            |
           |        命令行参数             |------>int main(int argc char* argv[])         +-------------------------------+
       用  +-------------------------------+                                               |             磁盘              |
           | 栈空间（小）从高->底分配地址  |                                               |        可执行文件 .out        |
           +-------------------------------+    +----> C标准库                             |    Linux下可执行文件格式:elf  |
           |                               |   /                                           +-------------------------------+
           |        共享库                 |---
           |                               |   \
           +-------------------------------+    +----> Linux系统IO函数
           |                               |
       户  | 堆空间（大）从低->高分配地址  |
           |                               |
           +-------------------------------+
           |        .bss(未初始化全局变量) |--            
           +-------------------------------+  \        ELF格式主要包含的三个段 .bss .data .txt             
           |	  .data(已初始化全局变量)  |   +-->ELF 其他段：只读数据段 ，符号段等		
       区  +-------------------------------+  /   
           |  .txt(代码段，二进制机器指令) |--   
           +-------------------------------+   
           |     受保护的地址（0~4K）      |----> #define NULL(void*) 0 ,这句话定义了一个无类型指针,地址是0，是受保护的，所以无法访问
         0 +-------------------------------+

	进程的虚拟地址空间分为用户区和内核区，其中内核区是受到保护的，用户不能直接对内存区的内存地址进行读写操作，只能通过linux系统提供的接口间接访问
	内核区中很重要的一个就是进程管理，这里保存当前进程的PCB（进程控制块）信息，PCB中有文件描述符表，文件描述符表中存放着打开的文件描述符，涉及到文件的IO操作都会用到这个文件描述符。


4、PCB(进程控制块)和FD(文件描述符)

                                                             文件描述符
	                                         +-------------------------------+         
	4G +---------------+                     |  0-> STDIN_FILENO 标准输入	 |--读--+
           |               |                     +-------------------------------+       \
           |Linux     PCB  |---文件描述符表--->  |  1-> STDOUT_FILENO 标准输出   |--写----+--> /dev/tty,当前终端，默认都是打开状态
           |kernel    ...  |                     +-------------------------------+       /
           |               |                     |  2-> STDERR_FILENO 标准错误   |------+
        3G +---------------+                     +-------------------------------+
           |               |                     |              3 (~/world.txt)  |--+
           |               |                     |              4 (~/hello.txt)  |   \       
           |       用      |                     |              5 (...)          |    \      每打开一个新的文件，则
           |       户      |                     |              6 (...)          |     \     占用一个文件描述符，而
           |       空      |                     |              7 (...)          |      +--->且是空闲的最小的一个文    
           |       间      |                     |              8 (...)          |     /     件描述符，一个进程最多
           |               |                     |              ...              |    /      能打开1024个文件，0~2
           |               |                     |              1023             |   /       被关闭以后，当新文件打
           |               |                     |                               |--+        开的时候，会占用这几个
        0  +---------------+                     +-------------------------------+           描述符

	备注：
		pcb:结构体：task_struct 。linux2.4 或者 2.6 的源码在linux/sched.h中，可以看到一个进程有一个文件描述符表，长度是1024
			前三个被占用，分别是STDIN_FILENO , STDOUT_FILENO,STDERR_FILENO
			文件描述符的作用：通过文件描述符找到inode，系统通过inode找到磁盘数据块
        	虚拟地址空间->内核区->PCB->文件描述表->文件描述符->文件IO操作使用文件描述符

