1、什么是线程
	轻量级的进程(LWP, light weight process)，在linux下线程的本质仍是进程。
	进程：拥有独立的地址空间，拥有PCB。
	线程：有PCB，但没有独立的地址空间，多个线程共享进程空间。

 	在linux操作系统下：
		线程是最小的执行单位
		进程是最小的资源分配单位，可看成是只有一个线程的进程。
		多个子线程和主线程共享一个地址空间，只有一个PID
		通过线程号来区分不同线程
		除了栈以外，其余资源都可以共享。栈大小(stack size)使用ulimit -a查看，一般是8M。
		主线程和子线程谁先抢到cpu资源，谁先执行。
		在多核cpu上，一个进程里的多个线程可以分别在多个核上并发运行
	
	线程特点：
		类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现除了线程的概念，因此在这类系统中进程和线程关系密切。
		线程是轻量级进程(light-weight process),也有PCB，创建线程使用的底层函数和进程一样，都是clone
		从内核里看进程和线程是一样的，都有各自不同的PCB
		进程可以蜕变成线程。
		在linux下，线程是最小的执行单位；进程是最小的资源分配单位
	
	查看指定线程的LWP号： ps -Lf pid
	
	实际上，无论是创建进程的fork，还是创建线程的pthread_create,底层实现都是调用同一个内核函数clone
		如果复制对方的地址空间，那么就产出一个“进程”
		如果共享对方的地址空间，就产生一个“线程”。
	所以，Linux内核是不区分进程和线程的，只在用户层面上进行区分。
	线程所有操作函数 pthread_*是库函数，而非系统调用

2、线程共享资源
	文件描述符表
	每种信号的处理方式
	当前工作目录
	用户ID和组ID
	内存地址空间(.text/.data/.bss/heap/共享库)

3、线程非共享资源
	线程ID
	处理器现场和栈指针(内核栈)
	独立的栈空间(用户空间栈)
	errno变量（这是个全局变量，虽然改变时加锁了，但是一般来讲线程编成就不要用errno了，用strerror）
	信号屏蔽字（很少在线程里使用信号）
	调度优先级

4、线程优缺点
	优点：
		提高程序并发性
		开销小
		数据通信、共享数据方便
	缺点：
		库函数，不稳定
		gdb调试、编写困难
		对信号支持不好
	优点相对突出，缺点均不是硬伤，linux下由于实现方法导致进程，线程差别不大

5、线程函数
	详见/c-pro/cProjects/linuxThread

6、进程函数和线程函数的比较
	+---------------------------------------+-------------------------------------------+
        |              进程                     |                  线程                     |
	+---------------------------------------+-------------------------------------------+
	|             fork                      |             pthread_create                |
        +---------------------------------------+-------------------------------------------+
        |             exit                      |             pthread_exit                  |
        +---------------------------------------+-------------------------------------------+
        |          wait/waitpid                 |             pthread_join                  |
        +---------------------------------------+-------------------------------------------+
        |             kill                      |             pthread_cancel                |
        +---------------------------------------+-------------------------------------------+
        |            getpid                     |             pthread_self                  |
        +---------------------------------------+-------------------------------------------+
  


7、线程属性
	linux下线程的属性是可以根据实际项目需要，进行设置，之前讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题，如果对程序的性能提出更高的要求，则需要设置线程属性。
	
	7.1)线程的分离状态决定一个线程以什么样的方式来终止自己，有两种状态：
		非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束，只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的资源
		分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的实际需要，选择适当的分离状态。
	
	7.2)设置线程属性分为以下几个步骤：
		第一步：定义线程属性类型的变量
			pthread_attr_t attr;
		第二步：对线程属性变量进行初始化
			int pthread_attr_init(pthread_attr_t *attr);
		第三步：设置线程为分离属性
			int pthread_attr_setdetachstate(pthread_attr_t *attr,int detachstate;);
			attr:线程属性
			detachstate:
				PTHREAD_CREATE_DETACHED(分离)
				PTHREAD_CREATE_JOINABLE(非分离)
		注意：完成这一步之后调用pthread_create函数创建线程
		第四部：释放线程资源
			int pthread_attr_destroy(pthread_attr_t *attr);
			参数：线程属性
		
8、线程同步
	线程同步，指一个线程发出某一功能调用时，再没有得到结果之前，该调用不返回。同时其他线程为保证数据一致性，不能调用该功能。
	比如：创建两个线程，让两个线程共享一个全局变量int number,然后让每个线程数5000次，在没有同步的情况下，两个线程运算结束后，number不一定是10000，同步之后number才能稳定的计算出10000这个结果。
	linux使用互斥锁来解决多线程同步的问题。
	当多个线程共同访问某个共享资源的时候，每个线程访问时需要先加锁，执行任务， 再解锁，如果加锁的时候锁被占用，则加锁失败并阻塞等待占用锁的线程释放锁后才能有机会解除加锁阻塞。
	通过互斥锁，多个线程不能同时访问共享资源，保证了多线程同步安全。

9、互斥锁
	详见c-pro/cProjects/linuxThread项目
	注意：加锁之后，一定会影响效率，因为cpu无法并行执行多个线程中被加锁的代码。
	
	互斥锁的使用步骤：
		1）创建一把锁：pthread_mutex_t mutex;
		2) main函数中初始化互斥锁：pthread_mutex_init(&mutex,NULL);
		3) 锁的使用：在共享资源出现的上下，加锁和解锁
			pthread_mutex_lock(&mutex);
			...共享资源代码
			pthread_mutex_unlock(&mutex);
		4）释放锁：在main函数中释放，pthread_mutex_destroy(&mutex);

10、死锁
	死锁不是linux提供给用户的一种使用方法，而是由于用户使用互斥锁不当的一种现象。
	常见的死锁有两种：
		1）自己锁自己，比如:
			...
			pthread_mutex_lock(&mutex);
			ptherad_mutex_lock(&mutex);
			...
		2)线程A拥有A锁，请求获得B锁，线程B拥有B锁，请求获得A锁，这样就造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而造成死锁。

	如果解决死锁：
		让线程按照一定的顺序去访问共享资源
		避免使用使用锁的嵌套，在访问其他锁的时候，需要先将自己的锁解开
		即使线程异常退出，也要尽量释放锁
		调用pthread_mutex_trylock，如果加锁不成功会立刻返回

11 、读写锁
	读写锁也叫共享-独占锁。当读写锁以读模式锁住时，他是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享
	读写锁使用场合:
		读写锁非常适合与对数据结构读的次数，远大于写的情况。
	读写锁特性
		读写锁是“写模式加锁”时，解锁前，所有对该锁加锁的线程都会被阻塞
		读写锁是“读模式加锁”时，若果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。
		读写锁是“读模式加锁”时，既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后读模式锁请求。由县满足写模式锁。读锁、写锁并行阻塞，写锁优先级高。
	例如：
		线程A加写锁成功，现称B请求读锁
			B线程阻塞，当线程A解锁之后，线程B才会加锁成功
			
		线程A持有读锁，线程B请求写锁
			B线程阻塞，当线程A解锁之后，线程B才会加锁成功
		
		线程A持有读锁，线程B请求读锁
			B线程加锁成功
		
		线程A持有读锁，然后线程B请求写锁，线程C请求读锁
			B和C都阻塞，当A释放锁后，B（写锁）获得锁，C阻塞，当B释放后，C才会获得锁

		线程A持有写锁，然后线程B请求读锁，线程C请求写锁
			B和C都阻塞，当A释放锁后，C（写锁）获得锁，B阻塞，当C释放后，B才会获得锁

12、读写锁函数和使用步骤
	详见详见/c-pro/cProjects/linuxThread

13、条件变量
	条件变量本身不是锁，但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提高哦功能一个回合的场所
		使用互斥量保护共享数据
		使用条件变量可以使线程阻塞，等待某个条件的发生，当条件满足的时候解除阻塞
	条件变量的两个动作：
		条件不满足，阻塞线程
		条件满足，通知阻塞的线程解除阻塞，继续后面的代码。
	
	条件变量相关函数
		详见详见/c-pro/cProjects/linuxThread	
	
14、多个生产者和多个消费者程序在执行期间，core掉的原因分析
	如果只有一个生产者生产了一个节点，此时调用pthread_cond_signal通知消费者线程，若有多个消费者被唤醒，最终只有一个消费者获得锁，并消费。
	之后其余消费者线程会解除阻塞并随机让一个消费者获得成功，这时节点已经为空，如果不判空，会报错

	在使用条件变量的线程中，能够引起线程阻塞的地方有两个：
		1）在条件变量处引起阻塞，会被生产者调用pthread_cond_signal唤醒
		2）互斥锁处会使线程阻塞，其他线程释放锁会解除阻塞
	
15、信号量
	信号量相当于多把锁，可以理解为是加强版的互斥锁。信号的初始值是几，表示有几个线程可以并行执行。
	互斥锁，每次只能有一个拿到锁的线程才能执行，而信号量，可以让多个线程一起执行。
	
	使用信号量时一般有两个，生产者一个，消费者一个，生产者生产节点后使用生产者信号量通知消费者线程消费，消费者消费一个以后，使用消费者信号量通知生产者继续生产。
	
	相关函数 ： 详见详见/c-pro/cProjects/linuxThread
		
