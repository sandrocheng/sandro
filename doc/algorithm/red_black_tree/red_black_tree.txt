1、常用搜索算法简介
	-线性搜索：Linear search
		   在数组/链表中逐个元素比对的搜索，是最简单的搜索方法
		   搜索效力低 ，时间复杂度是O(n)

	-二分搜索：Binary Search
		   二分搜索的前提是数据必须放在数组中，并所有元素是有序的，在搜索的时候每次都从数组中间开始比对，如果比对的结果在数组的某一侧，那么下一次的搜索是这一侧的中间开始搜索
		   比如数组是从小到大排列的 1 12 23 34 45 56 67 78 89 如果要搜索12
		   第一次搜索从数组的中间位值 45 开始，12<45 ,说明12在45的左边
		   第二次从 1 ～ 45的中间开始 就是 23   12<23 ，说明12在23的左边
		   。。。
		   直到搜索到 12，返回搜索成功，如果无法继续二分的时候依然没有找到，则查找失败。	
		   优点：二分查找的时间复杂度是 O(log N),所以效率比线性搜索快很多。
						     2							
		   缺陷：由于数组中的元素必须有序的，因此数组插入删除元素的时候必须要保证有序插入，这会导致插入删除的效率比较低
		         虽然链表的插入删除元素的效率比较高，但是链表不像数组那样有位值索引，所以链表无法使用二分搜索

	-二叉搜索树：binary search tree(BST)
		     二叉搜索数本质上是一个二叉树：			
			-左序树：每个节点上左子树中最大的节点小于当前节点，右子树最小的节点大于当前节点，左<根<右
			-右序树：每个节点上左子树中最小的节点大于当前节点，右子树最大的节点小于当前节点，左>根>右
		     左序树的搜索：
			 从根节点开始如果搜索数小于根节点则从左子数开始搜索，如果大于根节点则从右子数开始搜索，直到搜索到像等的节点，如果一直搜索到叶子节点也没有搜索到，说明搜索的数字不在当前树中
		     和二分搜索的查找效率是差不多的，搜索方式是从根节点开始，大于/小于 当前值的时候选择左/右子数继续查找，直到找到或搜索到叶子节点
		     二叉搜索树插入删除元素的时候不需要移动大量元素，这点比二分搜索效率更高
		     缺点:二叉搜索树的搜索效率和树的深度有关，极限情况下，所有的节点都比父节点大/小，这样二叉搜索树就退化成了一个链表，搜索的效率就是线性搜索了，时间复杂度就变成了O(N)

	-平衡二叉搜索树：由三个发明者的名字命名Adelson Velsky Landis (AVL)
		        平衡二叉树左右子树的高度基本一样，对于每个节点来说 |Height(RightTree) - Height(LeftTree)| <= 1，如图：red_black_tree_1_二叉平衡搜索树
			因此搜索效率会很高，时间复杂度是 log N
		                                            2
			平衡二叉搜索树的插入/删除算法会比较复杂，因为要不断调整根节点，保证左右子树的深度是一样的，如图 ：red_black_tree_1_二叉平衡搜索树的插入
				-插入的过程也是查找的过程，目的是先保证左右子树有序,并重新计算每个节点左右子树的高度差
				-如果某个节点的高度差>2,则使用左旋和右旋调整当前节点和其子树的位值

			插入节点后导致二叉搜索树失去平衡的四种情况，如图：red_black_tree_1_二叉平衡搜索树元素插入的4种情况
			
			删除元素/子树时，有可能导致失衡，同样也需要重新调整
	-2-3-4树
		2-3-4树是四阶的B树(Balance Tree) , 它属于一种多路查找树，它的结构有以下限制：
			-所有叶子结点都拥有相同的深度
			-节点只能是2-节点、3-节点、4-节点之一
				2-节点：包含一个元素的节点，有2个或0个子节点
				3-节点：包含两个元素的节点，有3个或0个子节点	
				4-节点：包含三个元素的节点，有4个或0个子节点
			-所有节点必须至少包含1个元素
			-元素始终保持排序顺序，整体上保持二叉查找树的性值，即父节点大于左子节点，小于右子节点
			-而且节点有多个元素时，每个元素必须大于它左边的和它的左子树中的元素
		如图：red_black_tree_1_2-3-4树
		2-3-4树的查询操作像普通的二叉搜索树一样，非常简单，但由于其节点元素数不确定，实现起来并不方便，实现的时候一般使用它的衍生算法-红黑树
		1-2-3树的生成过程：如图 red_black_tree_1_2-3-4树的生成	
	
	-可视化的数据结构和算法演示网站
		https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
		这里有各种数据结构和算法，可以演示

2、红黑树简介
	Red-Black Tree(RBT)
	红黑树的平衡性没有平衡二叉搜索树那么好，不要求左右子树深度差必须小于等于1，只能保证二叉搜索树的基本平衡
	红黑树是一个自平衡的二叉搜索树，红黑树的每个节点只有黑色和红色两种，它的插入删除元素时像平衡二叉搜索树那么频繁的调整
	如果插入删除比较少，搜索比较多，平衡二叉搜索树更适合，如果插入删除比较多，则红黑树效果更好
	
	-红黑树特点，,如图：red_black_tree_2_红黑树 
	 	根属性：根节点必须是黑色的
	 	红属性：红色节点的子结点必须是黑色的
			黑色节点的子结点可以是黑色，也可以是红色。
		黑属性：叶子节点是一个黑色的空节点，有的时候图上并不会显示的画出来，就是默认每个元素节点不会是叶子节点。
			从任何元素节点到其所有叶子节点的路径上所包含的黑色节点数量都是一样的，例如图中，从13到任何叶子节点(NIL),每条路径上都只有2个黑色节点。其他的黑色节点也是这样
		红黑树的高度：红黑树的高度最大是 2*log (n + 1) ,所以它的搜索效率和平衡二叉搜索树几乎是一样的
						      2
		黑高：从一个元素节点到叶子的路径上黑色节点的数量，比如图中13到1的路径上有两个黑色节点，因此13到8的黑高是2

	-红黑树是从2-3-4树中演变过来的，如图：red_black_tree_2_红黑树和2-3-4树的等价关系
	-2-3-4树转换成红黑树，如图：red_black_tree_2_2-3-4树转换成红黑树

	-红黑树保持黑高平衡的三种操作，如图：red_black_tree_2_红黑树旋转
		左旋：以某个节点作为支点(旋转节点)，其右子节点变为旋转节点的父节点
		      右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变
		右旋：以某个节点作为支点(旋转节点)，其左子节点变为旋转节点的父节点
		      左子节点的右子节点变为旋转节点的左子节点，右子节点不变
		变色：颜色又黑变红，或者红变黑
	  红黑树的左旋和右旋是二叉树的基本算法，二叉搜索树，平衡二叉搜索树等也可以使用左旋和右旋来改变当前树的形态

3、红黑树的元素插入	
	-红黑树的节点插入，如图：red_black_tree_3_红黑树和2-3-4树节点插入的等价关系
	 	红黑树节点的插入和普通的二叉搜索树插入新节点是一样的
		插入后，需要根据红黑树的黑高平衡的规则进行位值和颜色调整
			1、新增的节点(默认新增的节点都是红色)，如果父亲是黑色，不需要调整，如果新增的节点是根节点，则需要变为黑色
			2、如果父亲节点是红色(叔叔肯定也是红色)，则有如下两种情况：
				如图 3-节点对应的左倾和右倾红黑树结构 
		        	如图 4-节点对应的红黑树结构，新增节点是红色，爷爷是黑色，父亲和叔叔是红色，也会有4中构型对应的调整
			   综合这些情况后，代码逻辑如下：
				-父节点是爷爷的左孩子，x.parent == x.parent.parent.left
					-有右叔叔节点,x.parent.parent.right != null，如图构型-7 和 构型-8
						//变色+递归
						父亲和叔叔变黑色，爷爷变为红色
						递归处理爷爷节点	
					-没有右叔叔节点	
						 -插入节点如果是右孩子 如图构型-4
							先根据父亲节点做左旋，再根据爷爷节点做右旋
							此时会变成左根右的构型：
								当前节点变成了父亲节点，此时要变成黑色
								原来的父亲和爷爷变成了左右子孩子，此时要变成红色
						 -插入节点如果是左孩子，如图构型-5
							根结爷爷节点右旋
							此时会变成左根右的构型：
								当前节点变成了父亲节点，此时要变成黑色
								原来的父亲和爷爷变成了左右子孩子，此时要变成红色
				-父节点是爷爷的右孩子 x.parent == x.parent.parent.right	
					-有左叔叔节点，如图构型-9 和 构型-10
						//变色+递归
						父亲和叔叔变黑色，爷爷变为红色
						递归处理爷爷节点
					-没有左叔叔节点
						-插入节点如果是右孩子 如图构型-1
							根据爷爷节点左旋
							此时会变成左根右的构型：
								当前节点变成了父亲节点，此时要变成黑色
								原来的父亲和爷爷变成了左右子孩子，此时要变成红色
						-插入节点如果是左孩子 如图构型-3
							先根据父亲节点做右旋，再根据爷爷节点做左旋
							此时会变成左根右的构型：
								当前节点变成了父亲节点，此时要变成黑色
								原来的父亲和爷爷变成了左右子孩子，此时要变成红色
				-最后，把root节点再设置一次黑色，有可能在递归的时候把root给设置为红色了
	-可以参考java TreeMap类的fixAfterInsertion方法

4、红黑树的节点删除
	-二叉搜索树的前驱节点和后继节点，如图：red_black_tree_4_二叉搜索树的前驱节点和后继节点	
	-二叉搜索树的节点删除操作
		1、删除叶子节点，直接删除
		2、删除的节点有一个子节点，那么用子节点来替代
		3、如果删除的节点有两个子节点，此时需要找到前驱节点或者后继节点，也就是说删除一个有两个子节点的父节点，会产生两种构型的树
			-找到前驱节点，复制前驱节点的值覆盖到当前节点，然后删除前驱节点
			-找到后继节点，复制后继节点的值覆盖到当前节点，然后删除后继节点
	-二叉搜索树节点删除步骤
		1、查找节点node
		2、节点删除 : void deleteNode(Node node)
		
			if(node.left !=null && node.right!=null){
				//要删除的节点，有两个孩子，可以使用前驱节点也可以使用后继节点，此时后继节点和前驱节点肯定是子孙节点，不可能是祖辈节点
				Node successorNode = successor(node);//找到node的后继节点
				
				//用后继节点的值覆盖要删除的节点
				node.key = successorNode.key
				node.value = succesorNode.value
				//覆盖以后，删除后继节点，这里是通过赋值的方式修改node的引用
				node = successorNode;//此时node就是后继节点，后继节点只可能有一个右孩子，或者没有孩子
			}

			//经过上一层的筛选，此时node可能要删除的节点，也可能是要删除的节点的后继节点			
			//但是不管是哪种情况，当前节点node只可能有1个孩子
			Node replaceNode = node.left!=null? node.left : node.right
			if(replaceNode != null){//node有一个孩子
				replaceNode.parent = node.parent
				if(node.parent == null){
					root = replaceNode;//如果node的父亲是空，说明node就是根节点，此时要重新赋值root节点
				}else if(node.parent.left == node){//node是左孩子
					node.parent.left = replaceNode;//替换父节点的左孩子
				}else{node是右孩子
					node.parent.right = replaceNode;	
				}
				//node节点中的节点引用清空，此时node被删除
				node.left = node.right = node.parent = null;

				if(node.color == BLACK){//如果是红黑树，还要继续判断黑节点删除后树的调整
					fixAfterRemove(replaceNode);//红黑树节点删除需要继续调整构型和颜色
				}	
			}else{//node是叶子节点,直接删除
				Node parent = node.parent;
				if(parent != null){//
					if(parent.left == null){
						parent.left = null
					}else{
						parent.right = null
					}
					if(node.color = BLACK){//如果是红黑树，还要继续判断黑节点删除后树的调整
                                            fixAfterRemove(node);//见红黑树节点的删除后的构型调整
                                    	}
				}else{//如果删除的节点是根节点，root赋值为null,此时树里面没有节点了
					root = null
				}
				node.left = node.right = node.parent = null;
			}
				
	-红黑树节点的删除后的构型调整
		-红黑树节点删除和二叉搜索树节点的删除是一样的
		 如果删除的是黑节点还需要进一步调整树的结构和颜色保证各节点的黑高是一样
	 		
		-2-3-4树节点的删除
		 红黑树的节点删除是从2-3-4树的节点删除衍生来的，如图：red_black_tree_4_2-3-4树的节点删除

		-红黑树节点的删除
		 
		 如果替换的节点是红色，只需要变黑色即可，对应2-3-4树的 3-节点和4-节点的删除
		 如果替换的节点是黑色,对应2-3-4树的2-节点，需要通过向兄弟节点借的方式调整平衡		 	 

		-代码
		 private void fixAfterRemove(RBNode e){
			while(e != root && e.color==BLACK){
				//判断e是左孩子还是右孩子
				if(e.isLeft){
					1.找到右兄弟借
					RBNode rNode = e.parent.right;
					if(rNode.color == red){
						//这种情况对应的2-3-4树里，不会是真正的兄弟节点
						//需要一次变色+左旋转
						rNode.color = Block;//兄弟节点变为黑色
						e.parent.color = RED;//父亲节点变为红色
						leftRotate(e.parent)//对当前节点的父节点做一次左旋
						//旋转后，右兄弟节点需要重新赋值
						rNode = e.parent.left;//rNode这个变量重新赋值以下
					}
					//判断兄弟节点能不能借
					//当兄弟节点一个子节点都没有的情况下，就没法借
					if(rNode.left==Black && rNode.right==Black){
						//这个时候，兄弟节点是没法借的
						rNode.color = RED;//此时把兄弟节点变为红色
						e = e.parent;//进入下一个循环递归执行
					}else{
						//这个时候就可以借
						if(rNode.right.color == Black){
							//如果兄弟节点的右孩子为空，这种情况，它的左孩子肯定不为空
							//这个时候需要先变色，并完成一次右转
							rNode.color = RED;
							rNode.left = Black;
							rightRotate(rNode);
							//右旋后，rNode这个变量重新赋值以下
							rNode = e.parent.right;
						}
						//最后根据父亲节点做一次左旋操作，并变色
						rNode.color = e.parent.color;//兄弟节点变成父亲节点的颜色
						e.parent.color = Black;//父亲节点要变成黑色
						rNode.right = Black；//兄弟节点的右节点变成黑色
						leftRotate(e.parent);
						e = root;//通过这种方式结束while循环
					}		
				}else{
					2 找到左兄弟借
					RBNode lNode = e.parent.left;
					if(lNode.color == red){
						//这种情况对应的2-3-4树里，不会是真正的兄弟节点
						//需要一次变色+右旋转
						lNode.color = Block;//兄弟节点变为黑色
						e.parent.color = RED;//父亲节点变为红色
						rightRotate(e.parent)//对当前节点的父节点做一次右旋
						//旋转后，左兄弟节点需要重新赋值
						lNode = e.parent.left;//
					}
					//判断兄弟节点能不能借
					//当兄弟节点一个子节点都没有的情况下，就没法借
					if(rNode.left==Black && rNode.right==Black){
						//这个时候，兄弟节点是没法借的
						rNode.color = RED;//此时把兄弟节点变为红色
						e = e.parent;//进入下一个循环递归执行
					}else{
						//这个时候就可以借
						if(lNode.left.color == Black){
							//如果兄弟节点的左孩子为空，这种情况，它的右孩子肯定不为空
							//这个时候需要先变色，并完成一次左旋
							lNode.color = RED;
							lNode.right = Black;
							leftRotate(lNode);
							//左旋后，lNode这个变量重新赋值以下
							lNode = e.parent.left;
						}
						//最后根据父亲节点做一次左旋操作，并变色
						lNode.color = e.parent.color;//兄弟节点变成父亲节点的颜色
						e.parent.color = Black;//父亲节点要变成黑色
						lNode.left = Black；//兄弟节点的左节点变成黑色
						rightRotate(e.parent);
						e = root;//通过这种方式结束while循环
					}					
				}	
			}
			setClolor(e,BLACK);//如果替换的节点是红色，直接变黑色
		 }




















