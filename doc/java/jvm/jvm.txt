1、书籍和名人
	国内比较有名的人叫R大，比叫资深的java虚拟机专家，《深入理解java虚拟机》比较早期的书籍，比较经典
2、常用jvm工具
	jconsole:JDK自带的 jvm监控工具，通过jconsole可以查看各进程的 内存，线程,cpu等运行信息
	jvisualvm:oracle自带的集成工具，类似jconsole工具，功能更全面
	jmap:java命令行工具，能够打印给定的java进程，核心文件内存信息，jmap可能在未来的JDK版本中删除
	
3、类加载器的深入理解与阶段分析
	3.1)类加载：class loading
	在java代码中，类型(class , interface ,枚举等)的加载、连接与初始化过程都是在程序运行期间完成的。比如c语言，是在程序编译后，就把类型关系就确立好了，相对于java来说就没有那么灵活。
	类加载提供了更大的灵活性，增加了更多的可能性，所以java虽然是静态的开发语言，但是依然能够完成动态语言的功能
	类型的加载最常见的方式将类文件从磁盘上加载到内存中去。

	3.2)类加载器(class loader):java中的每一个类型最终都会进入到内存当中，类加载器就是用来做这个工作的

	3.3)java虚拟机(程序)的生命周期，在如下几种情况下，java虚拟机将结束声明周期
		执行了System.exit()方法
		程序正常结束
		程序在执行过程中遇到了异常或者错误而异常终止，比如异常没有catch，那么当前异常会一直向上抛出，直到main方法。
		由于系统错误而导致java虚拟机进程终止
	
	3.4)类的加载、连接、与初始化
		加载：查找并加载类的二进制数据
		连接：
	             a)验证，确保被加载的类的正确性，避免二进制文件被恶意修改
		     b)准备，为类的静态变量分配内存，并将其初始化为默认值，注意在这个阶段，静态变量即使在代码中有赋值，但是这个阶段还只是默认值
		     c)解析，把类中的符号引用转换为直接引用
		           符号引用是一种间接的引用，比如System.out.println("aaa"),System out println这三部分就是符号引用，这个符号引用会被存贮在当前类的常量池中
			   在解析阶段虚拟机会把这个符号引用转化为直接引用，指向实际的内存地址
			   这个过程包括查找System类，out子段，println方法以及确定方法的参数和返回值等步骤
			   最终System.out.println("aaa")会被解析成一个指向实际输出流对象的地址，使得程序能够正常执行
		初始化：为类的静态变量赋予正确的初始值(在连接的准备阶段，静态变量只会被赋予默认值)
 	
	3.5)类的使用和卸载
		使用：类的字节码文件加载到内存后，就可以使用了
		卸载：类加载到内存后，是可以销毁的，销毁后的类就不能再使用了，比如不能再实例化对象等
		      比如osgi技术会动态卸载类
	
	3.6) java程序对类的使用方式分为：
		主动使用(7种):
			创建类的实例
			访问某个类或接口的静态变量(getstatic 助记符号)，或者对该静态变量赋值(putstatic 助记符)
			调用类的静态方法（invoke助记符）
			反射
			初始化一个类的子类,子类被初始化的时候，父类也会被初始化
			java虚拟机启动时被标明为启动类的类（有main方法的类）
			JDK1.7开始提供的动态语言支持(比如javascrpt)：java.lang.invoke.MethodHandle实例的解析结果 _getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则立刻初始化
		被动使用:
			除了以上7中主动使用，其他使用java类的方式都被当作是对类的被动使用，都不会导致类的初始化
	     所有的java虚拟机实现必须在每个类或接口被java程序“首次主动使用”时，才初始化他们。

	3.7）类的加载
		类的加载指的是将类的.class文件中二进制数据读如到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构
		规范中并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中
		
		加载.class文件的方式:
			从本地系统(磁盘)中直接加载
			通过网络下载.class文件
			从zip,jar等归档文件中加载.class文件
			从专有数据库中提取.class文件
			将java源文件动态编译为.class文件，比如动态代理(动态代理在编译器是不存在这个类的，只有在运行期在存在) jsp文件(jsp文件中可以嵌入java代码，jsp最终会转化为servlet)
	3.8) 类加载例子：
		源码见 project/jvm_lecture项目 com.sandro.classloader.Test1，com.sandro.classloader.Test2，com.sandro.classloader.Test3
		对于静态字段来说，只有直接定义了这个字段的类在首次主动使用的时候才会初始化，通过子类调用父类的静态字段，子类不会在首次主动使用的时候初始化
	
	        -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来
 	        比如在class根目录中运行:
	        ..../jvm_lecture/out/production/jvm_lecture$ java -XX:+TraceClassLoading com.sandro.classloader.Test1	
	   	
  	        输出如下：
			..... //jdk的一些类
			[Loaded com.sandro.classloader.Test1 from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]//进程主类
			.....//jdk的一些类
			[Loaded com.sandro.classloader.Test1$Parent from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
			[Loaded com.sandro.classloader.Test1$Child from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
   	
5、jvm参数
	一般jvm参数都是已 -XX:开头的
	一般写法有如下几种：
	5.1）布尔类型的设置
		-XX:+<option> ,表示开启 <option>选项，比如：java -XX:+TraceClassLoading com.xxx.xxx.MainClass
		-XX:-<option> ,表示关闭 <option>选项，jvm有些选项是默认开启的，如果在启动某个进程时候不想用某个已经开启的选项，可以通过"-"关闭
	5.2）赋值设置
		-XX:<option>=<value> 表示将option选项的值设置为value,如：-XX:SurvivorRatio=8,表示eden区与survivior区大小比例为8比1
	
4、常量的本质含义与反编译及助记符详解
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test3
	final修饰的字符串是常量，在编译阶段这个常量就已经保存在调用这个常量的方法所在类的常量池中了
			
	通过 javap -c com.sandro.classloader.Test3反编译
	如下：
		sandro@sandro-Lenovo-XiaoXin-V4000:~/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture$ javap -c com.sandro.classloader.Test3
		Compiled from "Test3.java"
		public class com.sandro.classloader.Test3 {
  			public com.sandro.classloader.Test3();
    				Code:
       					0: aload_0
       					1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       					4: return

  			public static void main(java.lang.String[]);
    				Code:
       					0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       					3: ldc           #4                  // String hello world
       					5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       					8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					11: bipush        567
      					13: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
      					16: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					19: new           #7                  // class java/lang/StringBuilder
      					22: dup
      					23: invokespecial #8                  // Method java/lang/StringBuilder."<init>":()V
      					26: ldc           #9                  // String list size is
      					28: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      					31: getstatic     #11                 // Field com/sandro/classloader/Test3$Parent.list:Ljava/util/List;
      					34: invokeinterface #12,  1           // InterfaceMethod java/util/List.size:()I
      					39: invokevirtual #13                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      					42: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      					45: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      					48: return

		}

	助记符：
	ldc : 表示将int,float 或者 String类型的常量值从常量池中推送置栈顶	
	bipush:表示将单字节(-128~127)的常量推送置栈顶，从测试结果看567也用的是bipush，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	sipush:表示将一个短整形常量值（-32768~32767）推送到栈顶，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	iconst_1:表示将int类型的数字1推送置栈顶，最多到iconst_5,也就是说jvm对int类型 -1～5单独设置了助记符, -1对应的助记符iconst_m1
	助记符的实现在rt.jar中，都有相应的源码可以查看，比如ldc bipush等就在com.sun.org.apache.bcel.internal.generic包下

5、编译期常量与运行期常量的区别
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test4 
	当一个常量的值如果不能在编译期间确定，那么其值就不会被放到调用类的常量池中
	这时在运行程序时，会导致主动使用这个常量所在的类，这个类就肯定会被初始化
	
6、数组创建本质分析
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test5
	对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.xxx.xxx
	动态生成的类型其父类是Object
	对于数组来说，JavaDoc经常构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。
	助记符：
		anewarray，表示创建一个引用类型的（如类，接口，数组）数组，并将其引用值压入栈顶
		newarray,表示创建一个指定的原始类型（如：int,char,short等）的数组，并将其引用压入栈顶

7、接口初始化规则
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test6
	接口中的属性都是public static final的，也就是一个常量，如果是确定的常量，则编译期间这个常量会保存在调用类中的常量池中
	如果常量是需要运行期间才能确定的，那么这个常量首次主动调用时，接口会被初始化，如果接口有父类，父类也会被初始化

8、类连接阶段和初始化阶段静态变量赋值顺序的例子
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test7
	初始化阶段是对静态变量赋值的阶段，赋值的顺序是按照代码从上到下的顺序执行的，因此如果书写不当，有可能造成意外情况。

9、类加载器深入解析及重要特性剖析
	1)进程启动顺序
		开始 		 
		 ⥥	     
	     是否装载APP ----否----> ClassLoader装载成功 -------否---------------> 抛出异常
                 ↓                           ↓                                        ↓
                 是                          ↓                                        ↓
                 ↓                           ↓                                        ↓   
	        连接<----------成功----------+			                      ↓
		 ↓                                                                    ↓
          初始化主入口的类---------------------------->调用主类.main()函数---------->结束
  
	2)
	        +--------------------------+
	开始--- |---> 验证--->准备---->解析|-->初始化--->实例化---->垃圾回收及对象终结--->结束	
		+--------------------------+
		加载：就是把二进制形式的java类读入java虚拟机中
		
		连接：验证，准备，解析
		
                初始化：为类的静态变量赋值
		
	        类的实例化：1)为新的对象分配内存，一般是在堆上分配
			    2)为实例变量赋默认值
			    3)为实例变量赋正确的初始值
			    4)java编译器会为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被成为“<init>”。针对源代码中的每一个类的构造方法，
			      java编译器都产生一个“<init>”方法
        
        3)类的加载
	 -类的加载的最终产品是位于内存中的Class对象
	 -Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口
	 -有两种类型的类加载器
		1)java虚拟机自带的加载器
		      -根类加载器(Bootstrap classloader),也叫启动类加载器
		      -扩展类加载器(Extension classloader)
		      -系统(应用)类加载器(System/app classloader)
                2)用户自定义的类加载器
		      -java.lang.ClassLoader的子类
		      -用户可以定制类的加载方式
         -类加载器并不需要等到某个类被“首次主动使用”时再加载它，比如使用-XX:+TraceClassLoading 就能看到每个类加载的顺序  
	  源码分析详见 project/jvm_lecture项目 com.sandro.classloader.Test7
	  原因：
		1)jvm规范允许类加载器在预料某个类将要被使用时就预先加载它。
		  如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)
		2）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
       
	4)类连接中的验证阶段
	  -类加载后，就进入了连接阶段。连接就是将已经读到内存的类的二进制数据合并到虚拟机的运行时环境中去。
	  -类的验证内容（主要验证工作，不同虚拟机细节上会有不同）
		1）类文件的解构检查
		2）语义检查
		3）字节码验证
		4）二进制兼容性的验证	
	
	5)类连接中的准备阶段
	  在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认初始值。
	  例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且默认赋值为0，为long类型的静态变量b分配8各字节的内存空间，同样的默认赋值为0
		public class Sample{
			private static a=1;
			private static long b;
   			static{
				b=2;
			}
		}
        
	6)类的初始化
	  在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。
	  在程序中，静态变量的初始化有两种途径：
		(1)在静态变量的声明出进行初始化
	        (2)在静态代码块中进行初始化。
          例如在以下代码中，静态变量a和b都被显示初始化，而静态变量c没有被显示初始化，它将保持默认值0
                 public class Sample{
                         private static a=1; //在静态变量的声明出进行初始化
                         private static long b;
		         private static long c:
                         static{
                                 b=2;        //在静态代码块进行初始化
                         }
                 }
	
	静态变量的声明语句，以及静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。
	例如当以下sample类被初始化后，它的静态变量的取值是4
		public class sample{
			static int a=1;
			static{ a=2; }
			static{ a=4; }
       			public static void main(String args[]){
				System.out.println(a);// 输出 ：4	
			}
		}
  	
	7)类的初始化步骤：
		-假如这个类还没有被加载和连接，那就先进行加载和连接
		-假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
		-假如类中存在初始化语句，那就依次执行这些初始化语句

	8)类的初始化时机(7种)
		-创建类的实例
		-访问某个类或接口的静态变量，或者对该静态变量赋值
		-调用类的静态方法
		-反射
		-初始化一个类的子类
		-java虚拟机启动时被标明为启动的类
	  	-JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle 实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化则初始化
		
	  除了上述7种情形，其他使用java类的方式都被看做是被动使用，不会导致类的初始化
	  当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
		-在初始化一个类时，并不会先初始化它所实现的接口
		 源码见 project/jvm_lecture项目 com.sandro.classloader.Test9
 
		-在初始化一个接口时，并不会先初始化它的父接口
		 源码见 project/jvm_lecture项目 com.sandro.classloader.Test10

          因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量(实际是不确定的常量，比如获取uuid之类的)时，才会导致该接口的初始化
 	  只有当程序访问的静态变量或者静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用
	  调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用。不会导致类的初始化
	  
	 9)类加载器
	   类加载器用来把类加载到java虚拟机中。从jdk1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好的保证java平台的安全。
	   在此委托机制中，出了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。
	   当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。
 	   如果loader1本身加载失败，就抛异常了
	
	   虚拟机自带了以下几种加载器
		-根类加载器(Bootstrap ClassLoader): 也叫启动类加载器，该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。
		                                    类如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。
					            根类加载器的实现依赖于底层操作系统，由c++实现，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。
						    加载$JAVA_HOME中 jre/lib/rt.java
	
		-扩展类加载器（Extension ClassLoader）: 它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的 jre\lib\ext子目录(扩展目录)中加载类库
					                如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯JAVA类，是java.lang.ClassLoader类的子类。
		-系统加载器（System):也成为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类。
				     它是用户自定义的类加载器的默认父类加载器。系统类加载器是纯JAVA类，是java.lang.ClassLoader类的子类
	   除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载都应该继承ClassLoader类。
	   
	   类加载器层级关系图：他们并不是继承关系，实际上是包含关系
	
			根类加载器
	                     ⬆
		        扩展类加载器
			     ⬆
		        系统类加载器
			     ⬆
		     用户自定义类加载器	
 			     
	   	比如 系统类加载要加载一个类，先交给父亲扩展类加载器加载，扩展类加载器会继续向上交给根类加载器加载，如果此时根类加载器加载不了，则会重新返回给扩展类加载器加载
		     扩展类加载器如果也加载不了，则最后只能返回给系统类加载器去加载。这个时候如果系统类加载器也加载不了，就会抛异常了
			
10、类加载双亲委托机制详解
	1）类加载的父亲（双亲）委托机制
	   在父亲委托机制中，各个加载器按照父子关系形成了属性结构，除了根类加载器之外，其余加载器都有且只有一个父加载器
                       
                             根类加载器
                                 ⬆
                            扩展类加载器
                                 ⬆
                            系统类加载器-----+
	                         ⬆ 委托      ↓ 加载动作通过loader1委托给系统加载器类，一般工程中的类实际上都是系统类加载器实际完成的
                               loader1<-----加载-----> Sample类 
                                 ⬆
                               loader2       
                                                         
         
	2）类加载器查询加载器示意图
            
         ⬆                                           ↓ 
 	 ⬆ 1.                                        ↓ 
	 ⬆ 自        +--------------------------+    ↓ 
	 ⬆ 底        |ClassLoader Architecture  |    ↓ 
	 ⬆ 向        |                          |    ↓ 2.
	 ⬆ 上        |     Bootstrap ClassLoader|    ↓ 自 ---------> Load JRE/lib/rt.jar或者 -Xbootclasspath选项指定的jar包
	 ⬆ 检        |                          |    ↓ 顶
	 ⬆ 查        |                          |    ↓ 向
	 ⬆ 类        |     Extension ClassLoader|    ↓ 下 ---------> Load JRE/lib/ext/*.jar或 -Djava.ext.dirs指定目录下的jar包
         ⬆ 是        |                          |    ↓ 尝
	 ⬆ 否        |                          |    ↓ 试   
	 ⬆ 已        |      App ClassLoader     |    ↓ 加 ---------> Load CLASSPATH或 -Djava.class.path所指定的目录下的类和jar包
         ⬆ 经        |                          |    ↓ 载
	 ⬆ 加        |                          |    ↓ 类 
	 ⬆ 载        |      Custom ClassLoader  |    ↓    ---------> 通过java.lang.ClassLoader的子类自定义加载class
         ⬆           +--------------------------+    ↓
         ⬆                                           ↓
	
	3)定义类加载器和初始类加载器
	  -若有一个类加载器能够成功加载用户自己编写的Test类，那么这个类加载器被成为定义类加载器  
 	  -所有能成功返回Class对象引用的类加载（包括定义类加载器）都被成为初始类加载器
          -比如 1）图中所示，loader1尝试加载 Sample类，最终实际上是系统类加载器加载成功，那么此时系统类加载器就被称为定义类加载器，
		   因为sample类对象的引用是从loader1中返回的，因此loader1是初始类加载器，loader1的父亲也是处是类加载器

	4)使用类加载器加载class
	  源码见 project/jvm_lecture项目 com.sandro.classloader.Test11
	  
11、类加载器与类初始化案例
	1）演示类的常量和静态变量读取时，类的初始化例子
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test8
	
	2）演示类加载和初始化顺序的例子
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test12
	
        3）类的实例化导致初始化的例子
           源码见 project/jvm_lecture项目 com.sandro.classloader.Test13

	4）通过子类调用父类的静态变量和静态方法，都只能算是对父类的主动使用 案例
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test14

	5）通过classloader加载的class对象不会初始化，通过反射加载的class对象会让类初始化
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test15	

12、不同的类加载器作用与加载器动作分析
	1) 读取系统类加载器，并循环读取其所有的父加载器
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test16

	2) 上下文类加载器，通过类加载器读取资源在磁盘上的路径
	   jar hell问题以及解决方法
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test17

	3) 获得Classloader的途径
	   clazz.getClassLoader();//获取当前类的ClassLoader
	   Thread.currentThread().getContextClassLoader();//获得当前线程上下文的classloader
	   ClassLoader.getSystemClassLoader();//获取系统类加载器
	   DriverManager.getCallerClassLoader();//获得调用者的ClassLoader

13、ClassLoader源码分析与实例剖析
	-ClassLoader抽象类，要自定义加载器必须要继承ClassLoader
	-ClassLoader加载类的时候需要二进制文件名
	-如：
           "java.lang.String"
    	   "javax.swing.JSpinner$DefaultEditor"
           "java.security.KeyStore$Builder$FileBuilder$1"
           "java.net.URLClassLoader$3$1"
	-每一个class对象都包含一个定义这个类的ClassLoader
	
	-数组类型对应的class对象并不是classloader创建的，它是jvm根据需要自动创建的，数组使用的类加载器和数组元素的类加载器是一样的，如果数组中的元素是源是类型，那么数组类是没有类加载器的
	 案例： project/jvm_lecture项目 com.sandro.classloader.Test18
	
	-ClassLoader使用的是双亲委托模型去查找类或者资源。启动类加载器是没有双亲的。

	-支持多线程加载类的加载器叫做并发加载器(parallel capable class loader)，并发加载器需要使用ClassLoader.registerAsParallelCapable方法去注册，默认情况下ClassLoader已经注册了
	 如果子类需要并行加载的化，子类也需要注册
	 在委托模型不是严格化层次的环境下，加载器需要注册为并发加载器，否则有可能出现死锁问题
	
	-jvm通常情况下是从本地文件系统加载的，比如unix使用的是CLASSPATH环境变量指定的路径加载类库
 	-有些类并不是来源与文件，有可能通过其他来源，比如网络，动态代理等，这种情况下defineClass方法可以把字节数组转化为一个class实例
	 NetworkClassLoader源码中可以看到defineClass方法的使用
	 例如：ClassLoader loader = new NetworkClassLoader(host,port);
	       Object main = loader.loadClass("Main",true).newInstance();
      
14、自定义加载器实例
	project/jvm_lecture项目 com.sandro.classloader.Test19

15、类的命名空间
	每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类所组成
	在同一个命名空间中，不会出现类的完整的名字(包括类的包名)相同的两个类
	在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类
	
	命名空间中的类加载关系：
		子加载器加载的类，可以访问父加载器加载过的类
		而父加载器加载的类，不能访问子加载器加载的类
	
16、类的卸载
	-当Sample类被加载、连接和初始化后，它的声明周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束声明周期。
	 Sample类在方法区内的数据也会被卸载，从而结束Sample类的声明周期。

	-一个类何时结束声明周期，取决于代表它的对象何时结束声明周期。

	-由java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载，java虚拟机自带的类加载器包括根加载器、扩展类加载器和系统加载器。     
	 java虚拟机本身会始终引用这些类的加载器，而这些类加载器则会始终引用他们所加载的Class对象，因此这些Class对象始终是可及的。

	-用户自定义的类加载器所加载的类是可以被卸载的。   

	-比如，sample类由load1加载，在类的加载器的内部实现中，用一个java集合来存放所加载类的引用。
	 另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader方法，就能获得它的类加载器。
	 由此可见，代表Sample类的Class实例与loader1之间为双向关联关系。
	 一个类的实例总是引用代表这个类的Class对象。在Object类总定义了getClass()方法，这个方法返回代表对象所属的类的class对象的引用。
	 此外，所有java类都有一个静态属性class，它引用代表这个类的class对象

	-类卸载的例子：project/jvm_lecture项目 com.sandro.classloader.Test20

17、自定义类加载器在复杂情况下的运行分析
	project/jvm_lecture项目 com.sandro.classloader.Test21

18、类加载器的命名空间案例
	project/jvm_lecture项目 com.sandro.classloader.Test22

19、jvm各种加载器类的路径和设置
	project/jvm_lecture项目 com.sandro.classloader.Test23	
	
	扩展类加载器类路径设置方法：
		java -Djava.ext.dirs = ./com.xxx.xxxx.xxx
		将当前目录中的类设置为扩展加载器加载的类路径，这样修改该以后，其他的所有扩展包都无法加载了，要小心使用

20、不同命名空间加载相同类导致的问题
	project/jvm_lecture项目 com.sandro.classloader.Test24

21、类加载的双亲委托模型的优势
	1)可以确保java核心库的类型安全:所有的java应用都至少会引用java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到jvm中
				       如果这个加载过程是由java应用自己的类加载器所完成的。那么很可能能就会在jvm中存在多个版本的java.lang.Object的类
			               而且这些类还是相互不兼容，相互不可见的(由于命名空间导致)。
				       借助于双亲委托机制,java核心类库中的类的加载工作都是由启动类(根类)来统一加载完成，从而确保了java应用所使用的都是同一个版本的java核心类库。
				       他们相互之间都是兼容的
	2)可以确保java核心类库所提供的类不会被自定义的类所替代
	3)不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间，相同名称的类可以并存在jvm中只需要用不同的类加载器来加载他们即可。
	  不同类加载器所加载的类之间是不兼容的，这就相当于在jvm内部创建了一个又一个相互隔离的java类空间，这类技术在多框架中都得到了实际的应用。
        4)某些框架比如tomcat 会修改双亲委托模型以满足web开发的需要

22、扩展类加载器类路径设置要点
	project/jvm_lecture项目 com.sandro.classloader.Test25
	-扩展类加载器默认是加载jar包的，而不是class文件
	 在class目录下运行jar命令给Test1打成jar包，并命名为test.jar
	project/jvm_lecture/out/production/jvm_lecture$ jar cvf test.jar com/sandro/classloader/Test1.class
	
	-运行时设置扩展类加载器：
		在~project/jvm_lecture/out/production/jvm_lecture目录下运行 设置扩展类加载器命令
		java -Djava.ext.dirs=./ com.sandro.classloader.Test25
		-D 一般是运行时设置，java.ext.dirs=./ 将当前目录设置为扩展类加载器需要加载的类路径

23、平台特定的启动类加载器深入分析
	project/jvm_lecture项目 com.sandro.classloader.Test26
	在运行期，一个java类是由该类的完全限定名(binary name,二进制名)和用于加载该类的定义类加载器(defining loader)所共同决定的
	如果同样名字(相同的完全限定名)的类是由两个不同的加载器所加载，那么这些类就是不同的，即使class文件的字节码完全一样，并且从相同的位值加载亦如此

	ClassLoader存在于rt.jar，它是由启动类加载器加载的。启动类加载器是c++编写的它内建于jvm中。
	扩展类加载器和应用类加载器是在jvm启动的时候被启动类加载器加载（Bootstrap ,这是一个特殊机器码，是特定于平台的机器指令，它负责开始整个加载过程）
	加载第一个纯java类加载器就是启动类加载器的职责
	启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。

24、类加载器源码分析
	1）ClassLoader.getSystemClassLoader()
	   -返回用于委托的系统类加载器。它是所有新的ClassLoader实例的默认的委托双亲。它也是通常用于启动应用的类加载器
	    这个方法首先在运行期启动很早的时候就被调用，在被调用的时刻会创建系统类加载器，并且将其设置为所在线程的上下文类加载器(context class loader)	
	    默认的系统类加载器是与这个类实现相关的实例
	    如果系统属性 java.system.class.loader指定了一个类，那么这个类就会替换条默认的系统类加载器。这个类默认是系统类加载器加载的。这个类必须是ClassLoader的子类，并且实现了设置双亲的构造函数
	    	protected ClassLoader(ClassLoader parent) 
	    系统类加载器会作为这个自定义系统类加载器的父加载器
	   
           -源码说明：
		initSystemClassLoader:ClassLoader创建的时候调用，
                                      sclSet：如果设置了系统类加载器，就不再设置了
				      scl:静态变量，保存当前系统类加载器
				      sun.misc.Launcher:这里面定义了系统类加载器和应用类加载器，sun的Launcher没有开源，如果想看开源的代码可以查看openjdk开源代码
                                                        官网:openjdk.java.net			
	   	                                        在launcher构造方法中
								1）创建扩展类加载器 ExtClassLoader.getExtClassLoader()
								   在静态块中ClassLoader.registerAsParallerCapable()，注册了可以并行加载的接口
								   这里面可以看到java.ext.dirs属性的作用，会读取这个属性目录的类文件
								   并对每一个文件进行权限校验			
								2）创建应用类加载器AppClassLoader.getAppClassLoader(extclassloader)
								   这个对象赋值给一个Launcher的成员变量
								   appclassloader从java.class.path路径中加载，并运行在一个安全受限的上下文中
								   将extclassloader赋值给appclassloader的父加载器
                                                                3) Thread.currentThread().setContetClassLoader(loader)
                                                                   为当前的执行线程设置上下文类加载器
								4）设置安全管理器
                                      将Launchuer中的loader,实际上就是应用类夹杂器赋值给scl		   		
				      对scl进行权限验证：SystemClassLoaderAction(scl)	              
							 1)读取java.system.class.loader系统属性
	                                                 2)如果为空，使用原有的应用类加载器
							   如果不为空，反射生成对应的类加载器实例，并且把当前的应用类加载器设置为新实例的父加载器
	     						 3)将新的应用类加载器设置到当前线程的上下文类加载器中

25、上下文类加载器
	-project/jvm_lecture项目 com.sandro.contextclassloader.Test101
	 当前类加载器：current Classloader ,用于加载当前类的加载器
                      每各类都会使用自己的类加载器（即加载自身的类加载器）去加载其他类(这个类所依赖的其他类)
		      比如：classX引用了classY,那么classX的加载器去加载classY(前提是classY没有被加载过)
	-线程上下文类加载器：Context ClassLoader
		            线程上下文类加载器，从JDK1.2开始引入
			    get/setContextLoader()用于获取和设置一个类加载器
		            如果没有设置的情况下，线程将继承其父线程上下文类加载器
			    java应用运行时的初始线程的上下文类加载器，是应用类加载器
        		    在线程中运行的代码可以同过该类加载器来加载类与资源
	
	-线程上下文类加载器的重要性
 	 比如JDBC连接方式：
		Class.forName("com.mysql.driver.Driver");
		Connection conn = Driver.getConnection();
		Statement st = conn.getStatment();
         JDBC是一套连接标准，它提供了基本的接口和标准类，这些类是在java核心库rt.jar的 java.sql中，比如java.sql.Connection
	 这些接口是由启动加载器加载的，具体的实现是在各厂商数据库实现中，而厂商的类库是放在classpath中的，由应用类加载器加载                 
	 基于加载器的双亲委托模式，启动类加载的类和接口（SPI，Service Provider Interface）无法加载应用类加载器中的类(厂商的接口实现)
	 为了解决这个问题，jvm提供了线程上下文类加载器：父ClassLoader可以使用当前线程的Thread.currentThread().getContextClassLoader()去加载classpath中的类
	 这就解决了父classloader不能使用子classloader加载的类的问题，即改变了双亲委托模型
	
        -总结：在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层加载器加载，但是对于SPI，有些接口是java核心库提供的
               java核心库由启动类加载器加载，这些接口实现却来自与不同的jar包（厂商提供），java的启动类加载是不会加载其他来源的jar包
	       这样传统双亲模型就无法满足SPI的要求，而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来加载接口实现类
	-常见的SPI:JDBC，JNDI(java命名和目录接口标准)，JAXP(xml解析标准)，这些SPI接口实现类的加载都需要打破双亲委托模式才能执行。
	-不使用jvm的双亲委托模式的理论子：tomact，tomcat为了让服务隔离，也重新实现了自己的类加载器，如果子类能加载，就加载，不去委托父加载器，这和传统的双亲委托模式完全相反了
	 但是能非常好的使用服务器上多个web服务同时执行的情况

26、上下文类加载器应用实例
	-project/jvm_lecture项目 com.sandro.contextclassloader.Test102
	 线程上下文类加载器的一般使用模式（获取->使用->还原）
         当高层提供了统一的接口让底层区实现，同时又要在高层加载(实例化)底层的类时，就必须要通过上下文类加载器来帮助高层的ClassLoader找到并加载该类
        
	-jvm ServiceLoader通过上下文加载器加载mysql jdbc 驱动实现类的例子
	 project/jvm_lecture项目 com.sandro.contextclassloader.Test103
	
27、java字节码文件结构查看
	-project/jvm_lecture项目 com.sandro.bytecode.Test1
	
	-项目class根目录下使用javap 命令查看class源码文件的框架信息:javap com.sandro.bytecode.Test1
 	 此时输出的是一个类的框架，但是没有私有变量，类的很多相关信息是没有的
	
	-使用 javap -c com.sandro.bytecode.Test1 查看更详细的类助记符信息
	 使用javap -c依然无法看到全部的信息
     
        -使用javap -verbose -p com.sandro.bytecode.Test1 可以看到全部的类助记符信息
	 -verbose将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类中的变量与成员变量的信息
	 -p 将会把私有方法也输出出来，不使用-p只会展示共有方法
	
	-linux下使用 hexdump -C Test1.class 命令可以查看16进制的信息
	 [-C] 规范化"十六进制+ASCII"显示,显示结果如下：
		00000000  ca fe ba be 00 00 00 34  00 3a 0a 00 0c 00 20 09  |.......4.:.... .|
		00000010  00 06 00 21 09 00 22 00  23 07 00 24 0a 00 04 00  |...!..".#..$....|
		00000020  20 07 00 25 0a 00 26 00  27 0a 00 04 00 28 08 00  | ..%..&.'....(..|
		00000030  29 0a 00 04 00 2a 0a 00  2b 00 2c 07 00 2d 01 00  |)....*..+.,..-..|
		00000040  01 61 01 00 01 49 01 00  06 3c 69 6e 69 74 3e 01  |.a...I...<init>.|
		00000050  00 03 28 29 56 01 00 04  43 6f 64 65 01 00 0f 4c  |..()V...Code...L|
		00000060  69 6e 65 4e 75 6d 62 65  72 54 61 62 6c 65 01 00  |ineNumberTable..|
		00000070  12 4c 6f 63 61 6c 56 61  72 69 61 62 6c 65 54 61  |.LocalVariableTa|
		00000080  62 6c 65 01 00 04 74 68  69 73 01 00 1b 4c 63 6f  |ble...this...Lco|
		00000090  6d 2f 73 61 6e 64 72 6f  2f 62 79 74 65 63 6f 64  |m/sandro/bytecod|
		000000a0  65 2f 54 65 73 74 31 3b  01 00 04 73 65 74 41 01  |e/Test1;...setA.|
		000000b0  00 04 28 49 29 56 01 00  04 67 65 74 41 01 00 03  |..(I)V...getA...|
		000000c0  28 29 49 01 00 04 6d 61  69 6e 01 00 16 28 5b 4c  |()I...main...([L|
		000000d0  6a 61 76 61 2f 6c 61 6e  67 2f 53 74 72 69 6e 67  |java/lang/String|
		000000e0  3b 29 56 01 00 04 61 72  67 73 01 00 13 5b 4c 6a  |;)V...args...[Lj|
		000000f0  61 76 61 2f 6c 61 6e 67  2f 53 74 72 69 6e 67 3b  |ava/lang/String;|
		00000100  01 00 0a 53 6f 75 72 63  65 46 69 6c 65 01 00 0a  |...SourceFile...|
		00000110  54 65 73 74 31 2e 6a 61  76 61 0c 00 0f 00 10 0c  |Test1.java......|
		00000120  00 0d 00 0e 07 00 2e 0c  00 2f 00 30 01 00 17 6a  |........./.0...j|
		00000130  61 76 61 2f 6c 61 6e 67  2f 53 74 72 69 6e 67 42  |ava/lang/StringB|
		00000140  75 69 6c 64 65 72 01 00  19 63 6f 6d 2f 73 61 6e  |uilder...com/san|
		00000150  64 72 6f 2f 62 79 74 65  63 6f 64 65 2f 54 65 73  |dro/bytecode/Tes|
		00000160  74 31 07 00 31 0c 00 32  00 33 0c 00 34 00 35 01  |t1..1..2.3..4.5.|
		00000170  00 05 20 74 65 73 74 0c  00 36 00 33 07 00 37 0c  |.. test..6.3..7.|
		00000180  00 38 00 39 01 00 10 6a  61 76 61 2f 6c 61 6e 67  |.8.9...java/lang|
		00000190  2f 4f 62 6a 65 63 74 01  00 10 6a 61 76 61 2f 6c  |/Object...java/l|
		000001a0  61 6e 67 2f 53 79 73 74  65 6d 01 00 03 6f 75 74  |ang/System...out|
		000001b0  01 00 15 4c 6a 61 76 61  2f 69 6f 2f 50 72 69 6e  |...Ljava/io/Prin|
		000001c0  74 53 74 72 65 61 6d 3b  01 00 0f 6a 61 76 61 2f  |tStream;...java/|
		000001d0  6c 61 6e 67 2f 43 6c 61  73 73 01 00 07 67 65 74  |lang/Class...get|
		000001e0  4e 61 6d 65 01 00 14 28  29 4c 6a 61 76 61 2f 6c  |Name...()Ljava/l|
		000001f0  61 6e 67 2f 53 74 72 69  6e 67 3b 01 00 06 61 70  |ang/String;...ap|
		00000200  70 65 6e 64 01 00 2d 28  4c 6a 61 76 61 2f 6c 61  |pend..-(Ljava/la|
		00000210  6e 67 2f 53 74 72 69 6e  67 3b 29 4c 6a 61 76 61  |ng/String;)Ljava|
		00000220  2f 6c 61 6e 67 2f 53 74  72 69 6e 67 42 75 69 6c  |/lang/StringBuil|
		00000230  64 65 72 3b 01 00 08 74  6f 53 74 72 69 6e 67 01  |der;...toString.|
		00000240  00 13 6a 61 76 61 2f 69  6f 2f 50 72 69 6e 74 53  |..java/io/PrintS|
		00000250  74 72 65 61 6d 01 00 07  70 72 69 6e 74 6c 6e 01  |tream...println.|
		00000260  00 15 28 4c 6a 61 76 61  2f 6c 61 6e 67 2f 53 74  |..(Ljava/lang/St|
		00000270  72 69 6e 67 3b 29 56 00  21 00 06 00 0c 00 00 00  |ring;)V.!.......|
		00000280  01 00 02 00 0d 00 0e 00  00 00 04 00 01 00 0f 00  |................|
		00000290  10 00 01 00 11 00 00 00  38 00 02 00 01 00 00 00  |........8.......|
		000002a0  0a 2a b7 00 01 2a 04 b5  00 02 b1 00 00 00 02 00  |.*...*..........|
		000002b0  12 00 00 00 0a 00 02 00  00 00 03 00 04 00 04 00  |................|
		000002c0  13 00 00 00 0c 00 01 00  00 00 0a 00 14 00 15 00  |................|
		000002d0  00 00 01 00 16 00 17 00  01 00 11 00 00 00 3e 00  |..............>.|
		000002e0  02 00 02 00 00 00 06 2a  1b b5 00 02 b1 00 00 00  |.......*........|
		000002f0  02 00 12 00 00 00 0a 00  02 00 00 00 07 00 05 00  |................|
		00000300  08 00 13 00 00 00 16 00  02 00 00 00 06 00 14 00  |................|
		00000310  15 00 00 00 00 00 06 00  0d 00 0e 00 01 00 01 00  |................|
		00000320  18 00 19 00 01 00 11 00  00 00 2f 00 01 00 01 00  |........../.....|
		00000330  00 00 05 2a b4 00 02 ac  00 00 00 02 00 12 00 00  |...*............|
		00000340  00 06 00 01 00 00 00 0b  00 13 00 00 00 0c 00 01  |................|
		00000350  00 00 00 05 00 14 00 15  00 00 00 09 00 1a 00 1b  |................|
		00000360  00 01 00 11 00 00 00 4c  00 03 00 01 00 00 00 1e  |.......L........|
		00000370  b2 00 03 bb 00 04 59 b7  00 05 12 06 b6 00 07 b6  |......Y.........|
		00000380  00 08 12 09 b6 00 08 b6  00 0a b6 00 0b b1 00 00  |................|
		00000390  00 02 00 12 00 00 00 0a  00 02 00 00 00 0f 00 1d  |................|
		000003a0  00 10 00 13 00 00 00 0c  00 01 00 00 00 1e 00 1c  |................|
		000003b0  00 1d 00 00 00 01 00 1e  00 00 00 02 00 1f        |..............|
		000003be
	jclasslib:https://github.com/ingokegel/jclasslib
	          这是一个java class字节码查看工具相对与javap命令更详细的展示class各字节含义	
	          在idea中 setting->plugin 中可以搜索jclasslib 并安装，就可以直接在编译器上方便的查看了，安装之后重启，就能找到Bytecode viewer，在这里就可以查看了
	java 字节码整体结构：
		Magic Number(4个字节) :魔数 值为0xCAFEBABE(咖啡宝贝) ，由java创始人James Gosling制定
		Version(2 + 2 个字节) :包括minor_version和major_version: 1.1(45),1.2(46),1.3(47),1.4(48),1.5(49),1.6(50),1.7(51),1.8(52).指令集多年不变，但是版本号每次发布都变化
		Constant Pool(2 + n个字节) :包括字符串常量，数值常量等
		Access Flags(2个字节):针对于当前类的访问标志，比如public final class,public class 等
		This Class Name(2个字节):当前类的名字
		Super Class Name(2个字节):当前类的父类
		Interface(2+n个字节):当前类实现的接口列表
		Fields(2 + n个字节):当前类的成员变量的信息
		Methods(2+n个字节):当前类的方法列表
		Attributes(2+n个字节):当前类的附加属性，一些编译器在编译的时候会往这里插入一些特殊属性供jvm执行的时候使用
	

28、java字节码魔数，版本号，常量池(constant pool)深入分析
         -对于class字节码来说 都是已8位(1个字节)为单位来记录的
         -魔数：所有的字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE(咖啡宝贝)，魔数值用来初步判断该字节码是否是一个有效的java字节码文件
         -主办本号：major version: 52，对应魔数后面的4个字节中的后两个字节(00 00 00 34中的0034)，52对应jdk8 51对应jdk7.....
         -次版本号: minor version: 0 , 对应魔数后面的4个字节中的前两个字节(00 00 00 34中的0000)
                    所以该文件的版本号 是 1.8.0，1.8对应0034 .0对应0000 ，可以通过java -version查看当前java的版本号
                    jvm在执行class文件的时候就是根据这个版本号确认是否可以兼容

	-紧接着主版本号之后的就是常量池入口(第9个字节开始)。
	-一个java类定义的很多信息都是由常量池维护和描述的，一般来讲常量池是class文件中最大的部分，jvm执行时根据一个索引就可以在常量池中找到具体信息的位值，可以将常量池看作是class文件的资源仓库。
	-常量池中包含java类中定义的方法与变量信息。
	-常量池中主要存储两类常量:子面量与符号量
		-子面量:文本字符串；java中声明为final的常量值等
		-符号量:类和接口的全局限定名(包名和类名)；字段的名称和描述符；方法的名称和描述符等。
	-常量池的总体解构：java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。
		常量池数量：紧跟在主办本号后面的两个字节，比如:ca fe ba be 00 00 00 34  00 3a 0a 00 0c 00 20 09... 中， 00 3a就是常量池数量58个，
		常量池数组：-紧跟在常量池数量之后,比如:ca fe ba be 00 00 00 34  00 3a 0a 00 0c 00 20 09... 中， 0a 00 0c 00 20 09... 就是常量池数组
			    -常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、解构都是不同的，所以每个元素占据的空间也是不同的。但是每一种元素的第一个数据都是一个u1类型。
			    -u1类型是一个标志位，占据一个字节，jvm在解析类型时就可以根据u1类型来读取具体的信息。
			    -u1一个字节，u2两个字节，u4四个字节，u8八个字节
			    -经典的常量类型有11种，从jdk7开始扩增，具体类型可以从官网中查到
			    -比如 CONSTANT_Utf8_info分三部分:tag(u1),length(U2),bytes(u1),这里tag值为1，代表后面的数据是一个utf8数据，之后的length为U2占用两个字节代表字符串的长度，bytes就是长度
			     为length的UTF-8编码的字符串
		对应的javap -verbose 命令中Constant pool中的元素实际上是57个，这里需要注意常量池数组中的元素个数 = 常量池数量-1 (其中0不使用)。
		这么做的目的是满足某些常量池索引值的数据在特定情况下需要表达"不引用任何一个常量池"的含义。
		根本原因是索引为0也是一个常量(保留常量)，只不过它不位于常量数组中，这个常量就对应null值，所一个常量池的索引从1而非0开始。
	
	-在jvm规范中，每个变量/字段都有描述信息，描述信息主要作用是描述字段的数据类型，方法的参数列表(包括数量，类型与顺序)与返回值。
	 根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示(如：Ljava/lang/String;)。
	 这么做的原因是为了压缩字节码文件的体积，对于基本数据类型jvm都只使用一个大写子母来表示
		如：B - byte
		    C - char
		    D - double
	            F - float
                    I - int
	            J - long
		    S - short
	  	    Z - boolean
                    V - void
		    L+全限定名 - 对象类型 如：Ljava/lang/String; 
	-对于数组类型来说，每一个维度使用一个前置的方括号来表示，如：int[] 被记录为 [I 。String[][]被记录为[[Ljava/lang/String;

	-用描述符来描述方法的时候，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()只内，
	 如方法：String getName(int id , String name) 的描述符为(I,Ljava/lang/String;)Ljava/lang/String;
	 默认的构造函数用<init>来表示
29 Class文件结构中常量池的11种数据类型
	CONSTANT_Utf8_info:              tag u1 1,length u2 UTF-8的字符串长度，bytes u1 长度为lenght的UTF-8编码的字符串
	CONSTANT_Integer_info:           tag u1 3,bytes u4 按照高位在前的存储的int值
	CONSTANT_Float_info:             tag u1 4,bytes u4 按照高位在前的存储的int值
	CONSTANT_Long_info:              tag u1 5,bytes u8 按照高位在前的存储的long值
	CONSTANT_Double_info:            tag u1 6,bytes u8 按照高位在前的存储的double值
	CONSTANT_Class_info:             tag u1 7,bytes u2 指向全限定名常量项的索引
	CONSTANT_String_info:            tag u1 8,bytes u2 指向字符串字面量的索引
	CONSTANT_Field_ref_info:         tag u1 9,index u2 指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项,index u2 指向字段描述符CONSTANT_NameAndType_info的索引项
	CONSTANT_Methodref_info:         tag u1 10,index u2 指向声明方法的类描述符CONSTANT_Class_info的所印象,index u2 指向名称及类型描述符CONSTANT_NameAndType_info的索引项
	CONSTANT_InterfaceMethodref_info:tag u1 11,index u2 指向声明方法的接口描述符CONSTANT_Class_info的所印象,index u2 指向名称及类型描述符CONSTANT_NameAndType_info的索引项
	CONSTANT_NameAndType_info:       tag u1 12,index u2 指向该字段或方法名称常量项的索引，index u2 指向该字段或方法描述符常量项的索引

30、常量池字节码分析
                                           58个常量    #1 10号类型常量    #2 9号类型常量
	00000000  ca fe ba be 00 00 00 34  [00 3a]    [0a 00 0c 00 20]   [09  |.......4.:.... .|
			       #3 9号类型常量     #4 7号常量  #5 10号类型常量
	00000010  00 06 00 21] [09 00 22 00  23] [07 00 24]  [0a 00 04 00  |...!..".#..$....|
		       #6 7号类型常量	#7 10号类型常量	   #8 10号类型常量  #9 8号类型常量	
	00000020  20] [07 00 25]       [0a 00 26 00  27]  [0a 00 04 00 28] [08 00  | ..%..&.'....(..|
			#10 10号类型常量  #11 10号类型常量  #12 7号常量	 #13 1号常量	
	00000030  29] [0a 00 04 00 2a]   [0a 00  2b 00 2c] [07 00 2d]  [01 00  |)....*..+.,..-..|
			  #14 1号常量		#15 1号常量
	00000040  01 61] [01 00 01 49] [01 00  06 3c 69 6e 69 74 3e] 01  |.a...I...<init>.|
	00000050  00 03 28 29 56 01 00 04  43 6f 64 65 01 00 0f 4c  |..()V...Code...L|
	
        ....

        00000250  74 72 65 61 6d 01 00 07  70 72 69 6e 74 6c 6e 01  |tream...println.|
        00000260  00 15 28 4c 6a 61 76 61  2f 6c 61 6e 67 2f 53 74  |..(Ljava/lang/St|
        		   g    ; )  V  									
	00000270  72 69 6e 67 3b 29 56] (常量池所有常量)   00  21 00 06 00 0c 00 00 00  |ring;)V.!.......|

	从第9个字节开始 00 3a ，代表58个常量(除去null的0号常量，实际上是57个常量)
	#1 :第11个字节是第一个常量的类型 ：0a 即10号类型,及后面有两项内容都是u2类型（每项占两个字节）
		12 13字节 00 0c ，12
        	14 15字节 00 20 ，32
	    对应的Constant pool 第一个常量 #1 = Methodref          #12.#32
	    12 32这两个索引具体内容实际上在后面
	#2 :从第16个字节开始 ，09 00 06 00 21 ，9号类型常量，
		00 06 ： 6号索引
		00 21 ： 33号索引
	    对应的Constant pool 第二个常量 #2 = Fieldref           #6.#33  
	#3 :09 00 22 00 23 , 9号类型常量
		00 22：34
		00 23：35
	    对应的Constant pool 第三个常量 #3 = Fieldref           #34.#35 
	#4 : 07 00 24 7号常量 
		00 24 :36
	    对应的Constant pool 第四个常量 #4 = Class              #36
  	
	#5 : 0a 00 04 00 20 ,10号类型常量
	     00 04 ： 4
	     00 20 ： 32
	     对应的Constant pool 第5个常量 #5 = Methodref          #4.#32
	#6 ：07 00 25 7号类型常量
	     00 25 ： 37
	     对应的Constant pool 第6个常量  #6 = Class              #37
	#7 ：0a 00 26 00  27 10号类型常量
	     #7 = Methodref          #38.#39 
	#8 ：0a 00 04 00 28 10号类型常量
	     Methodref          #4.#40 
	#9 ：08 00 29 8号类型常量
             String             #41  
        #10：0a 00 04 00 2a 10号类型常量
	     #10 = Methodref          #4.#42 
	#11: 0a 00  2b 00 2c 10号类型常量
	     #11 = Methodref          #43.#44
        #12: 07 00 2d	7号类型常量
	     #12 = Class              #45  
	#13: 01 00 01 61 1号类型常量
	     00 01 ：字符串长度 1
	     61 : 字符16位ascII码  a
             #13 = Utf8               a
        #14: 01 00 01 49 1号类型常量
	     00 01 ：字符串长度 1
	     49 : 字符16位ascII码  I  		 	
	     #14 = Utf8               I
	#15  01 00  06 3c 69 6e 69 74 3e 1号类型常量
	     00  06 ：字符串长度 6
	     3c 69 6e 69 74 3e ：<init>
	     #15 = Utf8               <init>
	..... 		 		     
        			
	    	
31、Access Flags 访问标志符 u2
	-访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明成final。 	
	 ACC_PUBLIC        0X0001  public类型
	 ACC_PRIVATE       0X0002  private类型
	 ACC_FINAL         0X0010  final 类型
	 ACC_PUBLIC_STATIC 0X0009  public static 类型
	 ACC_SUPER         0X0020  子类调用父类的方法
	 ACC_INTERFACE     0X0200  接口类
	 ACC_ABSTRACT      0X0400  抽象类
	 ACC_SYNTHETIC     0X1000  不在源代码中
	 ACC_ANNOTATION    0X2000  注解
	 ACC_ENUM          0X4000  枚举
	
	               常量池常量列表结束
	- 00000270  72 69 6e 67 3b 29 56]   00  21 00 06 00 0c 00 00 00  |ring;)V.!.......|
        	
	-访问标志符接在常量池后面两个字节 ：00 21 
	 实际上是 0x0001 和 0x0020的并集，表示 ACC_PUBLIC和ACC_SUPER

32、This Class Name 当前类名 u2
                     常量池常量列表结束	     Access Flags  This class name
	- 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]         00 0c 00 00 00  |ring;)V.!.......|
	
	00 06 : 对应常量池6号索引  #6 = Class              #37            // com/sandro/bytecode/Test1

32、Super Class Name 当前类的父类 u2

                      常量池常量列表结束      Access Flags  This class name   super class name
         - 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]           [00 0c]          00 00 00  |ring;)V.!.......|
         
         00 0c : 对应常量池12号索引  #12 = Class              #45            // java/lang/Object

33、interfaces 接口列表 2 + n个字节
                       常量池常量列表结束      Access Flags  This class name  super class name        接口数量
          - 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]           [00 0c]                 [00 00] 00  |ring;)V.!.......|
	   数量：00 00 ，此时接口数量是0，所以接口列表就没有内容了直接连接下一个数据

34、Fields 2 + n个字节
	-字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量(静态变量)以及实例变量(成员变量)，但是不包括方法内部声明的局部变量 
                        常量池常量列表结束      Access Flags  This class name  super class name        接口数量 属性的数量
        - 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]           [00 0c]                 [00 00] [00             |ring;)V.!.......|	
	                 属性列表  
	  00000280  01] [00 02 00 0d 00 0e 00 00] 00 04 00 01 00 0f 00  |................|
          字段数量00 01 ，说名只有一个
	  	
	-字段表数据结构
	 access_flags u2， 访问符号 
         name_index u2 ，名字索引
         descriptor_index u2 ，描述索引
	 attributes_count u2 ，字段附加信息长度，如果是0，则后面的atribute_info就没有了
         attribute_info ，附加信息内容，长度为 attributes_count
	
	- 00 02 00 0d 00 0e 00
	  0002 access_flags为private
	  000d name_index,对应 #13 = Utf8               a
	  000e 描述索引,对应   #14 = Utf8               I
	  0000 附加信息长度 0，代表没有附加信息
	  因此当前字段就是一个名字为a 的 private的整形变量

35、Methods 方法表 2+n个字节
			属性列表                 方法数量  第一个方法
	00000280  01] [00 02 00 0d 00 0e 00 00] [00 04]   [00 01 00 0f 00  |................|
				 attribute_length = 56  attribute结构体字节码		
        00000290  10 00 01 00 11 (00 00 00 38)         (00 02 00 01 00 00 00  |........8.......|
        000002a0  0a 2a b7 00 01 2a 04 b5  00 02 b1 00 00 00 02 00  |.*...*..........|
        000002b0  12 00 00 00 0a 00 02 00  00 00 03 00 04 00 04 00  |................|
        000002c0  13 00 00 00 0c 00 01 00  00 00 0a 00 14 00 15 00  |................|
        000002d0  00)] 00 01 00 16 00 17 00  01 00 11 00 00 00 3e 00  |..............>.|

        - 0x0004 = 4 ： 方法的数量是4个
	-方法表数据结构
	 {
	 	access_flags u2， 访问符号 
         	name_index u2 ，名字索引
         	descriptor_index u2 ，描述索引
         	attributes_count u2 ，字段附加信息长度，如果是0，则后面的atribute_info就没有了
	 	attribute_info ，附加信息数据表 表长是 attribute_count
	
	 attribute_info数据体结构
	 {
	  	attribute_name_index u2
          	attribute_length u4
          	info[attribute_length] u1 长度为attribute_length的1个字节为单位的数组保存
 	 }
	
	 code的结构：当attribute_name_index 在常量池中指向的是code的时候需要用code结构体分析数据
	 {
		attribute_name_index u2
		attribute_length u4 ，表示attribute所包含的字节数，不包含attribute_name_index和 attribute_length字段
		max_stack u2，表示这个方法运行的任何时刻所能达到的操作数栈的最大深度 
	 	max_locals u2 表示方法执行期间粗昂见的局部变量的数目，包含用来表示传入的参数的局部变量
	        code_length u4 表示该方法所包含的字节码的字节数以及具体的指令码
		code[code_length],单位是1个字节 , 具体字节码即是该方法被调用时虚拟机执行的自己码
		exception_table_length u2
		exception_table[exception_table_length]
		exception_table 元数据结构体{
			//这里存放的是处理异常的信息
			//每个exception_table表由start_pc,end_pc,handler_pc,catch_type组成
			//start_pc和end_pc表示在code数组中的从start_pc到end_pc处(包含start_pc,不包含end_pc)的指令抛出的异常会由这个表项来处理
		        //handler_pc表示会被处理的异常类型，它指向常量池里的一个异常类。当catch_type为0时，表示处理所有的异常
			start_pc u2
			end_pc u2
			handler_pc u2
			catch_type u2
		}
		attributes_count u2,code属性长度
		attribute_info[attributes_count]，code属性信息
		{
			
		}
	 }

	-第一个方法
	 00 01 00 0f 00 10 00 01 00 11 00 00 00 38...后面56个字节
	 00 01 ，access_flags=ACC_PUBLIC
	 00 0f , name_index = 15
		 #15 = Utf8               <init>,构造方法
		 构造方法统一都使用 <init>助记符
	         默认的无参数构造方法，如果自己实现了无参数的构造方法，生成的字节码也是这样的，在默认的构造方法中会将成员变量赋值
		 多个构造方法，就会有多个 <init> 方法体
		 如果自己实现了一个有参数的构造方法，实际上在有参数的构造方法中也会给每个成员变量赋值
		 大部分类的字节码都会有<init>,但不是所有的类，比如接口，就没有<init> , 另外jvm和java语言是两套规范二者不能混为一谈，比如kotlin的kt文件都是静态的也没有<init>，但是依然可以被jvm执行

	 00 10 , descriptor_index = 16
	         #16 = Utf8               ()V
	 00 01 , attributes_count = 1 说明有一个attribute数据
	 00 11 , attribute_info[1].attribute_name_index = 17
	         #17 = Utf8               Code 
		 code代表执行代码，用助记符的方式描述方法体
	 00 00 00 38,attribute_info[1].attribute_length = 56 

	 code : 因为.attribute_name_index指向常量池中的常量是code,所以需要用code结构体来分析 info[56]这部分数据
		code是每个方法最重要的属性，这个属性几乎总是存在的
	        00 02 00 01 00 00 00 0a  2a b7 00 01 2a 04 b5 00 
		02 b1 00 00 00 02 00 12  00 00 00 0a 00 02 00 00 
		00 03 00 04 00 04 00 13  00 00 00 0c 00 01 00 00 
		00 0a 00 14 00 15 00 00  	 
          {      
                 max_stack u2，00 02->2
                 max_locals u2 , 00 01 ->1
                 code_length u4,00 00 00 0a ->10
                 code[code_length],单位是1个字节，2a b7 00 01 2a 04 b5 00 02 b1
				   通过查表可以将16进制和具体的助记符关联起来
				   官网地址：https://docs.oracle.com/javase/specs/jvms/se19/html/index.html（Chapter 6. The Java Virtual Machine Instruction Set ）
				   -2a,aload_0, 将索引为0的元素推送到操作栈的栈顶，准备调用 
				   -b7 [00 01],  invokespecial 1 -> #1 = Methodref          #12.#32        // java/lang/Object."<init>":()V
						这里是调用了父类的构造方法
				   -2a, aload_0
				   -04, iconst_1 ，推送整形1到栈顶，从这里看到非静态全局变量实际上是在默认的构造方法中赋值的
				   -b5 [00 02] ,putfield 2 -> #2 = Fieldref           #6.#33         // com/sandro/bytecode/Test1.a:I
						给成员变量赋值（此时要赋的值已经在上一行放到栈顶了）
			           -b1 ,return		
                 exception_table_length u2，00 00 = 0
                 exception_table[exception_table_length]，此时为空
                 attributes_count u2,00 02 = 2，
                 attribute_info[0]：00 12 [00 00 00 0a 00 02 00 00 00 03 00 04 00 04] 00 13  00 00 00 0c 00 01 00 00 00 0a 00 14 00 15 00 00
		 { 
			00 12(18)：第一个属性索引#18 = Utf8               LineNumberTable
			LineNumberTable：行号和字节码的对应关系，方便代码和执行位值关联，用于定位代码使用
			LineNumberTable struct{
				length u4 ,00 00 00 0a 长度为10个字节
					   00 02 00 00 00 03 00 04 00 04
				liner_number_table_length u2 00 02->2
				line_number_table{	
					start_pc u2
					line_number u2
				}->table[0].start_pc = 0000 table[0].line_number=0003 //这里怀疑是因为代码中注释的原因导致行号没有对齐，javap中看 liner_number是208和210
				   table[1].start_pc = 0004 table[1].line_nmuber=0004
			}
          	}
		attribute_info[1]：00 13 00 00 00 0c 00 01 00 00 00 0a 00 14 00 15 00 00
		{
			00 13(19): 第二个属性索引 #19 = Utf8               LocalVariableTable
			LocalVariableTable 局部变量表，
					   在java当中每一个非静态方法中都有一个this的，在字节码中这个this就是通过第一个局部变量隐式的传递进来的
			{
				length u4, 00 00 0c = 12 ,说明后面12个字节都是LocalVariableTable的数据
					   00 01 00 00 00 0a 00 14 00 15 00 00
				count u2, 00 01 =1  ，局部变量的个数是1个
				start u2, 00 00 = 0 起始位值是0
				length u2,00 0a = 10 长度是10
				name_index u2 ,0x0014 = 20 ->  #20 = Utf8               this
					       		
 				desc_index u2 ,0x0015 = 21 ->  #21 = Utf8               Lcom/sandro/bytecode/Test1;
				校验检查位 u2,0x0000 = 0
			}
		}
			 
	}
	
	-第2个方法：	      第二个方法开始
				public   index=22 setA   (I)V    1个attri    code结构    len=62       code_data
	         000002d0  00 [(00 01)  (00 16)        (00 17)  (00 01)     (00 11)   （00 00 00 3e）(00  
                 000002e0  02 00 02 00 00 00 06 2a  1b b5 00 02 b1 00 00 00  
                 000002f0  02 00 12 00 00 00 0a 00  02 00 00 00 07 00 05 00 
                 00000300  08 00 13 00 00 00 16 00  02 00 00 00 06 00 14 00  
                 00000310  15 00 00 00 00 00 06 00  0d 00 0e 00 01)] 00 01 00 

	-第3个方法：                                                public   index=34 getA		 
		 00000310  15 00 00 00 00 00 06 00  0d 00 0e 00 01 [(00 01  (00 
				()I     1个 attri  code结构     len=47        code_data
                 00000320  18) (00 19) (00 01)   (00 11)     （00 00 00 2f）(00 01 00 01 00  
                 00000330  00 00 05 2a b4 00 02 ac  00 00 00 02 00 12 00 00  
                 00000340  00 06 00 01 00 00 00 0b  00 13 00 00 00 0c 00 01  
                 00000350  00 00 00 05 00 14 00 15  00 00)] 00 09 00 1a 00 1b  
                 00000360  00 01 00 11 00 00 00 4c  00 03 00 01 00 00 00 1e  

	-第4个方法
		                                            public static index=26 main  ([Ljava/lang/String;)V
                 00000350  00 00 00 05 00 14 00 15  00 00 [(00 09)        (00 1a)        (00 1b)
			    1个attri  code结构	  len=76	code_data	
                 00000360  (00 01)   (00 11)   （00 00 00 4c） (00 03 00 01 00 00 00 1e 
                 00000370  b2 00 03 bb 00 04 59 b7  00 05 12 06 b6 00 07 b6  
                 00000380  00 08 12 09 b6 00 08 b6  00 0a b6 00 0b b1 00 00  
                 00000390  00 02 00 12 00 00 00 0a  00 02 00 00 00 0f 00 1d  
                 000003a0  00 10 00 13 00 00 00 0c  00 01 00 00 00 1e 00 1c  
                 000003b0  00 1d 00 00)] 00 01 00 1e  00 00 00 02 00 1f        

	
35、字节码文件的attribute
	class文件自己的一些属性信息
	000003b0  00 1d 00 00 [00 01 00 1e  00 00 00 02 00 1f]
	
	count u2 ,0x0001=1 ,只有一个属性信息
	index u2,0x001e = 30  #30 = Utf8               SourceFile
	len u4 ,0x00000002 = 2,长度只占据两个字节
	socefile_index u2, 0x001f=31  #31 = Utf8               Test1.java

36、案例2字节码
	project/jvm_lecture项目 com.sandro.bytecode.Test2
	字节码如下：
	
	java文件魔数  minor_version = 0  major_version=52即jdk1.8  58个常量  [常量池开始
        [ca fe ba be] [00 00]           [00 34]                   [00 30]   [0a 00 0a 00 23 08 
        00 24 09 00 05 00 25 09  00 05 00 26 07 00 27 0a 
        00 05 00 23 0a 00 05 00  28 0a 00 29 00 2a 09 00 
        05 00 2b 07 00 2c 01 00  03 73 74 72 01 00 12 4c 
        6a 61 76 61 2f 6c 61 6e  67 2f 53 74 72 69 6e 67 
        3b 01 00 04 78 4e 75 6d  01 00 01 49 01 00 05 69 
        6e 4e 75 6d 01 00 13 4c  6a 61 76 61 2f 6c 61 6e 
        67 2f 49 6e 74 65 67 65  72 3b 01 00 06 3c 69 6e 
        69 74 3e 01 00 03 28 29  56 01 00 04 43 6f 64 65 
        01 00 0f 4c 69 6e 65 4e  75 6d 62 65 72 54 61 62 
        6c 65 01 00 12 4c 6f 63  61 6c 56 61 72 69 61 62 
        6c 65 54 61 62 6c 65 01  00 04 74 68 69 73 01 00 
        1b 4c 63 6f 6d 2f 73 61  6e 64 72 6f 2f 62 79 74 
        65 63 6f 64 65 2f 54 65  73 74 32 3b 01 00 04 6d 
        61 69 6e 01 00 16 28 5b  4c 6a 61 76 61 2f 6c 61 
        6e 67 2f 53 74 72 69 6e  67 3b 29 56 01 00 04 61 
        72 67 73 01 00 13 5b 4c  6a 61 76 61 2f 6c 61 6e 
        67 2f 53 74 72 69 6e 67  3b 01 00 05 74 65 73 74 
        32 01 00 07 73 65 74 78  4e 75 6d 01 00 04 28 49 
        29 56 01 00 01 78 01 00  08 3c 63 6c 69 6e 69 74 
        3e 01 00 0a 53 6f 75 72  63 65 46 69 6c 65 01 00 
        0a 54 65 73 74 32 2e 6a  61 76 61 0c 00 11 00 12 
        01 00 07 57 65 6c 63 6f  6d 65 0c 00 0b 00 0c 0c 
        00 0d 00 0e 01 00 19 63  6f 6d 2f 73 61 6e 64 72 
        6f 2f 62 79 74 65 63 6f  64 65 2f 54 65 73 74 32 
        0c 00 1d 00 1e 07 00 2d  0c 00 2e 00 2f 0c 00 0f 
        00 10 01 00 10 6a 61 76  61 2f 6c 61 6e 67 2f 4f 
        62 6a 65 63 74 01 00 11  6a 61 76 61 2f 6c 61 6e 
        67 2f 49 6e 74 65 67 65  72 01 00 07 76 61 6c 75 
        65 4f 66 01 00 16 28 49  29 4c 6a 61 76 61 2f 6c
                                  常量池结束]  ACC_PUBLIC，ACC_SUPER  this classname=#5 -> Class              #39            // com/sandro/bytecode/Test2
        61 6e 67 2f 49 6e 74 65  67 65 72 3b] [00 21]                [00 05] 
	super classname = #10->java/lang/Object  接口数量=0   Fields数量=3 [fields开始
        [00 0a]                                  [00 00]      [00 03]      [00 00  00 0b 00 0c 00 00 00 02 
                                        fields结束] 方法数量=4
        00 0d 00 0e 00 00 00 09  00 0f 00 10 00 00] [00 04] 
	[方法区开始 
	 (方法1开始
        [(00 01 00 11 00 12 00 01  00 13 00 00 00 42 00 02 
        00 01 00 00 00 10 2a b7  00 01 2a 12 02 b5 00 03 
        2a 08 b5 00 04 b1 00 00  00 02 00 14 00 00 00 0e 
        00 03 00 00 00 03 00 04  00 04 00 0a 00 06 00 15 
						方法1结束
        00 00 00 0c 00 01 00 00  00 10 00 16 00 17 00 00)
	(方法2开始 
        (00 09 00 18 00 19 00 01  00 13 00 00 00 57 00 02 
        00 02 00 00 00 17 bb 00  05 59 b7 00 06 4c 2b 10 
        08 b6 00 07 10 14 b8 00  08 b3 00 09 b1 00 00 00 
        02 00 14 00 00 00 12 00  04 00 00 00 0b 00 08 00 
        0c 00 0e 00 0d 00 16 00  0e 00 15 00 00 00 16 00 
        02 00 00 00 17 00 1a 00  1b 00 00 00 08 00 0f 00 
        方法2结束	(方法3开始
	1c 00 17 00 01) (00 01 00  1d 00 1e 00 01 00 13 00 
        00 00 3e 00 02 00 02 00  00 00 06 2a 1b b5 00 04 
        b1 00 00 00 02 00 14 00  00 00 0a 00 02 00 00 00 
        11 00 05 00 12 00 15 00  00 00 16 00 02 00 00 00 
        06 00 16 00 17 00 00 00  00 00 06 00 1f 00 0e 00 
 方法3结束) (方法4开始	
        01) (00 08 00 20 00 12 00  01 00 13 00 00 00 21 00 
        01 00 00 00 00 00 09 10  0a b8 00 08 b3 00 09 b1 
					       方法区结束]
					       方法4结束)
        00 00 00 01 00 14 00 00  00 06 00 01 00 00 00 08)] 
        00 01 00 21 00 00 00 02  00 22                   

	常量池：
	0a 00 0a 00 23            #1 = Methodref          #10.#35        // java/lang/Object."<init>":()V
	08 00 24                  #2 = String             #36            // Welcome
	09 00 05 00 25            #3 = Fieldref           #5.#37         // com/sandro/bytecode/Test2.str:Ljava/lang/String;
	09 00 05 00 26            #4 = Fieldref           #5.#38         // com/sandro/bytecode/Test2.xNum:I
	07 00 27                  #5 = Class              #39            // com/sandro/bytecode/Test2 
	0a 00 05 00 23            #6 = Methodref          #5.#35         // com/sandro/bytecode/Test2."<init>":()V
	0a 00 05 00 28            #7 = Methodref          #5.#40         // com/sandro/bytecode/Test2.setxNum:(I)V
	0a 00 29 00 2a            #8 = Methodref          #41.#42        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
	09 00 05 00 2b            #9 = Fieldref           #5.#43         // com/sandro/bytecode/Test2.inNum:Ljava/lang/Integer;
	07 00 2c                  #10 = Class              #44            // java/lang/Object
	01 00 03 73 74 72         #11 = Utf8               str 
	01 00 12 4c 6a 61 76 61 2f 6c 61 6e  67 2f 53 74 72 69 6e 67 3b 
			          #12 = Utf8               Ljava/lang/String;
	01 00 04 78 4e 75 6d      #13 = Utf8               xNum
	01 00 01 49               #14 = Utf8               I 
	01 00 05 69 6e 4e 75 6d 
			          #15 = Utf8               inNum
	01 00 13 4c 6a 61 76 61 2f 6c 61 6e 67 2f 49 6e 74 65 67 65 72 3b 
			          #16 = Utf8               Ljava/lang/Integer;	
	01 00 06 3c 69 6e 69 74 3e 
			          #17 = Utf8               <init>
	01 00 03 28 29  56        #18 = Utf8               ()V
	01 00 04 43 6f 64 65      #19 = Utf8               Code
        01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 
			          #20 = Utf8               LineNumberTable
        01 00 12 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 
				  #21 = Utf8               LocalVariableTable
	01 00 04 74 68 69 73 
				  #22 = Utf8               this
	01 00 1b 4c 63 6f 6d 2f 73 61 6e 64 72 6f 2f 62 79 74 65 63 6f 64 65 2f 54 65 73 74 32 3b 
				  #23 = Utf8               Lcom/sandro/bytecode/Test2;
	01 00 04 6d 61 69 6e      #24 = Utf8               main
	01 00 16 28 5b  4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 
				  #25 = Utf8               ([Ljava/lang/String;)V	
	01 00 04 61 72 67 73      #26 = Utf8               args
	01 00 13 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 
				  #27 = Utf8               [Ljava/lang/String;  
	01 00 05 74 65 73 74 32 
				  #28 = Utf8               test2
	01 00 07 73 65 74 78  4e 75 6d 
                                  #29 = Utf8               setxNum
	01 00 04 28 49 29 56      #30 = Utf8               (I)V
	01 00 01 78               #31 = Utf8               x
	01 00 08 3c 63 6c 69 6e 69 74 3e 
				  #32 = Utf8               <clinit>
	01 00 0a 53 6f 75 72 63 65 46 69 6c 65
                                  #33 = Utf8               SourceFile 
	01 00 0a 54 65 73 74 32 2e 6a 61 76 61 
				  #34 = Utf8               Test2.java
	0c 00 11 00 12            #35 = NameAndType        #17:#18        // "<init>":()V
        01 00 07 57 65 6c 63 6f 6d 65 
				  #36 = Utf8               Welcome 
	0c 00 0b 00 0c            #37 = NameAndType        #11:#12        // str:Ljava/lang/String;
	0c 00 0d 00 0e            #38 = NameAndType        #13:#14        // xNum:I 
	01 00 19 63 6f 6d 2f 73 61 6e 64 72 6f 2f 62 79 74 65 63 6f 64 65 2f 54 65 73 74 32
				  #39 = Utf8               com/sandro/bytecode/Test2 
	0c 00 1d 00 1e            #40 = NameAndType        #29:#30        // setxNum:(I)V
	07 00 2d                  #41 = Class              #45            // java/lang/Integer 
	0c 00 2e 00 2f            #42 = NameAndType        #46:#47        // valueOf:(I)Ljava/lang/Integer; 
	0c 00 0f 00 10            #43 = NameAndType        #15:#16        // inNum:Ljava/lang/Integer;
	01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 
				  #44 = Utf8               java/lang/Object	
        01 00 11 6a 61 76 61 2f 6c 61 6e 67 2f 49 6e 74 65 67 65 72
				  #45 = Utf8               java/lang/Integer 
	01 00 07 76 61 6c 75 65 4f 66     
				  #46 = Utf8               valueOf
 	01 00 16 28 49 29 4c 6a 61 76 61 2f 6c 61 6e 67 2f 49 6e 74 65 67 65 72 3b 
				  #47 = Utf8               (I)Ljava/lang/Integer;	

	Fields: 
	00 09 00 0f 00 10 00 00 
	
	00 01 00 11 00 12 00 01  00 13 00 00 00 42 00 02
	fields[0] = 00 00 00 0b 00 0c 00 00 
	fields[0].access_flags = 0x0000(),0就代表没有，也可以理解为protected
	fields[0].name_index = 0x000b , #11 = Utf8               str
	fields[0].descriptor_index = 0x000c ,  #12 = Utf8               Ljava/lang/String;
	fields[0].attributes_count = 0x0000
	
        fields[1] = 00 02 00 0d 00 0e 00 00 
        fields[1].access_flags = 0x0002, private
        fields[1].name_index = 0x000d , 0x000e ,  #13 = Utf8               xNum
        fields[1].descriptor_index = 0x000e ,  #14 = Utf8               I
        fields[1].attributes_count = 0x0000 

        fields[2] = 00 09 00 0f 00 10 00 00  
        fields[2].access_flags = 0x0009, public static
        fields[2].name_index = 0x000f , 0x000e ,  #15 = Utf8               inNum
        fields[2].descriptor_index = 0x0010 ,  #16 = Utf8               Ljava/lang/Integer;
        fields[2].attributes_count = 0x0000

	
	方法：
	methods[0].access_flags = 0x0001 public  
	methods[0].name_index = 0x0011 , #17 = Utf8               <init>
	methods[0].descriptor_index = 0x0012 , #18 = Utf8               ()V 
	methods[0].attributes_count = 0x0001
	methods[0].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
 	methods[0].attribute_info[0].info_length = 0x00000042 ,66字节长度 
	methods[0].attribute_info[0].code = {
		max_stack = 0x0002,2
		max_locals = 0x0001,1
		code_length = 0x00000010,
		code_data = 2a b7 00 01 2a 12 02 b5 00 03 2a 08 b5 00 04 b1
		code:
			2a:aload_0
			b7 [00 01]: invokespecial #1=Methodref  #10.#35  // java/lang/Object."<init>":()V
			2a:aload_0
			12 [02]:ldc #2=String  #36 // Welcome
    			b5 [00 03] : putfield #3 Fieldref #5.#37 // com/sandro/bytecode/Test2.str:Ljava/lang/String;
			2a:aload_0
			08:iconst_5
			b5 [00 04] : putfield #4 Fieldref #5.#38   // com/sandro/bytecode/Test2.xNum:I
			b1:return
		exception_table_length= 0x0000
		attributes_count = 0x0002
		attribute_info[0] = {
			attribute_index=0x0014,#20 = Utf8 LineNumberTable
			LineNumberTable{
				length=0x0000000e
				tableinfo=00 03 00 00 00 03 00 04  00 04 00 0a 00 06
				table_count=0x0003
				table[0].start_pc=0x0000
				table[0].line_number=0x0003
                                table[1].start_pc=0x0004
                                table[1].line_number=0x0004
                                table[2].start_pc=0x000a
                                table[2].line_number=0x0006
			}		
		} 
                attribute_info[1] = {
                        attribute_index=0x0015,#21 = Utf8 LocalVariableTable
                        LocalVariableTable{
                                length=0x0000000c
                                tableinfo=00 01 00 00 00 10 00 16 00 17 00 00
                                count = 0x0001
				start = 0x0000
				length = 0x0010
		 		name_index = 0x0016, #22 = Utf8 this
				desc_index = 0x0017, #23 = Utf8 Lcom/sandro/bytecode/Test2;
				校验检查位 = 0x0000
                        }
                }
	
	}		

        methods[1].access_flags = 0x0009 public static
        methods[1].name_index = 0x0018 , #24 = Utf8  main
        methods[1].descriptor_index = 0x0019 , #25 = Utf8 ([Ljava/lang/String;)V
        methods[1].attributes_count = 0x0001
        methods[1].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
        methods[1].attribute_info[0].info_length = 0x00000057 ,87字节长度
        methods[1].attribute_info[0].code = {
                max_stack = 0x0002,2
                max_locals = 0x0002,2
                code_length = 0x00000017,
                code_data {
			bb [00 05]: new #5 = Class #39  // com/sandro/bytecode/Test2 
			59: dup
			b7 [00 06]:invokespecial #6 = Methodref #5.#35   // com/sandro/bytecode/Test2."<init>":()V
			4c:astore_1 
			2b:aload_1 
			10 [08] bipush 8 
			b6 [00 07] invokevirtual invokespecial #7 = Methodref #5.#40 // com/sandro/bytecode/Test2.setxNum:(I)V	
			10 [14] bigpush 20 
			b8 [00 08] invokestatic #8 = Methodref  #41.#42    // java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 
			b3 [00 09] pubstatic #9 = Fieldref      #5.#43     // com/sandro/bytecode/Test2.inNum:Ljava/lang/Integer; 
			b1 return
			
                exception_table_length= 0x0000
                attributes_count = 0x0002
                attribute_info[0] = {
                        attribute_index=0x0014,#20 = Utf8 LineNumberTable
                        LineNumberTable{
                                length=0x00000012
                                tableinfo=00 04 00 00 00 0b 00 08 00 0c 00 0e 00 0d 00 16 00  0e
                                table_count=0x0004 
                                table[0].start_pc=0x0000
                                table[0].line_number=0x000b
                                table[1].start_pc=0x0008
                                table[1].line_number=0x000c
                                table[2].start_pc=0x000e
                                table[2].line_number=0x000d
				table[3].start_pc=0x0016
				table[3].line_number=0x000e
                        }               
                }
                attribute_info[1] = {
                        attribute_index=0x0015,#21 = Utf8 LocalVariableTable
                        LocalVariableTable{
                                length=0x00000016
                                tableinfo=00 02 00 00 00 17 00 1a 00 1b 00 00     00 08 00 0f 00 1c 00 17 00 01
                                count = 0x0002
				table[0] = {
                                	start = 0x0000
                                	length = 0x0017
                                	name_index = 0x001a, #26 = Utf8 args
                                	desc_index = 0x001b, #27 = Utf8 [Ljava/lang/String;
                                	校验检查位 = 0x0000
				}
                                table[1] = {
                                        start = 0x0008
                                        length = 0x000f
                                        name_index = 0x001c, #28 = Utf8  test2
                                        desc_index = 0x0017, #23 = Utf8  Lcom/sandro/bytecode/Test2;
                                        校验检查位 = 0x0001
                                }

                        }
                }

        } 
        methods[2].access_flags = 0x0001 public
        methods[2].name_index = 0x001d , #29 = Utf8 setxNum
        methods[2].descriptor_index = 0x001e , #30 = Utf8 (I)V
        methods[2].attributes_count = 0x0001
        methods[2].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
        methods[2].attribute_info[0].info_length = 0x0000003e ,62字节长度
        methods[2].attribute_info[0].code = {
                max_stack = 0x0002,2
                max_locals = 0x0002,2
                code_length = 0x00000006,
                code_data {
			2a : aload_0 
			1b : iload_1 
			b5 [00 04] : putfield #4 = Fieldref #5.#38 // com/sandro/bytecode/Test2.xNum:I
			b1 : return
			
                exception_table_length= 0x0000
                attributes_count = 0x0002
                attribute_info[0] = {
                        attribute_index=0x0014,#20 = Utf8 LineNumberTable
                        LineNumberTable{
                                length=0x0000000a
                                tableinfo=00 02 00 00 00 11 00 05 00 12
                                table_count=0x0002
                                table[0].start_pc=0x0000
                                table[0].line_number=0x0011
                                table[1].start_pc=0x0005
                                table[1].line_number=0x0012
                        }               
                }
                attribute_info[1] = {
                        attribute_index=0x0015,#21 = Utf8 LocalVariableTable
                        LocalVariableTable{
                                length=0x00000016
                                tableinfo= 00 02    00 00 00 06 00 16 00 17 00 00     00  00 00 06 00 1f 00 0e 00 01
                                count = 0x0002
				table[0] = {
                                	start = 0x0000
                                	length = 0x0006
                                	name_index = 0x0016, #22 = Utf8 this
                                	desc_index = 0x0017, #23 = Utf8 Lcom/sandro/bytecode/Test2;
                                	校验检查位 = 0x0000
				}
                                table[1] = {
                                        start = 0x0000
                                        length = 0x0006
                                        name_index = 0x001f, #31 = Utf8 x
                                        desc_index = 0x000e, #14 = Utf8 I
                                        校验检查位 = 0x0001
                                }

                        }
                }

        }
        methods[3].access_flags = 0x0008 static代码块
        methods[3].name_index = 0x0020 , #32 = Utf8 <clinit> ，
			        在这个代码块中对静态变量进行赋值
				如果有多个static代码块，和多个静态变量，字节码实际上会统一合并到一起，放到<clinit>这个方法中去按照代码顺序执行
        methods[3].descriptor_index = 0x0012 , #18 = Utf8 ()V
        methods[3].attributes_count = 0x0001
        methods[3].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
        methods[3].attribute_info[0].info_length = 0x00000021 ,33字节长度
        methods[3].attribute_info[0].code = {
                max_stack = 0x0001,1
                max_locals = 0x0000,01
                code_length = 0x00000009,
                code_data {
			10 [0a]:bigbush 10 
			b8 [00 08] invokestatic  #8=Methodref  #41.#42 // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
			b3 [00 09] putstatatic  #9=Fieldref    #5.#43  // com/sandro/bytecode/Test2.inNum:Ljava/lang/Integer;
			b1 : return
			
                exception_table_length= 0x0000
                attributes_count = 0x0001
                attribute_info[0] = {
                        attribute_index=0x0014,#20 = Utf8 LineNumberTable
                        LineNumberTable{
                                length=0x00000006
                                tableinfo=00 01 00 00 00 08
                                table_count=0x0001
                                table[0].start_pc=0x0000
                                table[0].line_number=0x0008
                        }               
                }
                
        }
	00 01 00 21 00 00 00 02  00 22
	class_attribute.count = 0x0001
	class_attribute.index = 0x0021, #33 = Utf8  SourceFile
	class_attribute.len = 0x000002
	sourcefile_index = 0x0022, #34 = Utf8               Test2.java


36、synchronized关键字
	project/jvm_lecture项目 com.sandro.bytecode.Test3
	
	-synchronized修饰实例方法
	 反编译后普通方法和synchronized方法：

	  private void setData();
	    descriptor: ()V
	    flags: ACC_PRIVATE
	    Code:
	      stack=0, locals=1, args_size=1
	         0: return
	      LineNumberTable:
	        line 6: 0
	      LocalVariableTable:
	        Start  Length  Slot  Name   Signature
	            0       1     0  this   Lcom/sandro/bytecode/Test3;

	  private synchronized void setData2();
	    descriptor: ()V
	    flags: ACC_PRIVATE, ACC_SYNCHRONIZED
	    Code:
	      stack=0, locals=1, args_size=1
	         0: return
	      LineNumberTable:
	        line 10: 0
	      LocalVariableTable:
	        Start  Length  Slot  Name   Signature
	            0       1     0  this   Lcom/sandro/bytecode/Test3;
	
	 这两个方法的区别就在flags上，synchronized方法会在flags上增加一个ACC_SYNCHRONIZED标志，其他都一样
	 原因是当synchronized修饰在一个实例方法上的时候，在code中其是已经隐含了使用moniterenter  和 moniterexit 即加锁和释放锁的指令了
	
	-使用syncronized修饰变量
	  private void test();
	     descriptor: ()V
	     flags: ACC_PRIVATE
	     Code:
	       stack=2, locals=3, args_size=1
	          0: aload_0
 	          1: getfield      #3                  // Field lockObj:Ljava/lang/Object;
	          4: dup
	          5: astore_1
	          6: monitorenter
	          7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
	         10: aload_0
	         11: getfield      #3                  // Field lockObj:Ljava/lang/Object;
	         14: invokevirtual #5                  // Method java/lang/Object.hashCode:()I
	         17: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
	         20: aload_1
	         21: monitorexit
	         22: goto          30
	         25: astore_2
	         26: aload_1
	         27: monitorexit
	         28: aload_2
	         29: athrow
	         30: return
	       Exception table:
	          from    to  target type
	              7    22    25   any
	             25    28    25   any
	       LineNumberTable:
	         line 14: 0
	         line 15: 7
	         line 16: 20
	         line 17: 30
	       LocalVariableTable:
	         Start  Length  Slot  Name   Signature
	             0      31     0  this   Lcom/sandro/bytecode/Test3;
	       StackMapTable: number_of_entries = 2
	         frame_type = 255 /* full_frame */
	           offset_delta = 25
	           locals = [ class com/sandro/bytecode/Test3, class java/lang/Object ]
	           stack = [ class java/lang/Throwable ]
	         frame_type = 250 /* chop */
	           offset_delta = 4
	 
	 由于是在方法内使用synchronized修饰变量 ，可以在code中看到 monitorenter 和 moniterexit 来上锁和释放锁的指令
	 从25行开始，虚拟机又增加了异常处理，保证当System.out.println出现异常后依然能够调用moniterexit保证锁的释放
	 
	-synchronized修饰静态方法
	   private static synchronized void test2();
	     descriptor: ()V
	     flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNCHRONIZED
	     Code:
	       stack=0, locals=0, args_size=0
	          0: return
	       LineNumberTable:
	         line 21: 0
	 对于静态同步方法，在code中依然没有moniterenter和moniterexit，此时上锁实际上是放在的当前类上，此时锁标记位值已经为1了，相当于隐含的使用了上锁和释放锁的操作了
	 
37、异常表的作用和this关键字在方法中的原理
	java字节码对于异常的处理方式：
		-统一采用异常表的方式对异常进行处理。
		-在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，二是采用特定的指令的方式
		-当异常处理存在finally语句块时，现代化的jvm采取的处理方式是将finally块的字节码拼接到每一个catch块后面
		 换句话说程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码
	
	project/jvm_lecture项目 com.sandro.bytecode.Test4
	反编译后test方法的code部分如下：
	  public void test();
	    descriptor: ()V
	    flags: ACC_PUBLIC
	    Code:
	      stack=3,             //java对于方法调用是基于栈的操作，这里指运行时刻，最深的栈深度是3
	      locals=4,            //局部变量是4，this,is,sc,第四个局部变量是三个catch中的一个Excetpion，因为catch中的异常只能进入一个。这里的locals是最多的局部变量数，所以是4
	      args_size=1          //对于非静态方法（实例方法）第一个参数默认会把this当作参数传递该给方法，所以args_size是1
			           //这个操作是由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问，接下来在运行期间由jvm在调用实例方法时，自动传入该this
	         0: new           #2                  // class java/io/FileInputStream
	         3: dup
	         4: ldc           #3                  // String aaa.txt
	         6: invokespecial #4                  // Method java/io/FileInputStream."<init>":(Ljava/lang/String;)V
	         9: astore_1      将实例引用存储到了一个局部变量中去
	        10: aload_1
	        11: invokevirtual #5                  // Method java/io/InputStream.close:()V
	        14: new           #6                  // class java/net/ServerSocket
	        17: dup
	        18: sipush        9999
	        21: invokespecial #7                  // Method java/net/ServerSocket."<init>":(I)V
	        24: astore_2
	        25: aload_2
	        26: invokevirtual #8                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket;
	        29: pop
	        30: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
						      // 这里因为cathch中没有代码，所以直接列出的是finally中的代码，如果有catch则会列处catch中的字节码指令
	        33: ldc           #10                 // String finally
	        35: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        38: goto          88
	        41: astore_1
	        42: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        45: ldc           #10                 // String finally
	        47: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        50: goto          88
	        53: astore_1
	        54: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        57: ldc           #10                 // String finally
	        59: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        62: goto          88
	        65: astore_1
	        66: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        69: ldc           #10                 // String finally
	        71: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        74: goto          88
	        77: astore_3
	        78: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        81: ldc           #10                 // String finally
	        83: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        86: aload_3
	        87: athrow
	        88: return
	      Exception table:
	         from    to  target type
	             0    30    41   Class java/io/FileNotFoundException//从0到29行中，如果捕获FileFoundException则转到41行处理，从41开始由于catch中没有代码实际上就执行finally了
									//41行处实际上是 FileNotFoundException ex这句话
				                                        //然后在50行处goto到了return处 
	             0    30    53   Class java/io/IOException
	             0    30    65   Class java/lang/Exception
	             0    30    77   //any ,any就是0，如果上面3个异常都没有捕获则由0号也就是any来处理异常
                                     //这部分助记符是编译器自动加上去的
	      LineNumberTable:
	        line 12: 0
	        line 13: 10
	        line 14: 14
	        line 15: 25
	        line 21: 30
	        line 22: 38
	        line 17: 41
	        line 21: 42
	        line 22: 50
	        line 18: 53
	        line 21: 54
	        line 22: 62
	        line 19: 65
	        line 21: 66
	        line 22: 74
	        line 21: 77
	        line 22: 86
	        line 23: 88
	      LocalVariableTable: //局部变量表中 由于在编译期并不知道哪个异常会被捕获，所以只列出了其他的局部变量
	        Start  Length  Slot  Name   Signature
	           10      20     1    is   Ljava/io/InputStream;
	           25       5     2    sc   Ljava/net/ServerSocket;
	            0      89     0  this   Lcom/sandro/bytecode/Test4;
	      StackMapTable: number_of_entries = 5 //1.7之后引用的校验表，对于数据类型的校验上提供了更强的性能
	        frame_type = 105 /* same_locals_1_stack_item */
	          stack = [ class java/io/FileNotFoundException ]
	        frame_type = 75 /* same_locals_1_stack_item */
	          stack = [ class java/io/IOException ]
	        frame_type = 75 /* same_locals_1_stack_item */
	          stack = [ class java/lang/Exception ]
	        frame_type = 75 /* same_locals_1_stack_item */
	          stack = [ class java/lang/Throwable ]
	        frame_type = 10 /* same */
	
38、方法声明抛出的异常声明字节码
	project/jvm_lecture项目 com.sandro.bytecode.Test5
	案例中异常是声明在方法声明中的，此时这部分信息是jvm在方法中和code并列处增加了一个异常表保存信息
            public void test() throws java.io.IOException, java.lang.ExceptionInInitializerError;
               descriptor: ()V
               flags: ACC_PUBLIC
               Code:
                 ...
                 LineNumberTable:
                   ...
                 LocalVariableTable:
                   Start  Length  Slot  Name   Signature
                   ...
               Exceptions: //
                 throws java.io.IOException, java.lang.ExceptionInInitializerError

39、栈帧(statck frame)与操作数栈 以及 符号引用与直接引用

	栈帧：
		栈帧是一种用于帮助虚拟机执行方法调用和方法执行的数据结构
		栈帧本是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。 	
	
	符号引用和直接引用：
		和c++不同，由于在编译期间相互依赖的类之间是不知道对方的地址的，只有在运行时刻类加载并调用的时候才能知道，因此jvm使用了符号引用和直接引用
		符号引用，比如在常量池中，一个类会维护被调用的另一个类的全局唯一限定名
		在运行时刻会把符号引用转换为直接引用类似指针的内存地址，通过这种方式调用到其他类的方法或属性，这也是java的动态链接的能力
	
	静态解析和动态链接：
		有些符号引用会在类加载期间或者第一次使用的时候就会转换成直接引用，这种转换就叫做静态解析
		有些符号引用则是在每次运行期间转换为直接引用，这种转换叫做动态链接，这体现为java的多态性。
			Animal a = new Cat();
			a.sleep();
			a = new Dog();
			a.sleep();
			a = new Tiger();
			a.sleep();	
		比如这个代码中 ，编译期间a都是调用Animal的sleep(通过invokevirtual 指向父类的sleep)，只有在运行期间才会知道sleep才知道具体是哪个实例的sleep
	
	操作栈：

                       出栈 <-------+     ++--------入栈
		                    |     ↓  
				|______________|
                  		| stackframe3  |
                                |______________|
                                | stackframe2  |
                                |______________|  
                                | stackframe1  |
                                |______________|
		
		比如 ：3-2这个操作
		     1、把3压栈
		     2、把2压栈
		     3、开始执行减法操作
		     4、执行两次栈顶元素的弹出操作并保存在寄存器中，
		     5、在寄存器中执行减法
		     6、把结果再压栈保存到栈中，此时栈中只有一个元素就是结果1。
	
	局部变量表和slot
		slot是局部变量表的最小单位，比如long会用两个连续的slot保存，int,short只用一个slot保存
	        slot可以复用，比如方法体中的局部变量作用域是不同的
			例子：public void test(){
				int a = 1;
				if(a==1){
					int b = 2;
					int c = 3;
				}
				int d = 4;
				int e = 5;
			}
		在这个例子中 b和c这两个变量在 if作用域结束后就不再使用了，但是在局部变量表中b和c使用的slot是可能复用给d和e继续使用的。
		因此比如在一个方法中有10个int变量，实际上只用到了小与10个的slot，也可以能使用了10个slot。

	
40、jvm方法的的调用指令

	5种方法调用的指令：
		-invokeinterface:调用接口，调用接口中的方法，实际上是在运行期决定到底调用实现该接口的哪个对象的方法。
		-invokestatic:调用静态方法。
		-invokespecial:调用自己的私有方法、构造方法(<init>)以及父类的方法。
		-invokevirtual:调用虚方法，运行期动态查找的过程。
		-invokedynamic:1.7增加的，动态调用方法（比如动态语言javascript）。这种调用是最复杂的。
	
	project/jvm_lecture项目 com.sandro.bytecode.Test6
	案例分析，例子中的main方法code如下：
	     public static void main(java.lang.String[]);
	       Code:
	         stack=0, locals=1, args_size=1
	            0: invokestatic  #5                  // Method test:()V
				     调用的是当前类的静态法方法，所以用的是invokestatic
	            3: return
		
	静态解析:能被invokestatic和invokespecial调用的方法都是在解析阶段就能确定调用过程的。
		-父类方法
		-静态方法
		-私有方法:公有方法可能会被重写，就有可能出现多态的情况，私有方法则不会被重写，因此是可以确定的
		-当前类的构造方法
	 	这4类方法就成为非虚方法，他们是在类加载阶段就可以将符号引用转换成直接引用
	

41、方法重载与invokevitural字节码指令关系	
	project/jvm_lecture项目 com.sandro.bytecode.Test7	
	
	方法的静态分派:
		案例中 Grandpa g1 = new Father();
		g1的静态类型是Grandpa，而个g1的实际类型(真正指向的类型)是Father.
		变量的静态类型是不会变化的，而变量的实际类型根据代码的走向是有可能变化的(多态的一种体现)，实际类型是在运行期才能确定

	方法的重载：
		在方法的重载对于jvm来说是一种静态行为，重载方法的参数是根据静态参数来确定到底是调用哪个版本的方法
		比如 Test7.test(Grandpa  g),不管参数的实际类型是什么，对于test方法来说只认传参时参数的静态类型
		这种静态行为在编译器就可以完全确定的

	main方法的字节码：
	        public static void main(java.lang.String[]);
	          descriptor: ([Ljava/lang/String;)V
	          flags: ACC_PUBLIC, ACC_STATIC
	          Code:
	            stack=2, locals=4, args_size=1
	               0: new           #7                  // class com/sandro/bytecode/Father
	               3: dup
	               4: invokespecial #8                  // Method com/sandro/bytecode/Father."<init>":()V
	               7: astore_1
	               8: new           #9                  // class com/sandro/bytecode/Son
	              11: dup
	              12: invokespecial #10                 // Method com/sandro/bytecode/Son."<init>":()V
	              15: astore_2
	              16: new           #11                 // class com/sandro/bytecode/Test7
	              19: dup
	              20: invokespecial #12                 // Method "<init>":()V
	              23: astore_3
	              24: aload_3
	              25: aload_1
	              26: invokevirtual #13                 // Method test:(Lcom/sandro/bytecode/Grandpa;)V
	              29: aload_3
	              30: aload_2
	              31: invokevirtual #13                 // Method test:(Lcom/sandro/bytecode/Grandpa;)V
	              34: return		

		26 31行 调用了test方法 使用的是invokevitrual指令

42、通过字节码分析java的静态分派和动态分派机制
	project/jvm_lecture项目 com.sandro.bytecode.Test8

	案例中main方法的指令部分内容：
          public static void main(java.lang.String[]);
            descriptor: ([Ljava/lang/String;)V
            flags: ACC_PUBLIC, ACC_STATIC
            Code:
              stack=2, locals=3, args_size=1
                 0: new           #2                  // class com/sandro/bytecode/Apple
                 3: dup
                 4: invokespecial #3                  // Method com/sandro/bytecode/Apple."<init>":()V
                 7: astore_1      //将栈顶引用存入到第一个localVariable中，当前localVariable的就是apple对象
			          //astore_n的序号对应于LocalVariableTable中的序号(slot)
				  //比如astore_1对应Localvariable中序号是1的变量，也就是apple
                 8: new           #4                  // class com/sandro/bytecode/Orange
                11: dup
                12: invokespecial #5                  // Method com/sandro/bytecode/Orange."<init>":()V
                15: astore_2     //将引用存入到第二个localVariable中，当前localVariable的就是orange对象
                16: aload_1      //从局部变量中加载一个引用，也就是LocalVariableTable中slot是1的对象apple
                17: invokevirtual #6                  // Method com/sandro/bytecode/Fruit.test:()V
				 //因为apple的test方法是父类重载的，因此用invokevirtual指令	
                20: aload_2
                21: invokevirtual #6                  // Method com/sandro/bytecode/Fruit.test:()V
                24: new           #4                  // class com/sandro/bytecode/Orange
                27: dup
                28: invokespecial #5                  // Method com/sandro/bytecode/Orange."<init>":()V
                31: astore_1
                32: aload_1
                33: invokevirtual #6                  // Method com/sandro/bytecode/Fruit.test:()V
                36: return
              LineNumberTable:
                ...
              LocalVariableTable:
	        Start  Length  Slot  Name   Signature
        	    0      37     0  args   [Ljava/lang/String;
          	    8      29     1 apple   Lcom/sandro/bytecode/Fruit;
                   16      21     2 orange  Lcom/sandro/bytecode/Fruit;
      	      
	
	方法的动态分派涉及到一个重要的概念-方法接收者
	
	invokevirtual字节码指令的多态查找流程：
		-到操作数栈顶元素指向的对象的实际类型
		-找到以后,如果名称，类型，权限都符合，则查找成功
		-如果找不到，就按照继承的关系从子类到父类逐个查找，直到找到为止

	比较方法重载(overload)和方法重写(override)，方法重载是静态的，是编译器行为；方法重写是动态的是运行期行为

43、虚方法表与动态分配机制详解
	project/jvm_lecture项目 com.sandro.bytecode.Test9
	
	案例中的字节码方法体:
	  public static void main(java.lang.String[]);
	    descriptor: ([Ljava/lang/String;)V
	    flags: ACC_PUBLIC, ACC_STATIC
	    Code:
	      stack=3, locals=3, args_size=1
	         0: new           #2                  // class com/sandro/bytecode/Animal
	         3: dup
	         4: invokespecial #3                  // Method com/sandro/bytecode/Animal."<init>":()V
	         7: astore_1
	         8: new           #4                  // class com/sandro/bytecode/Dog
	        11: dup
	        12: invokespecial #5                  // Method com/sandro/bytecode/Dog."<init>":()V
	        15: astore_2
	        16: aload_1
	        17: ldc           #6                  // String hello
	        19: invokevirtual #7                  // Method com/sandro/bytecode/Animal.test:(Ljava/lang/String;)V
	        22: aload_2
	        23: new           #8                  // class java/util/Date
	        26: dup
	        27: invokespecial #9                  // Method java/util/Date."<init>":()V
	        30: invokevirtual #10                 // Method com/sandro/bytecode/Animal.test:(Ljava/util/Date;)V
	        33: return
	     LineNumberTable:
		...
	     LocalVariableTable:
	        Start  Length  Slot  Name   Signature
	            0      34     0  args   [Ljava/lang/String;
	            8      26     1 animal   Lcom/sandro/bytecode/Animal;
	           16      18     2   dog   Lcom/sandro/bytecode/Animal;
	
	虚方法表：针对于方法调用动态分派的过程，虚拟机会在类的方法区，建立一个虚方法表的数据结构(virtual method table,vtable)
	接口方法表：针对于invokeinterface指令来说，虚拟机会建立一个叫做结构方法表的数据结构(interface method table,itable)

	                |-----------------|
			|      animal     |---->方法1 ，方法2，方法3 
			|_________________|
				 ^
		                 | 继承		
                                 |
	                |-----------------|
			|       dog       |---->方法1,方法2  
			|_________________|
		
		在虚方法表中父类animal和子类dog的方法都有各自的记录，除了方法3，因为方法3子类没有重写，此时子类的方法3实际上保存的是父类方法3的入口地址，这样提升了查找效率同时，更节省空间
	
	vtable ,itable是在类加载的连接阶段初始化完成的	
	
	案例：
		public class Parent{
			void test();
		}

		public class Child extends Parent{
			void test();
			void test1();
		}
	
		调用：
			Parent child = new Child();
			child.test1()
		
	从java语法上讲，child对象被声明为Parent类型，尽管被赋值为一个Child对象，但是在调用的时候依然是按照Parent类型来使用的，而Parent类没有test1方法，所以会编译失败
	而从jvm编译的角度讲，child.test1()这条语句，由于是动态分配，因此会使用invokevirtul指令，此时这个指令指向的是child的声明类型也就是Parent,而Parent没有test1方法，因此编译失败

44、基于栈的指令集与基于寄存器的指令集对比	
	-现代jvm在执行java代码的时候通常都会将解释执行和编译执行结合起来进行
	 所谓解释执行就是通过解释器来读取字节码遇到相应的指令就去执行该指令。
	 所谓编译执行就是通过即时编译器(just in time jit)将字节码转换为本地其器码来执行，现代jvm会根据代码热点(执行频次高的代码)来生成相应的本地机器码，以提高执行效率

	-指令集主要分为基于栈的指令集和基于寄存器的指令集，基于栈的指令集是jvm主要的指令集
 	 基于栈的指令集可移植性更好，但是完成相同操作的情况下，由于需要大量内存的入栈出栈操作，所以使用栈指令要比寄存器指令的数量要多很多。而栈指令集主要是在内存中操作，所以速度慢
	 基于寄存器的指令集和硬件架构相关性很强，所有几乎没有移植性，但是寄存器指令集主要在高速缓冲区中由cpu直接操作，所以速度要高很多。	
	 
	比如计算 2-1 这个操作，jvm的栈指令集操作如下：
		iconst_1 ，将1加到栈顶
		iconst_2 ，将2加到栈顶
		isub,将栈顶和栈顶下面的元素弹栈，将栈顶数字减去下面的数字，然后将结果加到栈顶
		istore_0,将栈顶的元素放到局部变量表的索引是0的slot中
	 
	基于寄存器的规则如下：
		 mov 2,把2放到寄存器1中
		 sub 1,把寄存器中的2减去1再保存在当前寄存器中
		 
45、jvm执行栈指令集实例分析
	project/jvm_lecture项目 com.sandro.bytecode.Test10
	
	案例中的指令代码如下：
	  public int cal();
	    descriptor: ()I
	    flags: ACC_PUBLIC
	    Code:
	      stack = 2, //栈的最大深度是2，在方法内指令集对操作数栈的使用最多就用了两个栈帧
	      locals = 6,  //最大的局部变量是6
	      args_size = 1 //参数数量，这里是默认的this参数
	         0: iconst_1	    , 将数字1推送到操作数栈中
	         1: istore_1	    ，将栈顶(此时是1)弹栈，1号slot中的数据设置为弹栈的值(变量a)，就是int a = 1;的操作
	         2: iconst_2	    , 将数字2推送到操作数栈中
	         3: istore_2	    ，将栈顶(此时是2)弹栈，2号slot中的数据设置为弹栈的值(变量b)，就是int b = 2;的操作
	         4: iconst_3	    , 将数字3推送到操作数栈中
	         5: istore_3	    , 将栈顶(此时是3)弹栈，3号slot中的数据设置为弹栈的值(变量c)，就是int c = 3;的操作
	         6: iconst_4	    , 将数字4推送到操作数栈中
	         7: istore        4 , 将栈顶(此时是4)弹栈，4号slot中的数据设置为弹栈的值(变量d)，就是int d = 4;的操作
				      因为没有istore_4这个指令，这里使用了通用指令 istore xxx
	         9: iload_1	    , 把1号slot的值(a)压栈
	        10: iload_2	    , 把2号slot的值(b)压栈
	        11: iadd	    ，将栈顶和栈顶下一个元素弹栈，并执行加法，然后将结果压栈	
	        12: iload_3	    ，把3号slot的值(c)压栈	
	        13: isub	    , 此时栈顶是3，栈顶下一个元素也是3，将这两个元素弹栈并相减，并把结果压栈
	        14: iload         4 ，把4号slot的值(d)压栈
	        16: imul	    , 从栈顶弹出两个值，计算乘法，并把结果压栈
	        17: istore        5 ，把栈顶元素弹栈，保存到5号slot(result变量)中去
	        19: iload         5 ，将5号slot的值压栈 
	        21: ireturn	    ，把栈顶元素(必须是int类型)return，并清空操作数栈中的剩下的所有栈帧
	      LineNumberTable:
	     	  ...
	      LocalVariableTable:
	        Start  Length  Slot  Name   Signature
	            0      22     0  this   Lcom/sandro/bytecode/Test10;
	            2      20     1     a   I
	            4      18     2     b   I
	            6      16     3     c   I
	            9      13     4     d   I
	           19       3     5 result   I
		
46、java动态代理的字节码
	project/jvm_lecture项目 com.sandro.bytecode.Test11
	
	java1.8之后代理类的生成做了较大改变，采用了java8的Supplier 函数式编程实现的
	
	案例中动态代理返回的实例是com.sun.proxy.$Proxy0 对象，其父类是class java.lang.reflect.Proxy
	这个对象的生成是在java.lang.reflect.Proxy类中的内部类ProxyClassFactory.apply方法生成的
	在ProxyClassFactory.apply 中看到了 byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);
	这里说明动态类实际上是jvm生成的class文件
	ProxyGenerator是sun.misc不开源的代码，这里有一个逻辑是:   
	 private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction("sun.misc.ProxyGenerator.saveGeneratedFiles"))
	通过系统属性开关，判断是否保存生成的class文件
	因此可以通过设置这个开关，看到系统生成的代理类的class字节码文件。
		System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");
	运行后在项目下多出来了一个com目录，里面会有com.sun.proxy.$Proxy0的字节码文件

47、 jvm内存空间划分与作用
	jdk1.7之前和jdk1.8之后jvm在内存管理上做了较大的改动
	
	-虚拟机栈
	 Stack Frame 栈帧，每一个方法在执行的时候，都会有自己方法的栈帧数据结构，用于保存局部变量表(线程能访问的局部变量信息，8种原生类型和引用类型)，操作栈，动态链接，方法的返回地址等信息.
	 栈的深度在编译后就已经确定好了
	 线程独有的内存空间，当线程创建的时候与之相关的虚拟机栈就创建了，线程结束以后，虚拟机栈也会消亡
	 一个方法的执行过程，就是这个方法对于栈帧的入栈和出栈的过程	 
	 线程隔离
	 引用类型，类似c语言的指针，但是不能直接操作，只能通过引用在堆上找到对应的对象来操作数据
	 常见的错误是 stack overflow,栈溢出错误	,极少数会有oom错误	
	 

	-程序计数器 program counter (pc)
	 主要描述字节码执行的位值，是一块很小的内存空间。
	 用来标识当前的执行线程的行号或顺序。
	 是线程私有的内存空间，线程之间不能获取彼此的程序计数器
	 在多线程的环境下，cpu时间片切换的时候也会用程序技术器去保存线程的挂起的位值信息
	 一般不会出错

	-本地方法栈
	 本地方法栈和虚拟机栈的结构非常类似，主要用于描述和执行native方法，有些虚拟机，比如hotspot虚拟机就将本地方法栈和虚拟机栈合二为一了，统一为一种数据结构。
	 常见的错误是 stack overflow,栈溢出错误	
	
	-堆 Heap
	 因为堆内存比较重要，在有些场景里jvm内存会笼统的分为堆内存和非堆内存
	 java创建的大多数对象都是存放在堆里，所有线程都可以共享，一般来说new出来的对象实例都在堆上的,在java中是不能直接操作对象，而是通过引用操作的，引用本是个变量，它是位于jvm栈里面的
	 引用一般是在局部变量表里的变量
	 GC的主要工作区域，为了提高GC的效率，会把堆细分为更多子区域
	 线程共享
	 与堆相关的重要概念是垃圾收集器，现代几乎所有的垃圾收集器都是采用分代收集算法，所以堆空间也基于这一点进行了相应的划分
	 堆内存分代：
		-新生代和老年代，一般情况下新创建的对象会进入新生代，过一段时间，垃圾回收器经过多次回收后会把尚未回收的对象晋升到老年代。进入到老年代的对象回收频率会低很多
		 可以通过一些参数的设置，把新生的对象直接放置到老年代
		-Eden空间，From Survivor空间，To Survivor空间
	 堆空间可以是连续的也可以是不连续的	      
	 最常见的错误就是oom错误

 
	 对象:
	  对象本身分为两个数据，一个是本身的数据，一个是元数据(比如class数据等)，元数据是共享的，多个相同类型的对象共享一个元数据，它是一类数据的共同信息
	  元数据保存在方法区
	  对象数据保存有两种方式：
		- 句柄：对象实例本身是两个指针，一个指向实际的实例数据，一个指向对象的元数据
			
                              栈                                     堆
			|              |
			+——————————————+		 +---------------------------+
			|    long      |       +-------->|--实例句柄--->实例数据     |
                        +--------------+       |	 |         |                 |
			|    byte      |       |         |         |                 |
                        +--------------+       |         +---------|-----------------|                           
			|    int       |       |         | 方法区  |                 |     
                        +--------------+       |         |         +---> 元数据      |
			|    ref       | ------+         +---------------------------+ 
                        +--------------+

		- 直接指针：对象实例本是实例数据 和 元数据指针的集合
	
                              栈                                     堆
			|              |
			+——————————————+		 +---------------------------+
			|    long      |       +-------->|--实例数据----+            |
                        +--------------+       |	 |              |            |
			|    byte      |       |         |              |            |
                        +--------------+       |         +--------------|------------+                         
			|    int       |       |         | 方法区       |            |     
                        +--------------+       |         |            元数据         |
			|    ref       | ------+         +---------------------------+ 
                        +--------------+
		- jvm并没有强制具体用哪种方式，比如oracle的 hotspot虚拟机用的是第二种方式
		- 这两种方式在使用中的的主要差别：在垃圾回收的时候往往需要内存移动合并从而保证尽量有大的连续的空间，二者在内存移动时的操作方式是不同的
			
	-方法区method area
	 和堆一样各线程共享，主要保存元信息，比如class的结构信息，常量，静态变量，包括常量池、字段描述、方法描述
	 GC的非主要工作区域
	 永久代(permanent generation),这里的信息很少被垃圾回收，方法区里信息很少被回收，所以方法区在有的虚拟机里也被划分为永久代
	 从jdk1.8开始，永久代内存被彻底废弃，因为永久代可能会造成内存溢出，所以1.8之后使用元空间(meta space)替代了永久代		
	
	-运行期常量池，它是方法区的一部分，编译器生成的各种字面值比如常量和符号引用等
	
	-直接内存：Direct Memory，也叫堆外内存不受虚拟机直接管理而时操作系统管理的。一般是native方法使用的内存 ，是由jvm在运行期间向操作系统申请。
		   与java NIO直接相关，jvm通过堆上的DirectByteBuffer来操作直接内存。

48、java对象内存分配原理与布局    
	对象实例生成的方式：new反射,clone,反序列化
	
	new关键字创建对象的3个步骤:
		-在堆内存种创建出对象的实例，在创建之前jvm会检查类是否已经加载，如果类没加载还需要先把类加载后才能创建对象
		-为对象的实例成员变量赋值(静态变量是在类的初始化阶段就赋值了)，这部分是在<init>方法中赋值的
		-将对象的引用返回
	
	内存创建对象的两种情况：使用那种方式是根垃圾收集器的算法是息息相关的，有些算法会把使用的和未使用的空间分开，有些则不会分开导致使用和未使用的交织在一起。
		指针碰撞：
			前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间
			此时分配空间的时候只要指针偏移后就能找到对应的空间存放对象
	
		空闲列表：
			前提是堆内存空间中已被使用的空间和未被使用的空间是交织在一起的。这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些是已被使用的
			接下来找出可以容纳下新创建的对象的且未被使用的空间，在此空间存放对象，同时还要修改列表上的记录
		
	对象在内存中的布局
		-对象头，保存对象自身的运行的数据信息，比如哈希码，分代信息等
		-实例数据，即我们在一个类中所声明的各项信息，比如成员变量的信息
		-对齐填充(可选)	，一般是一些占位符号，比如有的空间最小单位是8位，不到8位就用占位符填充上		
	
	
	引用访问对象的方式：
		-使用句柄的方式
		-使用直接指针的方式	

49、使用jvisualvm查看内存错误文件
	project/jvm_lecture项目 com.sandro.memory.Test1

	案例分析：
		案例是一个死循环通过不断向list中添加对象而最终内存溢出的程序，为了能更快的内存溢出同时把内存问题保存到磁盘上，设置如下vm 环境变量
			-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError
			这里将运行期最大堆内存和最小堆内存都设置为5M，同时设置保存内存溢出log文件
		运行后输出如下：
			java.lang.OutOfMemoryError: Java heap space
			Dumping heap to java_pid48431.hprof ...    //这里是内存溢出错误文件 在项目根目录下会找到该文件
			Heap dump file created [9040787 bytes in 0.024 secs]
			Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
				at com.sandro.memory.Test1.<init>(Test1.java:7)
				at com.sandro.memory.Test1.main(Test1.java:11)

	导出的.hprof文件可以通过 oracle 工具jvisualvm查看

	打开jvisualvm可以在应用程序中看到本地正在运行的java应用，也可以在远程中查看远程java应用程序

	打开转转储文件
		文件->装入，选择文件路径和筛选器(Dump *.hprof)
		打开后，分为 概要，类，实例数，OQL控制台 4个部分 ，可以在 概要的 “堆转储上的线程”部分看到异常信息
		
		类：
			这部分记录了jvm在加载过程中加载过的类，通过实例数可以看到哪些类的实例最多

		实例数：
			刚打开的时候提示 “要查看实例, 请双击类或首先从  类视图的弹出式菜单中选择“显示实例视图”。”这里需要通过设置才能看到具体的信息
			点击 “类” 选择类中关注的类。
			此时展示的是当前类所有的实例信息，并且可以查看每个具体实例的属性值，
			从实例表的“字段信息”中可以看到在异常发生的时候当前类一共实例化了多少个实例
			在“引用信息中”可以看到具体某个实例中有哪些引用

		OQL控制台：
			这里可以通过类似sql语句的方式查询信息


		一般oom问题可以通过工具查看到底哪些实例被创建，大概率这些大量实例是导致oom的原因

	当在代码中显示的使用System.gc的时候，发现oom发生的时间明显延后了。
		通过jvisualvm动态查看java进程内存，观察gc的作用：
			运行进程
			在jvisualvm上本地中可以看到运行的java进程，双击查看
		此时出现的视图和.phrof文件的视图完全不一样，分为：概述，监视，线程，抽样器，profiler这几个部分
			监视：在cpu情况中 能看到当前进程正在频繁使用cpu 和 垃圾回收正在频繁使用的情况
			      堆空间中可以看到使用的内存正在缓慢上升，Metaspace中显示当前使用的元空间
			线程：显示当前所有线程，正在运行的线程，完成的线程等信息
			抽样器：可以查看的cpu 内存的动态信息
			
50、线程栈溢出监控与分析详解
	project/jvm_lecture项目 com.sandro.memory.Test2	 
	该案例是,虚拟机栈溢出的演示 ,stack overflow
	运行后会有 java.lang.StackOverflowError 发生,这时length=13863

	当设置了虚拟机参数 -Xss100k 在运行后，返回如下信息
		Error: Could not create the Java Virtual Machine.
		Error: A fatal exception has occurred. Program will exit.

		The stack size specified is too small, Specify at least 228k
	-Xss100k是设置虚拟机栈最大空间100k的意思，当设置太小的时候 java虚拟机都无法创建，改称228k后运行正常。这时候 length = 1517
	但是错误发生的时候栈深度length比没有设置的时候会小很多。 
	  
	通过jvisualvm监控虚拟栈
		在test方法前sleep以下，这样不会让程序立刻出错
		在jvisualvm attach到进程以后，动态观察进程的运行情况
		在线程视图下，点击线程Dump,此时会生成一个threaddump临时文件的展示界面
		此时会把jvm中所有执行的线程现场调用情况和数据都会呈现出来

		2023-08-21 16:14:19
		Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.291-b10 mixed mode):
		
		"RMI TCP Connection(2)-127.0.0.1" #16 daemon prio=9 os_prio=0 tid=0x00007f8f48003000 nid=0x17e7c runnable [0x00007f8f80e3e000]
		   java.lang.Thread.State: RUNNABLE
		        at java.net.SocketInputStream.socketRead0(Native Method)
		        。。。
		        - locked <0x000000076e46b6d8> (a java.io.BufferedInputStream)
		        at java.io.FilterInputStream.read(FilterInputStream.java:83)
		        。。。。
		
		   Locked ownable synchronizers:
		        - <0x000000076de21cb8> (a java.util.concurrent.ThreadPoolExecutor$Worker)
		
		"JMX server connection timeout 15" #15 daemon prio=9 os_prio=0 tid=0x00007f8f4c014000 nid=0x17e78 in Object.wait() [0x00007f8f80f40000]
		   java.lang.Thread.State: TIMED_WAITING (on object monitor)
		        at java.lang.Object.wait(Native Method)
		        at com.sun.jmx.remote.internal.ServerCommunicatorAdmin$Timeout.run(ServerCommunicatorAdmin.java:168)
		        - locked <0x000000076dfe1ad8> (a [I)
		        at java.lang.Thread.run(Thread.java:748)
		
		   Locked ownable synchronizers:
		        - None
		
		"RMI Scheduler(0)" #14 daemon prio=9 os_prio=0 tid=0x00007f8f4c011800 nid=0x17e77 waiting on condition [0x00007f8f81041000]
		   java.lang.Thread.State: TIMED_WAITING (parking)
		        at sun.misc.Unsafe.park(Native Method)
		        - parking to wait for  <0x000000076dce4910> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
		        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
		        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
		        。。。
		
		   Locked ownable synchronizers:
		        - None
		
		"RMI TCP Accept-0" #12 daemon prio=9 os_prio=0 tid=0x00007f8f54163000 nid=0x17e74 runnable [0x00007f8f81243000]
		   java.lang.Thread.State: RUNNABLE
		        at java.net.PlainSocketImpl.socketAccept(Native Method)
		        。。。
		
		   Locked ownable synchronizers:
		        - None
		
		"Attach Listener" #10 daemon prio=9 os_prio=0 tid=0x00007f8f6c001000 nid=0x17e6a waiting on condition [0x0000000000000000]
		   java.lang.Thread.State: RUNNABLE
		
		   Locked ownable synchronizers:
		        - None
		
		"Service Thread" #9 daemon prio=9 os_prio=0 tid=0x00007f8fac20b800 nid=0x17e5d runnable [0x0000000000000000]
		   java.lang.Thread.State: RUNNABLE
		
		   Locked ownable synchronizers:
		        - None
		
		"C1 CompilerThread2" #8 daemon prio=9 os_prio=0 tid=0x00007f8fac209000 nid=0x17e5c waiting on condition [0x0000000000000000]
		   java.lang.Thread.State: RUNNABLE
		
		   Locked ownable synchronizers:
		        - None
		
		"C2 CompilerThread1" #7 daemon prio=9 os_prio=0 tid=0x00007f8fac207000 nid=0x17e5b waiting on condition [0x0000000000000000]
		   java.lang.Thread.State: RUNNABLE
		
		   Locked ownable synchronizers:
		        - None
		
		"C2 CompilerThread0" #6 daemon prio=9 os_prio=0 tid=0x00007f8fac205000 nid=0x17e5a waiting on condition [0x0000000000000000]
		   java.lang.Thread.State: RUNNABLE
		
		   Locked ownable synchronizers:
		        - None
		
		"Monitor Ctrl-Break" #5 daemon prio=5 os_prio=0 tid=0x00007f8fac202800 nid=0x17e59 runnable [0x00007f8f81f7d000]
		   java.lang.Thread.State: RUNNABLE
		        at java.net.SocketInputStream.socketRead0(Native Method)
		        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)
		        。。。。
		        - locked <0x000000076d305558> (a java.io.InputStreamReader)
		        at java.io.InputStreamReader.read(InputStreamReader.java:184)
		        at java.io.BufferedReader.fill(BufferedReader.java:161)
		        at java.io.BufferedReader.readLine(BufferedReader.java:324)
		        - locked <0x000000076d305558> (a java.io.InputStreamReader)
		        at java.io.BufferedReader.readLine(BufferedReader.java:389)
		        at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:56)
		
		   Locked ownable synchronizers:
		        - None
		
		"Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00007f8fac182000 nid=0x17e50 runnable [0x0000000000000000]
		   java.lang.Thread.State: RUNNABLE
		
		   Locked ownable synchronizers:
		        - None
		
		"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007f8fac14f800 nid=0x17e4e in Object.wait() [0x00007f8f829f0000]
		   java.lang.Thread.State: WAITING (on object monitor)
		        at java.lang.Object.wait(Native Method)
		        - waiting on <0x000000076d188ee0> (a java.lang.ref.ReferenceQueue$Lock)
		        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)
		        - locked <0x000000076d188ee0> (a java.lang.ref.ReferenceQueue$Lock)
		        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)
		        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)
		
		   Locked ownable synchronizers:
		        - None
		
		"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007f8fac14b000 nid=0x17e4d in Object.wait() [0x00007f8f82af1000]
		   java.lang.Thread.State: WAITING (on object monitor)
		        at java.lang.Object.wait(Native Method)
		        - waiting on <0x000000076d186c00> (a java.lang.ref.Reference$Lock)
		        at java.lang.Object.wait(Object.java:502)
		        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
		        - locked <0x000000076d186c00> (a java.lang.ref.Reference$Lock)
		        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
		
		   Locked ownable synchronizers:
		        - None
		
		"main" #1 prio=5 os_prio=0 tid=0x00007f8fac00c000 nid=0x17e42 waiting on condition [0x00007f8fb1a22000]
		   java.lang.Thread.State: TIMED_WAITING (sleeping)
		        at java.lang.Thread.sleep(Native Method)
		        at com.sandro.memory.Test2.test(Test2.java:13)
		        at com.sandro.memory.Test2.test(Test2.java:14)   
			...下面省略无数行。。
		Locked ownable synchronizers:
		        - None
		
		"VM Thread" os_prio=0 tid=0x00007f8fac141000 nid=0x17e4c runnable 
		
		"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00007f8fac021000 nid=0x17e43 runnable 
		
		"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00007f8fac023000 nid=0x17e44 runnable 
		
		"GC task thread#2 (ParallelGC)" os_prio=0 tid=0x00007f8fac024800 nid=0x17e45 runnable 
		
		"GC task thread#3 (ParallelGC)" os_prio=0 tid=0x00007f8fac026800 nid=0x17e46 runnable 
		
		"VM Periodic Task Thread" os_prio=0 tid=0x00007f8fac20e800 nid=0x17e5e waiting on condition 
		
		JNI global references: 352
		
		虽然当前很多线程都在运行，但是实际上和应用相关的线程只有main线程
			 "main" #1 prio=5 os_prio=0 tid=0x00007f8fac00c000 nid=0x17e42 waiting on condition [0x00007f8fb1a22000]
			 	prio = 5 ，优先级是5 ，java线程的优先级是 1～10，数字越高优先级越高，默认是5
			 	os_prio=0 ，系统的优先级
			 java.lang.Thread.State: TIMED_WAITING (sleeping)
				当前状态是sleeping状态，每次执行test的时候都会sleep(300),所以加载现场的时候大概率是在线程睡眠的时候
		
	
	使用jconsole也能监控java进程运行情况
		启动后连接到当前进程
		连接后在线程中也能看到main线程，双击就能查看main线程的堆栈跟踪信息
			名称: main
			状态: TIMED_WAITING
			总阻止数: 0, 当前线程阻止其他线程的数量
			总等待数: 696,当前线程等待了多少次
	
			堆栈跟踪: 
			java.lang.Thread.sleep(Native Method)
			com.sandro.memory.Test2.test(Test2.java:13)
			com.sandro.memory.Test2.test(Test2.java:14)
			com.sandro.memory.Test2.test(Test2.java:14)
			。。。
	
		在"线程"视图中选中要关注的线程后，点击下面的"检测死锁"，可以检查是否有死锁的情况


51、线程死锁检测与分析工具
	project/jvm_lecture项目 com.sandro.memory.Test3
	案例演示了死锁的情况，运行后通过jconsole查看线程
	在线程列表中此时会看到没有结束的 thread_a  thread_b这两个线程,此时main方法已经执行完成，所以看不到main线程
		名称: thread_a
		状态: java.lang.Class@4594cc19上的BLOCKED, 拥有者: thread_b
		总阻止数: 1, 总等待数: 1
		
		堆栈跟踪: 
		com.sandro.memory.B.method(Test3.java:36)
		com.sandro.memory.A.method(Test3.java:27)
		   - 已锁定 java.lang.Class@17f69de9
		com.sandro.memory.Test3$1.run(Test3.java:8)
		
		名称: thread_b
		状态: java.lang.Class@17f69de9上的BLOCKED, 拥有者: thread_a
		总阻止数: 1, 总等待数: 1
		
		堆栈跟踪: 
		com.sandro.memory.A.method(Test3.java:23)
		com.sandro.memory.B.method(Test3.java:39)
		   - 已锁定 java.lang.Class@4594cc19
		com.sandro.memory.Test3$2.run(Test3.java:14)
	
	从信息中能够清晰的看出thread_a 被阻塞了，而锁的拥有者是thread_b。 thread_b也阻塞了，锁的拥有者是thread_a
	通过“检测死锁”就可以更明确的看到哪些线程死锁了

	在jvisualvm中 打开后立刻就能看到 死锁的提示，通过线程dump也能查看死锁的现场信息
		
		...
		"thread_b" #11 prio=5 os_prio=0 tid=0x00007effb8217800 nid=0x185c4 waiting for monitor entry [0x00007eff74ae3000]
		   java.lang.Thread.State: BLOCKED (on object monitor)
		        at com.sandro.memory.A.method(Test3.java:23)
		        - waiting to lock <0x000000076d68e230> (a java.lang.Class for com.sandro.memory.A) //这里能更清晰的指出哪个对象被锁住了
		        at com.sandro.memory.B.method(Test3.java:39)
		        - locked <0x000000076d408ec0> (a java.lang.Class for com.sandro.memory.B)
		        at com.sandro.memory.Test3$2.run(Test3.java:14)
		
		   Locked ownable synchronizers:
		        - None
		
		"thread_a" #10 prio=5 os_prio=0 tid=0x00007effb8215800 nid=0x185c3 waiting for monitor entry [0x00007eff74be4000]
		   java.lang.Thread.State: BLOCKED (on object monitor)
		        at com.sandro.memory.B.method(Test3.java:36)
		        - waiting to lock <0x000000076d408ec0> (a java.lang.Class for com.sandro.memory.B)
		        at com.sandro.memory.A.method(Test3.java:27)
		        - locked <0x000000076d68e230> (a java.lang.Class for com.sandro.memory.A)
		        at com.sandro.memory.Test3$1.run(Test3.java:8)
		
		   Locked ownable synchronizers:
		        - None
		
		...

		Found one Java-level deadlock:
		=============================
		"thread_b":
		  waiting to lock monitor 0x00007eff8c006568 (object 0x000000076d68e230, a java.lang.Class),
		  which is held by "thread_a"
		"thread_a":
		  waiting to lock monitor 0x00007eff8c0050c8 (object 0x000000076d408ec0, a java.lang.Class),
		  which is held by "thread_b"
		
		Java stack information for the threads listed above:
		===================================================
		"thread_b":
		        at com.sandro.memory.A.method(Test3.java:23)
		        - waiting to lock <0x000000076d68e230> (a java.lang.Class for com.sandro.memory.A)
		        at com.sandro.memory.B.method(Test3.java:39)
		        - locked <0x000000076d408ec0> (a java.lang.Class for com.sandro.memory.B)
		        at com.sandro.memory.Test3$2.run(Test3.java:14)
		"thread_a":
		        at com.sandro.memory.B.method(Test3.java:36)
		        - waiting to lock <0x000000076d408ec0> (a java.lang.Class for com.sandro.memory.B)
		        at com.sandro.memory.A.method(Test3.java:27)
		        - locked <0x000000076d68e230> (a java.lang.Class for com.sandro.memory.A)
		        at com.sandro.memory.Test3$1.run(Test3.java:8)
		
		Found 1 deadlock.
	
52、jvm 元空间深度解析
	java1.8之后，方法区内的通过元空间来管理数据，相对于1.8之前的永久代，元空间使用内存更灵活，它是一个不连续的内存空间
	元空间默认是使用操作系统的源生内存，初始内存大小是21M，如果随着进程的运行，内存不够，它会自动垃圾回收，或者空间扩展来保证内存的正常使用，可以一直扩展到物理内存最大的限度
	
	project/jvm_lecture项目 com.sandro.memory.Test4
	案例是方法区产生内存的错误，方法区产生内存问题一般不太好复现，可以通过设置vm参数的方式查看效果，需要使用两种手段来限制
		-显式的设定元空间的大小，让元空间不会不断的扩展
			-XX:MaxMetaspaceSize=10m
		-元空间主要存放元信息，比如类的信息。通过动态生成类的方法不断的增加元信息从而导致内存溢出		
		 使用cglib动态创建类的方式，往metaspace中不断加入类数据，依赖cglib-3.3.0 asm-8.0这两个jar包
		
	运行后很快就产生了oom异常，多运行几次就会看到 Metaspace 溢出的oom异常
		Caused by: java.lang.OutOfMemoryError: Metaspace
		at java.lang.ClassLoader.defineClass1(Native Method)
		at java.lang.ClassLoader.defineClass(ClassLoader.java:756)
		... 11 more

	通过jconsole查看内存在"概览"视图的类信息可以看到 类加载了非常多
	在"类"视图中也可以看到不断有类在加载，勾选“详细输出”在log中会看到类加载的信息
		[Loaded com.sandro.memory.Test4$$EnhancerByCGLIB$$412b6c4b_2416 from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
	
	在jvisualvm中“概述”视图里面也能看到 类加载的情况
	在堆/metaspace视图中选择metaspace也能看到 使用的内存在不断增加，当达到设定值的时候就会内存溢出

	为什么使用元空间
		在过去自定义类加载器使用不普遍的时候，类几乎是“静态的”，因此类也可以被看成“永久的”。另外由于类作为jvm实现的一部分，他们不由程序来创建，因此他们也被认为是“非堆”内存
		在jdk8之前的hotspot虚拟机中，类的这些“永久的”数据存放在一个叫做永久代的区域，它是一个连续的内存空间。
		永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦一个区域占满，这两个区域都要进行垃圾回收，但是有个明显的问题就是一旦类的元数据超过了设定的大小，程序就会oom
		
		1.8之后 永久代被抛弃，元数据信息被移到了和堆不相连的本地内存区域，这个区域就是元空间
		这项改动是必要的，因为对永久代调优是很困难。永久代的元数据可能会随着每一次Full GC发生而进行移动。
		并且为永久代设置空间大小也是很难确定的，因为影响因素太多，比如类的总数，常量池的大小和方法数量等,同时，hotspot虚拟机的每种类型的垃圾回收器都需要特殊处理永久代的元数据。
		将数据从永久代剥离出来，不仅实现了对元空间的无缝管理，还简化了Full GC
		
		由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统的可用内存空间。因此，我们就不会遇到永久代存在时的内存溢出错误。
		最终用户可以为元空间设置一个可用最大值，如果不进行设置，jvm会自动根据类的元数据大小动态增加元空间的容量。jvm默认是不设置元空加的大小的
		注意：元空间的使用并不代表自定义的类加载器泄漏的问题就解决了。因此必须要监控内存消耗的情况，因为一旦发生泄漏，会占用大量的本地内存，并且还可能导致交换区交换更加糟糕。

		元空间的内存管理由元空间虚拟机来完成。
		元空间使用固定大小组块保存类信息，这种情况下会导致碎片较多，而元空间目前不支持压缩操作，因此碎片化是元空间目前最的的问题。

53、jmap与jstat工具实战分析
	-jmap -clstats PID 打印类加载器数据，-clstats是-permstat的替代方案，在jdk1.8之前，-permstat用来打印类加载器的数据
		-ps aux | grep "Test4",  查找Test4进程id
		运行：jmap -clstats 105772

	 此时报错误1：ERROR: ptrace(PTRACE_ATTACH, ..) failed for 105772: 不允许的操作
	 报错原因：linux加入了ptrace-scope的限制，防止用户访问正在执行的应用的内存而jinfo jmap这些调试类工具本身就是利用ptrace来获取执行进程的内存等信息
	 解决方案：
		sysctl -n kernel.yama.ptrace_scope 查看以下内核参数。1表示正在禁止访问，0表示可以访问
		把这个值改称0就可以，由两种方案
		-直接修改:sysctl -w kernel.yama.ptrace_scope=0
		-输入值到ptrace_scope文件中
		 echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scpoe
		 tee  标准输出流到文件，意思是将0这个值输出到ptrace_scope文件中去
				
	 再执行jmap命令还是报错误2：
		Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file
	 报错原因：jamp命令和执行java程序的java命令不是同一版本的，比如再idea中运行java程序，默认是idea自带的java虚拟机
	 解决方案：使用同一套java命令运行程序，比如在命令行到 class目录下用java命令执行class文件

	 成功后输出如下：
		Attaching to process ID 106560, please wait...
		Debugger attached successfully.
		Server compiler detected.
		JVM version is 25.291-b10
		finding class loader instances ..done.
		computing per loader stat ..done.
		please wait.. computing liveness......done.
		class_loader		classes	bytes	parent_loader	   alive?	type
		
		<bootstrap>		384	754892	  null  	   live	        <internal> //启动类加载器 加载类的数量是384，占用754892个字节，父加载器是null，当前存活
		0x000000076d1ce3c8	1	748	0x000000076d1ba860 live	       sun/misc/Launcher$AppClassLoader@0x00000007c000f958//应用类加载器，父加载器是扩展类加载器
		0x000000076d1ba860	0	0	  null  	   live	       sun/misc/Launcher$ExtClassLoader@0x00000007c000fd00 //扩展类加载器
		
		total = 3		385	755640	    N/A    	alive=3, dead=0	    N/A 		
		
	-jamp -heap <pid> 打印进程堆信息如下:
		Attaching to process ID 106697, please wait...
		Debugger attached successfully.
		Server compiler detected.
		JVM version is 25.291-b10
		
		using thread-local object allocation.
		Parallel GC with 4 thread(s) //4线程的gc并行垃圾收集器
		
		Heap Configuration:
		   MinHeapFreeRatio         = 0                          
		   MaxHeapFreeRatio         = 100
		   MaxHeapSize              = 4173332480 (3980.0MB)
		   NewSize                  = 87031808 (83.0MB)
		   MaxNewSize               = 1390936064 (1326.5MB)
		   OldSize                  = 175112192 (167.0MB)
		   NewRatio                 = 2
		   SurvivorRatio            = 8
		   MetaspaceSize            = 21807104 (20.796875MB)
		   CompressedClassSpaceSize = 1073741824 (1024.0MB)
		   MaxMetaspaceSize         = 17592186044415 MB
		   G1HeapRegionSize         = 0 (0.0MB)
		
		Heap Usage:
		PS Young Generation //年轻代
		Eden Space:
		   capacity = 66060288 (63.0MB)
		   used     = 2642440 (2.5200271606445312MB)
		   free     = 63417848 (60.47997283935547MB)
		   4.000043112134176% used
		From Space:
		   capacity = 10485760 (10.0MB)
		   used     = 0 (0.0MB)
		   free     = 10485760 (10.0MB)
		   0.0% used
		To Space:
		   capacity = 10485760 (10.0MB)
		   used     = 0 (0.0MB)
		   free     = 10485760 (10.0MB)
		   0.0% used
		PS Old Generation  //老年代
		   capacity = 175112192 (167.0MB)
		   used     = 0 (0.0MB)
		   free     = 175112192 (167.0MB)
		   0.0% used
		
		708 interned Strings occupying 47208 bytes.//708个内部字符串占用了47208个字节

	-jstat -gc LVMID,用来打元空间的信息,对于本地来说LVMID就是进程id，如果是远程的化需要加ip和端口号
	 例子：jstat -gc 106697
		 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
		10240.0 10240.0  0.0    0.0   64512.0   2580.5   171008.0     0.0     4480.0 782.2  384.0   76.6       0    0.000   0      0.000    0.000
		
		MC:4480 ,Current Metaspace Capacity(KB),当前元空间占用字节的KB数，这是系统默认分配的,它会根据MU的变化而动态调整
			 如果设置了Maxspacesize 当MC达到最大值的时候就会oom
		MU:782.2 ,Metaspace Utilization(KB)，当前元空间已经占用的KB数
		

54、jps、jcmd命令
	jps 命令，直接查看java虚拟机进程
	jps -nkvV , 带有java 虚拟机参数的进程信息
	jps -l 进程号+包名

	jcmd ,jdk 1.7之后增加的重要java命令
	jcmd ：直接使用该命令，和jps类似
	
	jcmd <pid> VM.flags : 输出<pid>进程启动参数
		109548:
		-XX:CICompilerCount=3 -XX:CompressedClassSpaceSize=12582912 -XX:InitialHeapSize=262144000 -XX:MaxHeapSize=4173332480 
		-XX:MaxMetaspaceSize=20971520 -XX:MaxNewSize=1390936064 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=87031808 -XX:OldSize=175112192 
		-XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC 
	

	jcmd <pid> help 列出当前java进程可以执行的操作
		109828:
		The following commands are available:
		JFR.stop       
		JFR.start
		JFR.dump
		JFR.check
		VM.native_memory
		VM.check_commercial_features
		VM.unlock_commercial_features
		ManagementAgent.stop
		ManagementAgent.start_local
		ManagementAgent.start
		VM.classloader_stats
		GC.rotate_log
		Thread.print
		GC.class_stats
		GC.class_histogram
		GC.heap_dump
		GC.finalizer_info
		GC.heap_info
		GC.run_finalization
		GC.run
		VM.uptime
		VM.dynlibs
		VM.flags
		VM.system_properties
		VM.command_line
		VM.version
		help
	
	jcmd <pid> help JFR.dump:查看JFR.dump命令的帮助信息

	cmd <pid> PerfCounter.print ： 列出jvm性能相关的参数

	jcmd <pid> VM.uptime : 查看某个进程jvm的启动时长

	jcmd 109828 GC.class_histogram：查看进程中类的统计信息
		109828:
		
		 num     #instances         #bytes  class name
		----------------------------------------------
		   1:         20062        1765456  java.lang.reflect.Method
		   2:          7305         580256  [C
		   3:         18635         398112  [Ljava.lang.Class;
		   4:          1836         246912  java.lang.Class
		   5:          7289         174936  java.lang.String
		   6:          6407         153768  net.sf.cglib.core.Signature
		....
	jcmd <pid> Thread.print 查看线程堆栈信息,也会列出死锁的情况，和jconsole或者jvisualvm中基本一样的

	jcmd <pid> GC.heap_dump ~/mywork/test.phrof 把heap dump信息保存到文件中去

	jcmd <pid> VM.system_properties 输出进程的jvm属性信息
		110369:
		#Wed Aug 23 17:37:27 CST 2023
		java.runtime.name=Java(TM) SE Runtime Environment
		sun.boot.library.path=/usr/jdk1.8.0_291/jre/lib/amd64
		java.vm.version=25.291-b10
		java.vm.vendor=Oracle Corporation
		java.vendor.url=http\://java.oracle.com/
		path.separator=\:
		java.vm.name=Java HotSpot(TM) 64-Bit Server VM
		file.encoding.pkg=sun.io
		user.country=CN

	jcmd <pid> VM.version 查看目标JVM进程的版本信息
		Java HotSpot(TM) 64-Bit Server VM version 25.291-b10
		JDK 8.0_291

	jcmd <pid> VM.command_line 查看JVM启动的命令行参数信息

	
55、jstack、jmc、jhat
	jstack:可以查看或者导出java应用程序中线程的信息和jcmd <pid> Thread.print 是一样的
		jstack <pid>

	jmc : java mission control java任务控制，是一个一体化的图形界面工具
	jfr: java Flight Recorder: java飞行记录器，实时获取java进程的信息
		
	jhat <文件>:堆转储存文件分析
		Reading from java_pid111543.hprof...
		Dump file created Wed Aug 23 23:15:25 CST 2023
		Snapshot read, resolving...
		Resolving 97290 objects...
		Chasing references, expect 19 dots...................
		Eliminating duplicate references...................
		Snapshot resolved.
		Started HTTP server on port 7000
		Server is ready.
	
		此时，使用浏览器查看内容 http://locallost:7000
		Execute Object Query Language (OQL) query 使用类似sql语法的方式查找信息
			如：select classof(classloader).name from instanceof java.lang.ClassLoader classloader

56、垃圾回收重要理论分析
	
	-JVM运行时内存数据区域，如图：56_JVM运行时内存数据区域			
	 例子：
		public void method(){
			Object obj = new Object();
		}
	 这条语句生成了两部分内存区域
		-obj这个引用变量，因为是方法内的变量，所以放到的是JVM Stack的局部变量表中
		-真正Object class的实例对象，放到了Heap里面
	 上述的new 语句一共消耗了12个bytes ,JVM规定引用占4个byte(放在JVM Stack)，而空的对象是8个byte(在Heap里面)	
	 当方法结束后，对应Stack中的变量马上回收，但是Heap中的对象要等GC来回收

	-JVM垃圾回收(GC)模型
		垃圾判断算法
			-引用计数算法 Refference Counting
			 给对象添加一个引用计数器，当有一个地方引用它，计数器就+1，当引用失效，计数器-1，任何时刻计数器为0的对象就是不可能再被引用的
			 引用计数算法无法解决对象的循环引用的问题，如图：56_对象的循环引用
			 因此一般都是结合其他手段规避掉这个问题，比如ObjectC就主要使用了引用计数算法和其他算化混合的方式回收垃圾
				
			-根搜索算法 GC Roots Tracing
			 在实际的生产语言中(java,c#等)，都时使用根搜索算法判定对象是否存活
			 算法基本思路就是通过一系列称为"GC Roots"的点作为起始点进行向下搜索，当一个对象到GC Roots都没有任何以用链(Reference Chain)相连，则证明此对象是不可用的
                         在java语言中，GC Roots包括
                                 在VM栈（帧中的本地变量）中的引用
                                 方法区的静态引用
                                 JNI中的引用
			 枚举根节点：
                                 当执行系统停顿下来以后，并不需要一个不漏的检查完所有执行上下文和全局的引用位值，jvm应当是有办法直接得知哪些地方存放这对象引用
                                 在Hotspot的实现中，是使用一组成为OopMap的数据结构来达到这个目的的
			 
			 安全点:
				在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变或阿的指令非常多
				如果每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本就非常高。

				实际上，HotSpot并没有为每条指令都生成OopMap,而只是在“特定的位值”，记录了这些信息，这些位值成为安全点(Safepoint)，即程序执行时并非在所有地方都能停顿下来执行GC
				只有在达到安全点时才能暂停

				safepoint的选定就不能太少以至于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负载。所以安全点的选定基本上是以“是否具有程序长时间执行的特征”为标准进行选定的
				因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行。“长时间执行”的最明显的特征就是指令序列复用
				例如方法调用、循环跳转、异常跳转，所以具有这些功能的指令才会产生safepoint
	
				对于safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来：抢占式中断和主动式中断

				抢占式中断：它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果线程中断的地方不在安全点上，就恢复线程，让他跑到“安全点”上。
				主动式中断：当GC需要中断线程的时候，不直接对线程进行操作，仅仅简单的设置一个标志，各个线程执行时主动轮询这个标志，发现中断标志为真就自己中断挂起。
				    	    轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

				现在几乎没有虚拟机采用抢占式中断来暂停线程从而相应GC事件

			安全区域 :
				在使用safepoint似乎已经完美的解决了如何进入GC的问题，但实际上情况却并不一定。safepoint机制保证了程序执行时，在不太长的时间就可以遇到可进入GC的safepoint。
				但如果程序在“不执行”的时候呢？所谓不执行的程序就是没有分配到cpu时间片，典型的例子就是处与sleep状态和Blocked状态的线程，这时候线程无法相应JVM的中断请求，
				JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域（Safe Regin）来解决了。
			
				在线程执行到安全区域的代码时，首先标识自己已经进入了安全区域，当在这段时间里JVM要发起GC时，就不用管标识自己为安全区域状态的线程了。
				在线程要离开安全区域的时候，他要检查系统是否已经完成了根节点枚举(或者是整个GC流程)，如果完成了，那线程就继续执行，否者它就必须等待直到收到可以离开安全点的信号为止
				
				
			-方法区的垃圾回收：
				java虚拟机规范表示可以不要求在方法区内实现GC，因为对方法区使用GC的"性价比"一般比较低
				在堆中，由其是在新生代常规应用进行一次GC一般可以回收70%～95%的空间，而方法区的GC效率远小与此
				当前的商业JVM都有实现方法区的GC，主要回收两部分内容:废弃常量与无用类
				类回收需要满足如下3个条件：
					该类所有的实例都已经被GC了，也就是JVM中不存在该Class的任何实例
					加载该类的ClassLoader已经被GC
					该类对应的java.lang.Class对象都没有在任何地方被引用，比如不能在任何地方通过反射访问该类的方法
			 在大量使用反射，动态代理，CGLib等字节码框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要JVM具备类卸载的支持以保证方法区不会溢出

		GC算法
			-标记-清除算法 Mark-Sweep
				算法分为“标记”和“清除”两个阶段，首先标记出所有要回收的对象，然后再回收这些对象，如图：56_标记清除算法演示图
				两个缺点：
					效率低，标记和清理两个过程效率都不高，由于要扫描所有对象。堆越大，GC越慢
					空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次垃圾搜集动作，GC次数越多，碎片越严重

			-标记-整理算法 Mark-Compact	
			 	标记过程仍然一样，但是后续步骤不是进行直接清理，而是另所有存活的对象向一端移动，然后直接清理掉这端边界以外的内存
				特点：
					没有内存碎片
					比标记清除算法耗费更多时间进行整理
				

			-复制搜集算法 Copying
                                -将可用内存划分为两块，每次只使用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块上面，然后就把原来整块内存空间一次性清理掉
                                 这样使得每次内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了。
                                 优点：实现简单，运行高效
                                 缺点：内存相当于缩小了原来的一半，代价高昂
				 如图：56_复制搜集算法演示图

				-在现在的商业虚拟机中都是用了这种收集算法来回收新生代
				-将内存分为一块较大的eden空间和两块较少的survivor空间，每次使用eden和其中一块survivor，当回收时，将eden和survivor还存活的对象一次性拷贝到另一块survivor空间上
				 然后清理掉eden和用过的survivor
				-Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的

				-复制收集算法在对象存活率高的时候，效率有所下降
				 如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都是100%存活的极端情况，所以在老年代一般不能直接选用这种算法

				-特点：
					只需要扫描存活的对象，效率更高
					不会产生碎片
					需要浪费额外的内存作为复制区
					复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小。
					根据IBM的专门研究，98%的java对象只会存活1个GC周期，对这些对象很适合使用复制算法。而且不用1:1的划分工作区和复制区的空间
			-分代算法 Generational
				当前商业虚拟机的垃圾收集都是采用“分代收集”算法，根据对象不同的存活周期将内存划分为几块
				一般是把java堆分做新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，比如新生代每次GC都有大批对象死去，那就适合使用复制算法
				Hotspot JVM 6中共划分为3代，年轻代，老年代，永久代(8之后已经被抛弃)
		
				年轻代 young generation
					-新生成的对象都放在年轻代，年轻代用复制算法进行GC
					-年轻代分为三个区，一个Eden区，两个Survivor(可以通过修改参数设置Survivor个数)。对象在Eden区中生成，当这个Eden区满时还存活的对象将被复制到一个Survivor区域
					 当这个Survivor区满时，此区存活的对象将被复制到另外一个Survivor区，当第二个Survivor区也满的时候，从第一个Surivivor区复制过来的并且此时还存活的对象将被复制
					 到老年代。2个Survivor是完全对称的，轮流替换
					-Eden和2个Survivor的默认比例是8:1:1,也就是10%的空间会被浪费。可以根据GC log的信息调整大小的比例

				老年代 old generation
					-存放了经过一次或多次GC还存活的对象
					-一般采用Mark-Sweep或者 Mark-Compac算法进行GC
					-有多种垃圾回收器可以选择。每种垃圾收集器都可以看作一个GC算法的具体实现。可以根据具体应用的需求选用合适的垃圾收集器(追求吞吐量? 追求最短的响应时间)
				
				内存结构如图：56_内存结构,jdk8之后 -Xss默认是160k
				内存分配：
					-堆上分配：大多数情况在eden上分配，偶尔会直接在old上分配，细节取决于GC实现
					-栈上分配：原子类型的局部变量
				内存回收：
					GC要做的是将哪些dead的对象所栈用的内存回收掉
					hotspot认为没有引用的对象是dead的
					hotspot将引用分为4种
						Strong即默认通过Object o = new Object()这种方式赋值的引用
						soft软引用， weak弱引用 phantom虚引用 这三种则都是继承
					在Full GC时会对Reference类型的引用进行特殊处理
						Soft : 内存不够时一定会被GC，长期不用也会被GC
						Weak ：一定会被GC，当mark为dead,会在ReferenceQueue种通知
						Phantom: 本来就没引用，当从jvm heap种释放时会通知	
				
				GC的时机，在分代模型的基础上，GC从时机上分为两种：
					-Scavenge GC (Minor GC)
					 触发时机：新对象生成时，Eden空间满了
                                         理论上Eden区大多数对象会在Scavenge GC回收，复制算法的执行效率会更高，Scavenge GC时间比较短。
					-Full GC
					 对整个jvm进行整理包括 young,old 和 perm(永久代)
					 主要触发时机:1、Old满了；2、Perm满了；3）system.gc()
					 效率很低，尽量减少Full GC。
				
	 	垃圾回收器的实现和选择
			-综合前面几种GC算法的优缺点，针对不同生命周期的对象采用不同的GC算法，比如新生代用复制算方法，老年代用标记清除或者标记整理算法
			
			-分代模型:GC的宏观愿景
			 垃圾回收器：GC的具体实现
			 Hotspot jvm提供多种垃圾回收器，我们需要根据具体应用的需要采用不同的回收器
			 没有万能的垃圾回收器，每种垃圾回收器都有自己的适用场景

			-垃圾收集器的并行和并发
				并行Parallel:指多个收集器的线程同时工作，但是用户线程处与等待状态
				并发Concurrent：指收集器在工作的同时，可以允许用户线程工作
						并发不代表解决了GC停顿的问题，在关键的步骤还是要停顿的。比如在收集器标记垃圾的时候。但在清除垃圾的时候，用户线程可以和GC线程并发执行。
			
			-垃圾收集器算法如图：56_垃圾收集器算法
			-serial收集器：
				单线程收集器，收集时，会暂停所有工作线程(Stop The Wrold STW)，使用复制收集算法，虚拟机运行在Client模式时的默认新生代收集器	
				最早的收集器单线程进行GC
				New和Old Generation都可以使用
				在新生代，采用复制算法；在老年代采用标记整理算方法
				因为是单线程GC,没有多线程切换的额外开销，简单实用
				Hotspot JVM模式缺省的收集器
				如图：56_serial收集器示意图

			-ParNew收集器
				ParNew收集器就是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Serial收集器一模一样
				对应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial收集器有更好的效果
				
				总结：
					-Serial收集器在新生代的多线程版本
					-使用复制算法（因为针对的是新生代）
					-只有在多CPU的环境下，效率才会比Serial收集器高
   					-可以通过 -XX:ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数
					-Server模式下新生代的默认收集器

			-Parallel Scavenge收集器
				它是一个多线程的收集器，也是使用复制算法，但他的对象分配规则与回收策略都与ParNew收集器由所不同
				它是以吞吐量最大化(即GC时间占总运行时间最小)为目标的收集器实现
				它允许较长时间的STW换取总吞吐量最大化

			-Serial Old收集器
				它是单线程收集器，使用标记整理算法，是老年代的收集器

			-Parallel Old收集器
				老年代版本吞吐量优先收集器，使用多线程和标记-整理算法，JVM1.6提供，在此之前，新生代使用了 Parallel Scavenge收集器的话，老年代除了Serial Old外别无选择
				因为Parallel Scavenge无法与CMS收集器配合工作

				如图：56_Parallel Old收集器示意图
				特点：
					-PS在老年代的实现
					-在JVM1.6才出现 Parallel Old
					-采用多线程，标记-整理算法
					-更注重吞吐量
					-Parallel Scavenge + Parallel Old = 高吞吐量，单GC停顿可能不理想
			-CMS (Concurrent Mark Sweep)
				-CMS是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高(总体GC时间最小)，但它能尽可能降低GC时服务的停顿时间
				 CMS收集器使用的是标记-清除算法
				-由于实现非常复杂，一度Oracle差点废除这个收集器
				-特点：
					追求最短停顿时间，非常适合Web应用
					只针对老年区，一般结合ParNew使用
					Concurrent,GC线程和用户线程并发工作(尽量并发)
					Mark-Sweep
					只有在多CPU环境下才有意义
					使用 -XX:UseConcMarkSweepGC打开
				-缺点：
					CMS以牺牲CPU资源的代价减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大
					CMS在并发清理的过程中，用户线程还在跑。这时候需要预留一部分空间给用户线程
					CMS用Mark-Sweep，会带来碎片问题。碎片过多的时候会容易频繁触发Full GC

		垃圾回收器的JVM参数定义：
			UseSerialGC:虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial + Serial Old的收集器组合进行内存回收
			UseParNewGC：打开此开关后，使用 ParNew + SerialOld的收集器组合进行内存回收
			UseConcMarkSweepGC：打开此开关后，使用ParNew + Serial Old 的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的备用收集器
			UseParallelGC：虚拟机运行在Server模式下的默认收集器，打开此开关后，使用Parallel Scavege + Serial Olc(PS MarkSweep)的收集器组合进行内存回收
			UseParallelOldGC：打开开关后，使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收
			SurvivorRatio：新生代中Eden区域与Survivor区域的容量比值，默认为8 ，代表 Eden:Survivor=8:1
			PretenureSizeThreshold:直接晋升到老年代的对象大小，设置这个参数后，大与这个参数的对象将直接在老年代分配
			MaxTenuringThreshold:晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就加1，当超过这个参数值时就进入老年代
			UseAdaptiveSizePolicy：动态调整java堆中各个区域的大小以及进入老年代的年龄
			HandlePromotionFailure：是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况
			ParallelGCThreads：设置并行GC时进行内存回收的线程数
			GCTimeRatio：GC时间占总时间的比率，默认值是99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效
			MaxGCPauseMillis:设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效
			CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发垃圾收集器。默认值为68%，仅在使用CMS收集器时生效
			UseCMSCompactAtFullCollection：使用CMS收集器在完成垃圾回收后是否要进行一次内存随便整理，仅在使用CMS收集器时生效
			CMSFullGCsBeforeCompaction:设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效

57、java内存泄漏经典原因分析
	-对象定义在错误的范围(Wrong Scope)
		例：如果Fool实例对象的生命周期比较长，会导致临时性内存泄漏（这里的names变量实际上只有临时作用）
			class Foo{
				private String[] name;
				public void doIt(int length){
					names = new String[length];
					populate(names);
					print(names);
				}
			}
		jvm喜欢生命周期短的对象这样做已经足够高效,把names从成员变量换成方法的局部变量
			class Foo{
				public void doIt(int length){
					names = new String[length];
					populate(names);
					print(names);
				}
			}		
		
	-异常(Exception)处理不当
		Connection conn = DriverManager.getConnection(url,name,passwd);
		try{
			String sql = "select * from table";
			PreparedStatement stmt = conn.prepareStatement(sql);
			ResultSet rs = stmt.executeQuery();
			while(rs.next()){
				doWork(rs);	
			}
			rs.close();
			stmt.close();
			conn.close();
		}catch(Exception e){
			//如果doWork()抛出异常，rs.colse ,stmt.close和conn.close不会被调用，导致内存泄漏和db连接泄漏
		}
		正确的做法是永远要把资源释放 rs.colse() stmt.close 和 conn.close放到finally中去

	-集合数据管理不当	
		当使用Array-based的数据结构（ArrayList , HashMap等）时，尽量减少resize
			比如： new ArrayList时，尽量估算size,在创建的时候把size确定
			减少resize可以避免没有必要的array copying,gc碎片等问题
		如果一个List只需要顺序访问，不需要随机访问(Random Access) ，用LinkedList代替ArrayList
			LinkList本质是链表，不需要resize，但只适用于顺序访问。 

58、垃圾回收日志与算法深度解读
	project/jvm_lecture项目 com.sandro.gc.Test1
	设置jvm启动参数：
		-verbose:gc //会输出虚拟机中详细的垃圾回收日志
		-Xms20M  //jvm启动时堆容量初始值20M
		-Xmx20M //jvm在运行时堆容量最大值20M，通过设置最小和最大值，能够保证垃圾回收时内存没有抖动
			//设置的小一些保证能够发生gc操作
		-Xmn10M //堆空间中新生代的大小是10M
		-XX:+PrintGCDetails //打印出垃圾回收的详细信息
		-XX:+SurvivorRatio=8,新生代 Eden和Survivor的比例是8:1，这样的话Eden是8 ，from Survivor是1，to Survivor也是1

	运行后日志如下：此时只有当前内存的占用情况，并没有发生GC
		Heap 
		 PSYoungGen      total 9216K, used 7833K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 95% used [0x00000000ff600000,0x00000000ffda6408,0x00000000ffe00000)
		  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
		 ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)
		 Metaspace       used 3098K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K	
	
	修改代码增大内存占用的空间到6.5M时候(需要不断尝试，不一定是多少),此时看到了只有GC操作的日志：
	        //GC (Allocation Failure) ：MinorGC日志（ScavengeGC）新对象生成时，Eden空间满了触发,Allocation Failure是触发的原因,分配失败
		//[PSYoungGen: 8192K->416K(9216K)]：Parallel Scavenge收集器中的新生代占据空间从8192k减少到416k，
						    总大小是9216k也就是9M，也就是Eden(8M)+一个Survivor的大小
		//8192K->416K(19456K), 0.0016629 secs : GC之前堆中对象的的大小(新生代+老年代)是8291K，
							GC之后堆中对象的大小减少到416K
							总的堆的容量是 19456k 也就是19M=新生代9M(有一个suriver不能使用所以不算) + 老年代10M
							此次gc总耗时0.0016629秒
		//[Times: user=0.01 sys=0.00, real=0.00 secs]：在用户空间用了0.01秒，内核空间是0.00秒，实际时间是0.00秒
		[GC (Allocation Failure) [PSYoungGen: 8192K->416K(9216K)] 8192K->416K(19456K), 0.0016629 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
		Heap//堆汇总信息
		 PSYoungGen      total 9216K, used 584K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 2% used [0x00000000ff600000,0x00000000ff62a248,0x00000000ffe00000)
		  from space 1024K, 40% used [0x00000000ffe00000,0x00000000ffe68000,0x00000000fff00000)
		  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		//ParOldGen:老年代，使用的垃圾收集器是Parallel Old收集器
		//老年代总大小是10M，GC后使用了0K
		//新生代释放后：共释放了8192-416 = 7776大小的空间
		//整个堆释放后，共释放了8192-416 - 7776大小的空间
		//因此此次GC没有晋升进入到老年代，如果新生代释放的比较多，整个堆释放的比较少，这时才会有对象晋升到老年代
		 ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)
		 Metaspace       used 3087K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 338K, capacity 388K, committed 512K, reserved 1048576K
	
	修改代码增大内存占用的空间到8M,看到GC操作的日志，此时看到了GC和FullGC的日志：
		[GC (Allocation Failure) [PSYoungGen: 7668K->480K(9216K)] 7668K->6632K(19456K), 0.0047084 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
		[Full GC (Ergonomics) //FullGC 发生了，原因是Ergonomics
			[PSYoungGen: 480K->0K(9216K)] 新生代垃圾又进一次回收，这时新生代完全回收了
			[ParOldGen: 6152K->6500K(10240K)] 6632K->6500K(19456K), 老年代垃圾回收，老年代此次回收不但没有减少反而增多了，原因是新生代的一部分对象被晋升了
										但是堆的总空间减少了(6632K->6500K)
			[Metaspace: 3073K->3073K(1056768K)], 元空间的垃圾回收,元空间回收的空间一般都很小
		0.0069378 secs] 
		[Times: user=0.01 sys=0.00, real=0.01 secs] 
		hello world
		Heap
		 PSYoungGen      total 9216K, used 2372K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 28% used [0x00000000ff600000,0x00000000ff851210,0x00000000ffe00000)
		  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
		  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		 ParOldGen       total 10240K, used 6500K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 63% used [0x00000000fec00000,0x00000000ff2590d0,0x00000000ff600000)
		 Metaspace       used 3098K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K

	修改代码增大内存占用的空间到10M也就是设置的新生代的最大的大小,看到GC操作的日志，此时没有发现Full GC
		[GC (Allocation Failure) [PSYoungGen: 5620K->512K(9216K)] 5620K->4616K(19456K), 0.0034860 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
		Heap
		 PSYoungGen      total 9216K, used 6894K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 77% used [0x00000000ff600000,0x00000000ffc3bb90,0x00000000ffe00000)
		  from space 1024K, 50% used [0x00000000ffe00000,0x00000000ffe80000,0x00000000fff00000)
		  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		 ParOldGen       total 10240K, used 4104K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff002020,0x00000000ff600000)
		 Metaspace       used 3099K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K
		原因分析：
			byte[] myAlloc1 = new byte[2*size];
		        byte[] myAlloc2 = new byte[2*size];
		        byte[] myAlloc3 = new byte[3*size];//这一部执行完，内存已经分配了7M
		        byte[] myAlloc4 = new byte[3*size];//这时Eden空间 + Survivor都用用完了，此时新的对象会晋升到老年代去诞生
			年轻代满了之后触发了GC，新的对象由于直接在老年代分配，所以没有再触发FullGC
			
	垃圾收集器 PSYoungGen + ParOldGen，说明再jdk1.8 种默认的垃圾收集器是 Parallel Scavenge + Parallel Old 组合	
	
59、阈值和垃圾收集器类型对于对象分配的影响
	project/jvm_lecture项目 com.sandro.gc.Test2
	
	输出以下当前虚拟机版本号和默认的启动参数：java -XX:+PrintCommandLineFlags -version
		-XX:InitialHeapSize=260552704   //初始的堆大小 (字节) 等价与 Xms
		-XX:MaxHeapSize=4168843264      //最大的堆大小(字节)等价于Xmx 
		-XX:+PrintCommandLineFlags      //打印jvm启动信息
		-XX:+UseCompressedClassPointers //启用指针压缩，这样可以节省空间
		-XX:+UseCompressedOops          //从32位jvm迁移到64位jvm的时候指针会经历一次膨胀，导致指针也会变大，那么jvm启动的时候也会占用更大的空间，
						//使用这个参数的时候，会对一些特定的指针进行压缩，尽量减少空间的占用
		-XX:+UseParallelGC 		//使用Parallel Scavenge + Parallel Old 的收集器组合进行内存回收
		java version "1.8.0_291"
		Java(TM) SE Runtime Environment (build 1.8.0_291-b10)
		Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)
	
	运行进程前，设置一下jvm启动参数
		-verbose:gc
		-Xms20M
		-Xmx20M
		-Xmn10M
		-XX:+PrintGCDetails
		-XX:SurvivorRatio=8
		-XX:PretenureSizeThreshold=4194304,当新创建的对象已经超过这个值(单位字节,这里是4M)的时候 ，被创建的对象直接到老年代去做内存的分配	
	运行后gc日志如下：
		Heap
		 PSYoungGen      total 9216K, used 6808K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 83% used [0x00000000ff600000,0x00000000ffca63e8,0x00000000ffe00000)
		  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
		 ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)
		 Metaspace       used 3098K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K
	
		案例中 byte数组大小是5M,PretenureSizeThreshold设置的是4M，案例中应该有1M的对象是要分配到老年代中的
		但是从日志中看到 此时ParOldGen used 0K,说明案例中分配的内存没有进入到老年代	
		原因：
			jvm中的很多参数是交织在一起的，比如A参数设置以后，才会使用B参数的值
			PretenureSizeThreshold必须搭配Serial收集器才会其作用，而当前默认的收集器是UseParallelGC 
			因此需要设置 使用-XX:+UseSerialGC 才可以，使用Serial + Serial Old的收集器组合进行内存回收
	
	重新设置了启动参数后，日志如下：
		Heap
		 def new generation   total 9216K, used 1688K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  eden space 8192K,  20% used [0x00000000fec00000, 0x00000000feda63d8, 0x00000000ff400000)
		  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)
		  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
		 tenured generation   total 10240K, used 5120K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		   the space 10240K,  50% used [0x00000000ff600000, 0x00000000ffb00010, 0x00000000ffb00200, 0x0000000100000000)
		 Metaspace       used 3062K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 335K, capacity 388K, committed 512K, reserved 1048576K		
	此时新生代的垃圾收集器变成了 def new generation,老年代的垃圾收集器变成了 tenured generation
	在老年代里直接创建了5120K的对象，说明PretenureSizeThreshold起作用了
	byte[] myAlloc = new byte[5*size]; //myAlloc在创建的时候就确定了必须一次性创建5M的连续空间的内存
	
	案例二，将myAlloc对象的大小设置为8M，还是使用默认PS垃圾收集器(把UseSerialGC删掉就行)
	GC日志：
		Heap
		 PSYoungGen      total 9216K, used 1688K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 20% used [0x00000000ff600000,0x00000000ff7a63d8,0x00000000ffe00000)
		  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
		 ParOldGen       total 10240K, used 8192K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 80% used [0x00000000fec00000,0x00000000ff400010,0x00000000ff600000)
		 Metaspace       used 3099K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K
	此时由于对象创建需要8M空间，eden容纳不下，所以直接在老年代中创建了。所以一个对象的内存创建不会出现一部分在新生代，一部分在老年代这种情况
	
	案例三：将myAlloc对象的大小设置为10M
		[GC (Allocation Failure) [PSYoungGen: 1524K->400K(9216K)] 1524K->400K(19456K), 0.0014334 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[GC (Allocation Failure) [PSYoungGen: 400K->368K(9216K)] 400K->368K(19456K), 0.0010503 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[Full GC (Allocation Failure) [PSYoungGen: 368K->0K(9216K)] [ParOldGen: 0K->355K(10240K)] 368K->355K(19456K), [Metaspace: 3051K->3051K(1056768K)], 0.0044725 secs] 
			[Times: user=0.00 sys=0.00, real=0.01 secs] 
		[GC (Allocation Failure) [PSYoungGen: 0K->0K(9216K)] 355K->355K(19456K), 0.0006438 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(9216K)] [ParOldGen: 355K->337K(10240K)] 355K->337K(19456K), [Metaspace: 3051K->3051K(1056768K)], 0.0038796 secs] 
			[Times: user=0.01 sys=0.00, real=0.01 secs] 
		Heap
		 PSYoungGen      total 9216K, used 410K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 5% used [0x00000000ff600000,0x00000000ff666800,0x00000000ffe00000)
		  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
		  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		 ParOldGen       total 10240K, used 337K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 3% used [0x00000000fec00000,0x00000000fec54718,0x00000000ff600000)
		 Metaspace       used 3088K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 338K, capacity 388K, committed 512K, reserved 1048576K
		Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
			at com.sandro.gc.Test2.main(Test2.java:7)
	此时出现了内存溢出的情况，可以看到在溢出前，gc做了多次的尝试，也做了多次的FullGC的尝试，最终才程序异常	
	
	案例四：将myAlloc对象的大小设置为5M，同时增加-XX:+UseSerialGC 设置使用serial垃圾收集器
		为了使用工具查看内存，增加一个Thread.sleep，保证程序不会立刻死掉

		运行jvisualvm查看进程
		进程参数：
			-verbose:gc
			-Xms20M
			-Xmx20M
			-Xmn10M
			-XX:+PrintGCDetails
			-XX:SurvivorRatio=8
			-XX:PretenureSizeThreshold=4194304
			-XX:+UseSerialGC
			-javaagent:/home/sandro/software/idea-IC-223.8617.56/lib/idea_rt.jar=34625:/home/sandro/software/idea-IC-223.8617.56/bin
			-Dfile.encoding=UTF-8
		在启动工具的时候发现 有GClog日志出现，原因是工具往往使用attch进行的方式监控进程，这样有可能会导致内存不够的情况因此出现了gc操作
		在GC的时候在工具的监控中 可以看到堆内存有个较大的减少，也可以手动在工具中点击“执行垃圾回收”的操作，可以也可以看到内存有较大减少的情况，同时看到GC日志中出现了Full GC的log
		[Full GC (System.gc())],说明此次垃圾回收是 System.gc()触发的
		除了System.gc(),jvm只有在创建对象的时候才会进行垃圾回收。
		System.gc()调用以后，也不是立刻执行垃圾回收，而是由jvm选择一个合适的时间点才去执行
		
		运行jmc查看进程：
			在内存视图页面 可以看到Eden Space ,Survivor Space ,Tenured Space，具体的实时情况
			可以看到当Eden Space满了以后会立刻执行GC，同时内存会有一个较大的减少
			运行JFR(飞行记录器)
				在内存->堆视图中也可以更直观的看到堆在GC时的变化和数据
				在内存->分配中可以看到TLAB分配
					TLAB 分配概念: TLAB,全称Thread Local Allocation Buffer, 即:线程本地分配缓存。这是一块线程专用的内存分配区域。TLAB占用的是eden区的空间。
		
		运行 jcmd <pid> VM.flags，查看当前进程的启动参数:
			-XX:CICompilerCount=3 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 
			-XX:MinHeapDeltaBytes=196608 
			-XX:NewSize=10485760 //新生代的大小
			-XX:OldSize=10485760 //老年代的大小
			-XX:PretenureSizeThreshold=4194304 -XX:+PrintGC 
			-XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseSerialGC 

60、本地线程分配缓冲——TLAB
	-TLAB是虚拟机在堆内存的划分出来的一块专用空间，是线程专属的。
	-在TLAB启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，
	 这样就不存在竞争的情况，可以大大提升分配效率。		

	-这里说线程独享的堆内存，只是在“内存分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。即是指其他线程可以在这个区域读取、操作数据，但是无法在这个区域中分配内存。

	-TLAB 生命周期
		在分代收集的垃圾回收器中，TLAB是在eden区分配的。TLAB 是从堆上 Eden 区的分配的一块线程本地私有内存。
		线程初始化的时候，如果 JVM 启用了 TLAB（默认是启用的， 可以通过 -XX:-UseTLAB 关闭），则会创建并初始化 TLAB。
		同时，在 GC 扫描对象发生之后，线程第一次尝试分配对象的时候，也会创建并初始化 TLAB。
		
		在 TLAB 已经满了或者接近于满了的时候，TLAB 可能会被释放回 Eden。GC 扫描对象发生时，TLAB 会被释放回 Eden。
		TLAB 的生命周期只存在于一个 GC 扫描周期内。在 JVM 中，一个 GC 扫描周期，就是一个epoch。那么，可以知道，TLAB 内分配内存一定是线性分配的。

	-TLAB的大小,如图：60_TLAB的大小
		TLAB的初始大小可由参数-XX:TLABSize指定，若指定了TLAB的值，TLAB初始大小就是TLABSize。否则，TLAB大小为分配线程的平均值。

		TLAB 的大小的最小值：通过MinTLABSize指定
		TLAB 的大小的最大值：不同GC中有不同的最大值。例如G1 GC中，TLAB的最大值为大对象的大小，即是Region的一半；ZGC中的最大值为１／８的Region，
				     在大部分情况下 Shenandoah GC 也是每个 Region 大小的 8 分之一。对于其他的 GC，则是 int 数组的最大大小。
		
		TLAB空间大小的动态调整：-XX:ResizeTLAB
			resize开关是默认开启的，JVM可以对TLAB空间大小进行调整。

	-对象的慢分配
		当TLAB内存充足时，分配新对象的方式称为快分配。当TLAB内存不足，分配新对象的方式称为“慢分配”。
		慢分配有两种处理方式：
			当TLAB剩余内存空间小于TLAB最大浪费空间时，丢弃当前 TLAB 回归 Eden，线程获取新的 TLAB 分配对象
			当TLAB剩余内存空间大于TLAB最大浪费空间时，对象直接在Eden区分配内存

	-TLAB最大浪费空间
		最大浪费空间是一个动态值，TLAB最大浪费空间初始值＝TLAB大小／TLABRefillWasteFraction。TLABRefillWasteFraction默认为64，所以TLAB最大浪费空间初始值为TLAB大小的1/64。
		伴随着每次慢分配，这个TLAB最大浪费空间会每次递增 TLABWasteIncrement 大小的空间。

	-TLAB流程总结，如图：60_TLAB流程总结
	-参数总结：
		UseTLAB	是否启用 TLAB，默认是启用的。
		ResizeTLAB	TLAB 是否是自适应可变的，默认为是
		TLABSize	初始 TLAB 大小，单位是字节 。默认为0，0 就是不主动设置 TLAB 初始大小，而是通过 JVM 自己计算每一个线程的初始大小。例如：-XX:TLABSize=65536
		MinTLABSize	最小 TLAB 大小。单位是字节，默认2048。例如-XX:MinTLABSize=4096
		TLABRefillWasteFraction	在一次 TLAB 再填充（refill）发生的时候，最大的 TLAB 浪费。默认为64，和TLAB最大浪费空间有关 。TLAB最大浪费空间= TLAB大小/TLABRefillWasteFraction
		TLABWasteIncrement	TLAB 慢分配时允许的 TLAB 浪费增量
	
61、MaxTenuringThreshold与阈值动态调整
	project/jvm_lecture项目 com.sandro.gc.Test3

	vm运行参数：
 		-verbose:gc
 		-Xms20M
 		-Xmx20M
 		-Xmn10M
 		-XX:+PrintGCDetails
 		-XX:+PrintCommandLineFlags  //在jvm启动的时候 输出jvm启动参数
		-XX:+SurvivorRatio=8
		-XX:MaxTenuringThreshold=5  //设置可以晋升到老年代的最大年龄
					    //当一个对象在新生代每经历过一次Minor GC后，对象年龄就会+1，设置MaxTenuringThreshold=5，是让对象年龄>5后晋升到老年代
					    //这个值是理论上的最大值，对象晋升的实际年龄也可能<5,因为对象晋升的年龄jvm也会自动调节，但是绝对不会>5还不晋升。
					    //该设置的默认值是15，在CMS中默认是6，G1中默认为15(在jvm中，该数值是由4个bit来表示的，所以最大值是1111也就是15)
					    //经历了多次GC后，新生代存活的对象会在from survivor 与 to survivor之间存放，而这里面的前提是这两个空间有足够的大小来存放这些数据
					    //在GC算法中会计算每个对象年龄的大小，如果达到某个年龄后发现总大小已经大于了survivor空间的50%，
					    //那么这时候就需要调整阈值，不能再继续等到默认的15次GC后才完成晋升
				            //因为这样会导致surivivor空间不足，调整阈值是为了让这些存活对象尽快完成晋升
		-XX:+PrintTenuringDistribution //打印年龄信息

	运行后日志：
		//启动参数
		-XX:InitialHeapSize=20971520 -XX:InitialTenuringThreshold=5 -XX:MaxHeapSize=20971520 
		-XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=5 -XX:NewSize=10485760 
		-XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintTenuringDistribution 
		-XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC 
		
		[GC (Allocation Failure) 
		Desired survivor size 1048576 bytes, new threshold 5 (max 5) //当前最大对象年龄是5，new threshold，这个是动态计算的值是5，随着运行时间越来越就，这个值可能会小与5
									     //Desird survivor size  是1M
		[PSYoungGen: 7668K->464K(9216K)] 7668K->6608K(19456K), 0.0044398 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
		[Full GC (Ergonomics) [PSYoungGen: 464K->0K(9216K)] 
			[ParOldGen: 6144K->6524K(10240K)] 6608K->6524K(19456K), [Metaspace: 3093K->3093K(1056768K)], 0.0047949 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
		Heap
		 PSYoungGen      total 9216K, used 2130K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		  eden space 8192K, 26% used [0x00000000ff600000,0x00000000ff814930,0x00000000ffe00000)
		  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
		  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
		 ParOldGen       total 10240K, used 6524K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  object space 10240K, 63% used [0x00000000fec00000,0x00000000ff25f328,0x00000000ff600000)
		 Metaspace       used 3100K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K
		
	project/jvm_lecture项目 com.sandro.gc.Test4
	这个案例演示了对象从新生代晋升到老年代年龄阈值动态调整的过程
	运行参数：
		-verbose:gc
		-Xmx200M
		-Xmn50M
		-XX:TargetSurvivorRatio=60 ，当某一个survivor的空间被占据了60%，就需要重新计算对象晋升的阈值，而不是默认或者设置的值
		-XX:+PrintTenuringDistribution
		-XX:+PrintGCDetails
		-XX:+PrintGCDateStamps ,打印GC发生的时间戳
		-XX:+UseConcMarkSweepGC,使用 cms 垃圾回收器进行老年代垃圾回收
		-XX:+UseParNewGC,使用ParNew垃圾回收器进行新生代的垃圾回收
		-XX:MaxTenuringThreshold=3
	运行日志：
		//第一次垃圾回收，所需survivor是3M左右，超过3M就要重新设置阈值
		//3M是因为设置了xmn新生代50M，由于默认Eden和Survivor比例是8:1,所以Eden是40M，survivor是5M，设置的TargetSurvivorRatio=60，所以达到3M的时候需要重新计算对象晋升阈值
		2023-08-29T23:00:57.913+0800: [GC (Allocation Failure) 2023-08-29T23:00:57.913+0800: [ParNew
		Desired survivor size 3145728 bytes, new threshold 3 (max 3)
		- age   1:    1532512 bytes,    1532512 total  年龄是1的对象大小
		: 40954K->1507K(46080K), 0.0027042 secs] 40954K->1507K(199680K), 0.0027637 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish1---------------
		//第二次垃圾回收
		2023-08-29T23:00:58.920+0800: [GC (Allocation Failure) 2023-08-29T23:00:58.920+0800: [ParNew
		Desired survivor size 3145728 bytes, new threshold 3 (max 3)
		- age   1:       1696 bytes,       1696 total
		- age   2:    1522336 bytes,    1524032 total //原来是1的变成了2
		: 42042K->1571K(46080K), 0.0011964 secs] 42042K->1571K(199680K), 0.0012525 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish2---------------
		//第三次垃圾回收
		2023-08-29T23:00:59.930+0800: [GC (Allocation Failure) 2023-08-29T23:00:59.930+0800: [ParNew
		Desired survivor size 3145728 bytes, new threshold 3 (max 3)
		- age   1:     342280 bytes,     342280 total
		- age   2:       1696 bytes,     343976 total
		- age   3:    1521168 bytes,    1865144 total
		: 42118K->1967K(46080K), 0.0011513 secs] 42118K->1967K(199680K), 0.0011908 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish3---------------
		//第四次垃圾回收，此时之前年龄是3的对象被晋升到了老年代
		2023-08-29T23:00:59.935+0800: [GC (Allocation Failure) 2023-08-29T23:00:59.935+0800: [ParNew
		Desired survivor size 3145728 bytes, new threshold 3 (max 3)
		- age   1:         88 bytes,         88 total
		- age   2:     341816 bytes,     341904 total
		- age   3:       1696 bytes,     343600 total
		: 42681K->769K(46080K), 0.0022618 secs] 42681K->2267K(199680K), 0.0023072 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish4---------------
		//第五次垃圾回收，此时定义了3个1M的数组，暂时无法释放
		//因为一次性加了3M数据达到了之前的阈值设定，所以此时重新调整最大对象晋升年龄，这个时候jvm从3调整到了1
		2023-08-29T23:00:59.941+0800: [GC (Allocation Failure) 2023-08-29T23:00:59.941+0800: [ParNew
		Desired survivor size 3145728 bytes, new threshold 1 (max 3)
		- age   1:    3145864 bytes,    3145864 total
		- age   2:         88 bytes,    3145952 total
		- age   3:     341816 bytes,    3487768 total
		: 41492K->3488K(46080K), 0.0024113 secs] 42990K->4987K(199680K), 0.0024590 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
		finish5---------------
		//第6次垃圾回收，由于对象晋升年龄被重新调整到1，所以此时年龄>1的对象都放到了老年代
		2023-08-29T23:01:00.952+0800: [GC (Allocation Failure) 2023-08-29T23:01:00.952+0800: [ParNew
		Desired survivor size 3145728 bytes, new threshold 3 (max 3)
		- age   1:         88 bytes,         88 total
		: 44217K->77K(46080K), 0.0033390 secs] 45716K->4983K(199680K), 0.0033844 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish6---------------
		finish all------------
		Heap
		 par new generation   total 46080K, used 17053K [0x00000000f3800000, 0x00000000f6a00000, 0x00000000f6a00000)
		  eden space 40960K,  41% used [0x00000000f3800000, 0x00000000f4894028, 0x00000000f6000000)
		  from space 5120K,   1% used [0x00000000f6000000, 0x00000000f60135f0, 0x00000000f6500000)
		  to   space 5120K,   0% used [0x00000000f6500000, 0x00000000f6500000, 0x00000000f6a00000)
		 //老年代的数据达到了4M多
		 concurrent mark-sweep generation total 153600K, used 4905K [0x00000000f6a00000, 0x0000000100000000, 0x0000000100000000)
		 Metaspace       used 3606K, capacity 4536K, committed 4864K, reserved 1056768K
		  class space    used 399K, capacity 428K, committed 512K, reserved 1048576K
		
62、CMS垃圾收集器
	CMS- Concurrent Mark Sweep,以获取最短回收停顿时间为目标，多数应用于互联网站或者B/S系统的服务器端上。
	     在一定程度上CMS的GC线程可以和用户线程并发执行，最小的STW
	     
	CMS是基于“标记-清除”算法实现的，整个过程分为4个步骤：
		初始标记 (CMS inital mark)
		并发标记 (CMS concurrent mark)
		重新标记 (CMS remark)
		并发清除 (CMS concurrent sweep)
	
		其中初始标记和重新标记依然需要“Stop The Wrold”
		初始标记只是标记一下GCRoot能直接关联到的对象，速度很快；并发标记阶段就是进行GC Roots Tracing的过程；
		重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短

	CMS收集器的运作如图-62_CMS垃圾收集器,在整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以于用户线程一起工作，因此从总体上看，CMS收集器的内存回收过程时与用户线程一起并发执行的
	
	优点：并发收集，停顿低，Oracle官网称之为低停顿收集器(Concurrent Low Pause Collector)
	      CMS通过将大量工作分散到并发处理阶段来减少STW时间，在这块做的非常优秀

	缺点：
		-CMS收集器对CPU资源非常敏感
		-CMS收集器无法处理浮动垃圾（Floating Garbage，在之前判定某一个对象不是垃圾，但是之后又被用户线程设置成为了垃圾的对象，这种对象只能在下一次回收），
		 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，这个时候一般会使用serial old收集器。
		 如果在应用中老年代增长不是太快，可以时当调高参数-XX:CMSInitiationgOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获得更好的性能。
		 要是CMS运行期间预留的内存无法满足程序需要时，虚拟机将会启动备用方案：临时启用Serial Old收集器来重新进行老年代的垃圾回收，这样停顿时间就很长了。
		 所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。
		-收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行Full GC
		 CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关的参数（默认就是开启的），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的
		 空间碎片没有了，但停顿时间不得不变长。
		-对于堆比较大的应用，GC的时间难以预估
	
	空间分配担保：
		在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立那么 Minor GC可以确保是安全的。
		当大量对象在Minor GC后仍然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接移动到老年代。
		如果老年代判断到剩余空间不足（根据以往每一次回收晋升到老年代对象容量的平均值作为经验值），则进行一次Full GC

	CMS收集器也可以细分为7个详细步骤：
		Initial Mark 初始标记
			会stop the world，这个阶段的目标是标记哪些直接被GC引用或者被年轻代存活对象所引用的所有对象,如图：62_Initial Mark 初始标记

		Concurrent Mark 并发标记
			-在这个阶段GC会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到的GC Roots遍历查找。并发标记阶段，它会与用户的应用程序并发运行。
			 并不是老年代所有的存活对象都会标记，因为在标记期间用户的程序可能会改变一些引用
			-如图：62_Concurrent Mark 并发标记，与阶段1的图进行对比，就会发现有一个对象的引用已经发生了变化
				
		Concurrent Preclean 并发预清理
			-这也是一个并发阶段，与应用线程并发运行，并不会STW。在并发运行的过程中，一些对象的引用可能会发生变化。
			 但是这种情况发生时，JVM会将包含这个对象的区域(Card)标记为Dirty，这也就是Card Marking
			-在pre-clean阶段，那些能够从Dirty对象到达的对象也会被标记，这个标记做完之后，dirty card表就就会被清除了
			-如图：62_Concurrent Preclean 并发预清理
			
		Concurrent Abortable Preclean 并发可失败的预先清理
			这也是一个并发阶段，但是同样不会影响用户线程，这个阶段是为了尽量承担STW中最终标记阶段的工作。
			这个阶段持续时间依赖许多因素，这个阶段是在重复做很多相同的工作，直接满足一些条件（比如：重复迭代的次数、完成的工作量或者时钟时间等）

		Final Remark 最终的重新标记
			-这个阶段是第二个STW阶段，也是CMS中的最后一个，这个阶段的目标是标记老年代所有的存活对象。
			 由于之前的阶段是并发执行的，gc线程可能跟不上应用线程的变化，为了完成标记老年代所有存活对象的目标，STW就非常有必要了。

			-通常CMS的Final Remark阶段会在年轻代尽可能干净的时候运行，目的是为了减少连续STW发生的可能性(年轻代存活对象过多的话，也会导致老年代涉及的存活对象很多)
			 这个阶段比前面的几个阶段更复杂一些

			-经历了前5个阶段后，老年代所有存活的对象都被标记过了，标记阶段完成。后面的阶段是通过清除算法清理那些老年代不再使用的对象

		Concurrent Sweep 并发清除
			这里不需要STW，它与用户线程并发运行，这个阶段是：清除那些不再使用的对象，回收他们的占用空间来为将来使用
			如图：62_Concurrent Sweep 并发清除

		Concurrent Reset 并发重置
			这个阶段也是并发执行的，它会重设CMS内部的数据结构，位下次GC做准备

		concurrent都代表并发执行，不会stop the world
		
	
63、CMS垃圾收集器实例分析
	project/jvm_lecture项目 com.sandro.gc.Test5
	运行参数：
		-verbose:gc
                -Xms20M
                -Xmx20M
                -Xmn10M
                -XX:+PrintGCDetails
                -XX:SurvivorRatio=8
		-XX:+UseConcMarkSweepGC //使用cms进行老年代垃圾回收

	运行结果：
		//第一次申请4M空间，没有触发GC
		finish1---------------
		//第二次申请4M空间 ，此时一共申请了8M内存，而Eden目前一共只有8M,因此Minor GC 发生
		//新生代此时使用的是ParNew垃圾收集器，新生代的内存大幅减少，因为都晋升到老年代了
		[GC (Allocation Failure) [ParNew: 5620K->397K(9216K), 0.0236590 secs] 5620K->4495K(19456K), 0.0237252 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
		finish2---------------
		//第三次又申请了4M内存，系统再次触发了Minor GC
		[GC (Allocation Failure) [ParNew: 4649K->594K(9216K), 0.0074808 secs] 8747K->8790K(19456K), 0.0075096 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
		//老年代也发生了垃圾收集，当前占用了8196k,老年代总大小10240k
		[GC (CMS Initial Mark) [1 CMS-initial-mark: 8196K(10240K)] 12886K(19456K), 0.0015382 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[CMS-concurrent-mark-start]
		[CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[CMS-concurrent-preclean-start]
		[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[CMS-concurrent-abortable-preclean-start]
		[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[GC (CMS Final Remark) [YG occupancy: 4690 K (9216 K)]//年轻代大小
			[Rescan (parallel) , 0.0008620 secs] //重新扫描
			[weak refs processing, 0.0000081 secs]//弱引用扫描
			[class unloading, 0.0002519 secs]//类的卸载
			[scrub symbol table, 0.0004190 secs]//符号表处理
			[scrub string table, 0.0001793 secs]//字符串表处理
			[1 CMS-remark: 8196K(10240K)] 12886K(19456K), 0.0017944 secs] 
			[Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish3---------------
		[CMS-concurrent-sweep-start] //此时用户线程和GC线程的CMS垃圾回收器并发进行，CMS继续后面的两个步骤
		[CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		[CMS-concurrent-reset-start]
		[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
		finish4---------------
		Heap
		 par new generation   total 9216K, used 7060K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
		  eden space 8192K,  78% used [0x00000000fec00000, 0x00000000ff2505e8, 0x00000000ff400000)
		  from space 1024K,  58% used [0x00000000ff400000, 0x00000000ff494b10, 0x00000000ff500000)
		  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)
		 concurrent mark-sweep generation total 10240K, used 8196K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
		 Metaspace       used 3099K, capacity 4496K, committed 4864K, reserved 1056768K
		  class space    used 340K, capacity 388K, committed 512K, reserved 1048576K

64、G1垃圾收集器设计目标
	Garbage First Collector,最早是出现在jdk6的某一个小版本中，直译就是垃圾优先的收集器
	
	评价系统的两个重要的指标是吞吐量、响应能力
	-吞吐量
		吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量
		如下方式来衡量一个系统吞吐量的好坏：
			在一小时内同一事务（或者任务，请求）完成的次数(tps)
			数据库一小时可以完成多少查询(qps)
		对于关注吞吐量的系统，卡顿(Stop The World)是可以接受的，因为这个系统关注长时间的大量任务的执行能力，而单次快速的相应并不值得考虑。
	
	-响应能力
		响应能力指的是一个程序或者系统对请求是否能够及时响应，比如一个桌面UI能多快的响应一个事件，一个网站能够多快返回一个页面请求，数据库能够多快返回查询的数据
		对于这类对响应能力敏感的场景，长时间的停顿是无法接受的

	-G1 Garbage Collector
		g1收集器是一个面向服务端的垃圾收集器，适用于多核处理器，大内存容量的服务系统。
		它满足短时间gc停顿的同时达到一个较高的吞吐量
		jdk7以上版本适用

	-G1垃圾收集器的设计目标
		与应用线程同时工作，几乎不需要stop the world(与CMS类似)
		整理剩余空间，不产生内存碎片(CMS只能在Full GC时，用stop the world 整理内存碎片)
		GC停顿更加可控
		不牺牲系统的吞吐量
		gc不需要额外的内存空间(CMS需要预留空间存储浮动垃圾)
		

	-G1的设计规划是要替换掉CMS
		G1在某些方面弥补了CMS的不足，比如，CMS适用的是标记-清理算法，自然会产生内存碎片，而G1是基于Copying算法，高效的整理剩余内存，而不需要管理内存碎片
		另外，G1提供了更多手段，以达到对GC停顿事件的可控

		目前对于响应要求更高但是对吞吐量没有太大要求的服务器，CMS更好一点

65、G1垃圾收集器内存划分与角色分派
	官网地址：https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html

	Hotspot虚拟机主要构成，如图：65_Hotspot虚拟机主要构成
	
	传统垃圾收集器堆结构，如图：65_传统垃圾收集器堆结构

	G1垃圾收集器结构，如图：65_G1垃圾收集器结构
		-heap被划分为一个个相等的不连续的内存区域(regions),每个region都有一个分代的角色:eden,survivor,old
		-对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化
		-G1最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域(region)
		-G1使用了gc停顿可预测的模型，来满足用户设定的gc停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，一次清除多少个region
		-G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存(region算法)	
	
	G1 vs CMS
		-对比适用标记清除的CMS，G1适用的是copying算法不会造成内存碎片
		-对比Parallel Scavenge(基于copying)、Parallel Old收集器(基于标记整理算法)，Parallel会对整个区域做整理导致gc停顿会比较长，而G1只是特定的整理几个region
		-G1并非是一个实时的收集器，与parallel scavenge一样，对gc停顿时间的设置并不绝对生效，只是g1有较高的几率保证不超过设定的gc停顿时间
		 与之前的GC收集器对比，G1会根据用户设定的gc停顿时间，智能评估哪几个region需要被回收可以满足用户的设定。
	
	G1的重要概念：
		-分区(region)：G1采取了不同的策略来解决并行、串性和CMS收集器的碎片、暂停时间不可控等问题——G1将整个堆分成相同大小的分区(region)。
			-每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某代。年轻代，幸存区，老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑
			-在物理上不需要连续，则带来了额外的好出——有的分区内垃圾对象特别多，有的分区内垃圾对象很少。G1会优先回收垃圾对象特别多的分区
		 	 这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即首先收集垃圾最多的分区
			-依然是新生代满了的时候，对整个新生代进行回收——整个新生代中的对象，要么被回收，要么晋升，至于新生代也采取了分区机制的原因，是因为这样根老年代策略统一方便调整代的大小
			-G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就实现了局部压缩
		
		-收集集合(CSet):
			一组可被回收的分区集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区来自eden空间、survivor空间、或者老年代。
		
		-已记忆集合(RSet):
			-RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-info结构（谁引用了我的对象）。
		 	 RSet的价值在与使得垃圾收集器不需要扫描整个堆去查找引用了当前分区对象的对象，只需要扫描RSet即可。如图：65_RSet
			-G1 GC是在point-out(指向外部)的card table之上再加了一层结构来构成points-into(指向内部) RSet——每个region会记录下到底哪些别的region有指向自己的指针，
			 而这些指针分别在哪个card范围
			-这个RSet其是是一个hash table,key是别的region的起始地址,value是一个集合，里面的元素是card table的index。举例来说，如果region A的RSet里有一项的key是region B,value
			 里index为1234的card,它的意思是RegionB的一个card里有引用指向region A，所以对region A来说该RSet记录是points-into关系；而card table仍然记录了points-out的关系。
		
		-Snapshot-At-The-Begining(SATB):
			SATB是G1 GC在并发标记阶段使用的增量式的标记算法
			并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区




