1、书籍和名人
	国内比较有名的人叫R大，比叫资深的java虚拟机专家，《深入理解java虚拟机》比较早期的书籍，比较经典
2、常用jvm工具
	jconsole:JDK自带的 jvm监控工具，通过jconsole可以查看各进程的 内存，线程,cpu等运行信息
	jvisualvm:oracle自带的集成工具，类似jconsole工具，功能更全面
	jmap:java命令行工具，能够打印给定的java进程，核心文件内存信息，jmap可能在未来的JDK版本中删除
	
3、类加载器的深入理解与阶段分析
	3.1)类加载：class loading
	在java代码中，类型(class , interface ,枚举等)的加载、连接与初始化过程都是在程序运行期间完成的
	类加载提供了更大的灵活性，增加了更多的可能性，所以java虽然是静态的开发语言，但是依然能够完成动态语言的功能
	类型的加载最常见的方式将类文件从磁盘上加载到内存中去。

	3.2)类加载器(class loader):java中的每一个类型最终都会进入到内存当中，类加载器就是用来做这个工作的

	3.3)java虚拟机(程序)的生命周期，在如下几种情况下，java虚拟机将结束声明周期
		执行了System.exit()方法
		程序正常结束
		程序在执行过程中遇到了异常或者错误而异常终止，比如异常没有catch，那么当前异常会一直向上抛出，直到main方法。
		由于系统错误而导致java虚拟机进程终止
	
	3.4)类的加载、连接、与初始化
		加载：查找并加载类的二进制数据
		连接：
	             a)验证，确保被加载的类的正确性，避免二进制文件被恶意修改
		     b)准备，为类的静态变量分配内存，并将其初始化为默认值，注意在这个阶段，静态变量即使在代码中有赋值，但是这个阶段还只是默认值
		     c)解析，把类中的符号引用转换为直接引用
		           符号引用是一种间接的引用，比如System.out.println("aaa"),System out println这三部分就是符号引用，这个符号引用会被存贮在当前类的常量池中
			   在解析阶段虚拟机会把这个符号引用转化为直接引用，指向实际的内存地址
			   这个过程包括查找System类，out子段，println方法以及确定方法的参数和返回值等步骤
			   最终System.out.println("aaa")会被解析成一个指向实际输出流对象的地址，使得程序能够正常执行
		初始化：为类的静态变量赋予正确的初始值(在连接的准备阶段，静态变量只会被赋予默认值)
 	
	3.5)类的使用和卸载
		使用：类的字节码文件加载到内存后，就可以使用了
		卸载：类加载到内存后，是可以销毁的，销毁后的类就不能再使用了，比如不能再实例化对象等
		      比如osgi技术会动态卸载类
	
	3.6) java程序对类的使用方式分为：
		主动使用(7种):
			创建类的实例
			访问某个类或接口的静态变量(getstatic 助记符号)，或者对该静态变量赋值(putstatic 助记符)
			调用类的静态方法（invoke助记符）
			反射
			初始化一个类的子类,子类被初始化的时候，父类也会被初始化
			java虚拟机启动时被标明为启动类的类（有main方法的类）
			JDK1.7开始提供的动态语言支持(比如javascrpt)：java.lang.invoke.MethodHandle实例的解析结果 _getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则立刻初始化
		被动使用:
			除了以上7中主动使用，其他使用java类的方式都被当作是对类的被动使用，都不会导致类的初始化
	     所有的java虚拟机实现必须在每个类或接口被java程序“首次主动使用”时，才初始化他们。

	3.7）类的加载
		类的加载指的是将类的.class文件中二进制数据读如到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构
		规范中并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中
		
		加载.class文件的方式:
			从本地系统(磁盘)中直接加载
			通过网络下载.class文件
			从zip,jar等归档文件中加载.class文件
			从专有数据库中提取.class文件
			将java源文件动态编译为.class文件，比如动态代理(动态代理在编译器是不存在这个类的，只有在运行期在存在) jsp文件(jsp文件中可以嵌入java代码，jsp最终会转化为servlet)
	3.8) 类加载例子：
		源码见 project/jvm_lecture项目 com.sandro.classloader.Test1，com.sandro.classloader.Test2，com.sandro.classloader.Test3
		对于静态字段来说，只有直接定义了这个字段的类在首次主动使用的时候才会初始化，通过子类调用父类的静态字段，子类不会在首次主动使用的时候初始化
	
	        -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来
 	        比如在class根目录中运行:
	        ..../jvm_lecture/out/production/jvm_lecture$ java -XX:+TraceClassLoading com.sandro.classloader.Test1	
	   	
  	        输出如下：
			..... //jdk的一些类
			[Loaded com.sandro.classloader.Test1 from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]//进程主类
			.....//jdk的一些类
			[Loaded com.sandro.classloader.Test1$Parent from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
			[Loaded com.sandro.classloader.Test1$Child from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
   	
5、jvm参数
	一般jvm参数都是已 -XX:开头的
	一般写法有如下几种：
	5.1）布尔类型的设置
		-XX:+<option> ,表示开启 <option>选项，比如：java -XX:+TraceClassLoading com.xxx.xxx.MainClass
		-XX:-<option> ,表示关闭 <option>选项，jvm有些选项是默认开启的，如果在启动某个进程时候不想用某个已经开启的选项，可以通过"-"关闭
	5.2）赋值设置
		-XX:<option>=<value> 表示将option选项的值设置为value,如：-XX:SurvivorRatio=8,表示eden区与survivior区大小比例为8比1
	
4、常量的本质含义与反编译及助记符详解
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test3
	final修饰的字符串是常量，在编译阶段这个常量就已经保存在调用这个常量的方法所在类的常量池中了
			
	通过 javap -c com.sandro.classloader.Test3反编译
	如下：
		sandro@sandro-Lenovo-XiaoXin-V4000:~/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture$ javap -c com.sandro.classloader.Test3
		Compiled from "Test3.java"
		public class com.sandro.classloader.Test3 {
  			public com.sandro.classloader.Test3();
    				Code:
       					0: aload_0
       					1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       					4: return

  			public static void main(java.lang.String[]);
    				Code:
       					0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       					3: ldc           #4                  // String hello world
       					5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       					8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					11: bipush        567
      					13: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
      					16: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					19: new           #7                  // class java/lang/StringBuilder
      					22: dup
      					23: invokespecial #8                  // Method java/lang/StringBuilder."<init>":()V
      					26: ldc           #9                  // String list size is
      					28: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      					31: getstatic     #11                 // Field com/sandro/classloader/Test3$Parent.list:Ljava/util/List;
      					34: invokeinterface #12,  1           // InterfaceMethod java/util/List.size:()I
      					39: invokevirtual #13                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      					42: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      					45: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      					48: return

		}

	助记符：
	ldc : 表示将int,float 或者 String类型的常量值从常量池中推送置栈顶	
	bipush:表示将单字节(-128~127)的常量推送置栈顶，从测试结果看567也用的是bipush，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	sipush:表示将一个短整形常量值（-32768~32767）推送到栈顶，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	iconst_1:表示将int类型的数字1推送置栈顶，最多到iconst_5,也就是说jvm对int类型 -1～5单独设置了助记符, -1对应的助记符iconst_m1
	助记符的实现在rt.jar中，都有相应的源码可以查看，比如ldc bipush等就在com.sun.org.apache.bcel.internal.generic包下

5、编译期常量与运行期常量的区别
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test4 
	当一个常量的值如果不能在编译期间确定，那么其值就不会被放到调用类的常量池中
	这时在运行程序时，会导致主动使用这个常量所在的类，这个类就肯定会被初始化
	
6、数组创建本质分析
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test5
	对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.xxx.xxx
	动态生成的类型其父类是Object
	对于数组来说，JavaDoc经常构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。
	助记符：
		anewarray，表示创建一个引用类型的（如类，接口，数组）数组，并将其引用值压入栈顶
		newarray,表示创建一个指定的原始类型（如：int,char,short等）的数组，并将其引用压入栈顶

7、接口初始化规则
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test6
	接口中的属性都是public static final的，也就是一个常量，如果是确定的常量，则编译期间这个常量会保存在调用类中的常量池中
	如果常量是需要运行期间才能确定的，那么这个常量首次主动调用时，接口会被初始化，如果接口有父类，父类也会被初始化

8、类连接阶段和初始化阶段静态变量赋值顺序的例子
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test7
	初始化阶段是对静态变量赋值的阶段，赋值的顺序是按照代码从上到下的顺序执行的，因此如果书写不当，有可能造成意外情况。

9、类加载器深入解析及重要特性剖析
	1)进程启动顺序
		开始 		 
		 ⥥	     
	     是否装载APP ----否----> ClassLoader装载成功 -------否---------------> 抛出异常
                 ↓                           ↓                                        ↓
                 是                          ↓                                        ↓
                 ↓                           ↓                                        ↓   
	        连接<----------成功----------+			                      ↓
		 ↓                                                                    ↓
          初始化主入口的类---------------------------->调用主类.main()函数---------->结束
  
	2)
	        +--------------------------+
	开始--- |---> 验证--->准备---->解析|-->初始化--->实例化---->垃圾回收及对象终结--->结束	
		+--------------------------+
		加载：就是把二进制形式的java类读入java虚拟机中
		
		连接：验证，准备，解析
		
                初始化：为类的静态变量赋值
		
	        类的实例化：1)为新的对象分配内存，一般是在堆上分配
			    2)为实例变量赋默认值
			    3)为实例变量赋正确的初始值
			    4)java编译器会为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被成为“<init>”。针对源代码中的每一个类的构造方法，
			    java编译器都产生一个“<init>”方法
        
        3)类的加载
	 -类的加载的最终产品是位于内存中的Class对象
	 -Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口
	 -有两种类型的类加载器
		1)java虚拟机自带的加载器
		      -根类加载器(Bootstrap classloader),也叫启动类加载器
		      -扩展类加载器(Extension classloader)
		      -系统(应用)类加载器(System/app classloader)
                2)用户自定义的类加载器
		      -java.lang.ClassLoader的子类
		      -用户可以定制类的加载方式
         -类加载器并不需要等到某个类被“首次主动使用”时再加载它，比如使用-XX:+TraceClassLoading 就能看到每个类加载的顺序  
	  源码分析详见 project/jvm_lecture项目 com.sandro.classloader.Test1
	  原因：
		1)jvm规范允许类加载器在预料某个类将要被使用时就预先加载它。
		  如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)
		2）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
       
	4)类连接中的验证阶段
	  -类加载后，就进入了连接阶段。连接就是将已经读到内存的类的二进制数据合并到虚拟机的运行时环境中去。
	  -类的验证内容（主要验证工作，不同虚拟机细节上会有不同）
		1）类文件的解构检查
		2）语义检查
		3）字节码验证
		4）二进制兼容性的验证	
	
	5)类连接中的准备阶段
	  在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认初始值。
	  例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且默认赋值为0，为long类型的静态变量b分配8各字节的内存空间，同样的默认赋值为0
		public class Sample{
			private static a=1;
			private static long b;
   			static{
				b=2;
			}
		}
        
	6)类的初始化
	  在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。
	  在程序中，静态变量的初始化有两种途径：
		(1)在静态变量的声明出进行初始化
	        (2)在静态代码块中进行初始化。
          例如在以下代码中，静态变量a和b都被显示初始化，而静态变量c没有被显示初始化，它将保持默认值0
                 public class Sample{
                         private static a=1; //在静态变量的声明出进行初始化
                         private static long b;
		         private static long c:
                         static{
                                 b=2;        //在静态代码块进行初始化
                         }
                 }
	
	静态变量的声明语句，以及静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。
	例如当以下sample类被初始化后，它的静态变量的取值是4
		public class sample{
			static int a=1;
			static{ a=2; }
			static{ a=4; }
       			public static void main(String args[]){
				System.out.println(a);// 输出 ：4	
			}
		}
  	
	7)类的初始化步骤：
		-假如这个类还没有被加载和连接，那就先进行加载和连接
		-假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
		-假如类中存在初始化语句，那就依次执行这些初始化语句

	8)类的初始化时机(7种)
		-创建类的实例
		-访问某个类或接口的静态变量，或者对该静态变量赋值
		-调用类的静态方法
		-反射
		-初始化一个类的子类
		-java虚拟机启动时被标明为启动的类
	  	-JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle 实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化则初始化
		
	  除了上述7种情形，其他使用java类的方式都被看做是被动使用，不会导致类的初始化
	  当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
		-在初始化一个类时，并不会先初始化它所实现的接口
		 源码见 project/jvm_lecture项目 com.sandro.classloader.Test9
 
		-在初始化一个接口时，并不会先初始化它的父接口
		 源码见 project/jvm_lecture项目 com.sandro.classloader.Test10

          因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量(实际是不确定的常量，比如获取uuid之类的)时，才会导致该接口的初始化
 	  只有当程序访问的静态变量或者静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用
	  调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用。不会导致类的初始化
	  
	 9)类加载器
	   类加载器用来把类加载到java虚拟机中。从jdk1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好的保证java平台的安全。
	   在此委托机制中，出了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。
	   当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。
 	   如果loader1本身加载失败，就抛异常了
	
	   虚拟机自带了以下几种加载器
		-根类加载器(Bootstrap ClassLoader): 也叫启动类加载器，该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。
		                                    类如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。
					            根类加载器的实现依赖于底层操作系统，由c++实现，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。
						    加载$JAVA_HOME中 jre/lib/rt.java
	
		-扩展类加载器（Extension ClassLoader）: 它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的 jre\lib\ext子目录(扩展目录)中加载类库
					                如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯JAVA类，是java.lang.ClassLoader类的子类。
		-系统加载器（System):也成为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类。
				     它是用户自定义的类加载器的默认父类加载器。系统类加载器是纯JAVA类，是java.lang.ClassLoader类的子类
	   除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载都应该继承ClassLoader类。
	   
	   类加载器层级关系图：他们并不是继承关系，实际上是包含关系
	
			根类加载器
	                     ⬆
		        扩展类加载器
			     ⬆
		        系统类加载器
			     ⬆
		     用户自定义类加载器	
 			     
	   	比如 系统类加载要加载一个类，先交给父亲扩展类加载器加载，扩展类加载器会继续向上交给根类加载器加载，如果此时根类加载器加载不了，则会重新返回给扩展类加载器加载
		     扩展类加载器如果也加载不了，则最后只能返回给系统类加载器去加载。这个时候如果系统类加载器也加载不了，就会抛异常了
			
10、类加载双亲委托机制详解
	1）类加载的父亲（双亲）委托机制
	   在父亲委托机制中，各个加载器按照父子关系形成了属性结构，除了根类加载器之外，其余加载器都有且只有一个父加载器
                       
                             根类加载器
                                 ⬆
                            扩展类加载器
                                 ⬆
                            系统类加载器-----+
	                         ⬆ 委托      ↓ 加载动作通过loader1委托给系统加载器类，一般工程中的类实际上都是系统类加载器实际完成的
                               loader1<-----加载-----> Sample类 
                                 ⬆
                               loader2       
                                                         
         
	2）类加载器查询加载器示意图
            
         ⬆                                           ↓ 
 	 ⬆ 1.                                        ↓ 
	 ⬆ 自        +--------------------------+    ↓ 
	 ⬆ 底        |ClassLoader Architecture  |    ↓ 
	 ⬆ 向        |                          |    ↓ 2.
	 ⬆ 上        |     Bootstrap ClassLoader|    ↓ 自 ---------> Load JRE/lib/rt.jar或者 -Xbootclasspath选项指定的jar包
	 ⬆ 检        |                          |    ↓ 顶
	 ⬆ 查        |                          |    ↓ 向
	 ⬆ 类        |     Extension ClassLoader|    ↓ 下 ---------> Load JRE/lib/ext/*.jar或 -Djava.ext.dirs指定目录下的jar包
         ⬆ 是        |                          |    ↓ 尝
	 ⬆ 否        |                          |    ↓ 试   
	 ⬆ 已        |      App ClassLoader     |    ↓ 加 ---------> Load CLASSPATH或 -Djava.class.path所指定的目录下的类和jar包
         ⬆ 经        |                          |    ↓ 载
	 ⬆ 加        |                          |    ↓ 类 
	 ⬆ 载        |      Custom ClassLoader  |    ↓    ---------> 通过java.lang.ClassLoader的子类自定义加载class
         ⬆           +-------------------------+     ↓
         ⬆                                           ↓
	
	3)定义类加载器和初始类加载器
	  -若有一个类加载器能够成功加载用户自己编写的Test类，那么这个类加载器被成为定义类加载器  
 	  -所有能成功返回Class对象引用的类加载（包括定义类加载器）都被成为初始类加载器
          -比如 1）图中所示，loader1尝试加载 Sample类，最终实际上是系统类加载器加载成功，那么此时系统类加载器就被称为定义类加载器，
		   因为sample类对象的引用是从loader1中返回的，因此loader1是初始类加载器，loader1的父亲也是处是类加载器

	4)使用类加载器加载class
	  源码见 project/jvm_lecture项目 com.sandro.classloader.Test11
	  
