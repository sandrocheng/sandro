1、书籍和名人
	国内比较有名的人叫R大，比叫资深的java虚拟机专家，《深入理解java虚拟机》比较早期的书籍，比较经典
2、常用jvm工具
	jconsole:JDK自带的 jvm监控工具，通过jconsole可以查看各进程的 内存，线程,cpu等运行信息
	jvisualvm:oracle自带的集成工具，类似jconsole工具，功能更全面
	jmap:java命令行工具，能够打印给定的java进程，核心文件内存信息，jmap可能在未来的JDK版本中删除
	
3、类加载器的深入理解与阶段分析
	3.1)类加载：class loading
	在java代码中，类型(class , interface ,枚举等)的加载、连接与初始化过程都是在程序运行期间完成的。比如c语言，是在程序编译后，就把类型关系就确立好了，相对于java来说就没有那么灵活。
	类加载提供了更大的灵活性，增加了更多的可能性，所以java虽然是静态的开发语言，但是依然能够完成动态语言的功能
	类型的加载最常见的方式将类文件从磁盘上加载到内存中去。

	3.2)类加载器(class loader):java中的每一个类型最终都会进入到内存当中，类加载器就是用来做这个工作的

	3.3)java虚拟机(程序)的生命周期，在如下几种情况下，java虚拟机将结束声明周期
		执行了System.exit()方法
		程序正常结束
		程序在执行过程中遇到了异常或者错误而异常终止，比如异常没有catch，那么当前异常会一直向上抛出，直到main方法。
		由于系统错误而导致java虚拟机进程终止
	
	3.4)类的加载、连接、与初始化
		加载：查找并加载类的二进制数据
		连接：
	             a)验证，确保被加载的类的正确性，避免二进制文件被恶意修改
		     b)准备，为类的静态变量分配内存，并将其初始化为默认值，注意在这个阶段，静态变量即使在代码中有赋值，但是这个阶段还只是默认值
		     c)解析，把类中的符号引用转换为直接引用
		           符号引用是一种间接的引用，比如System.out.println("aaa"),System out println这三部分就是符号引用，这个符号引用会被存贮在当前类的常量池中
			   在解析阶段虚拟机会把这个符号引用转化为直接引用，指向实际的内存地址
			   这个过程包括查找System类，out子段，println方法以及确定方法的参数和返回值等步骤
			   最终System.out.println("aaa")会被解析成一个指向实际输出流对象的地址，使得程序能够正常执行
		初始化：为类的静态变量赋予正确的初始值(在连接的准备阶段，静态变量只会被赋予默认值)
 	
	3.5)类的使用和卸载
		使用：类的字节码文件加载到内存后，就可以使用了
		卸载：类加载到内存后，是可以销毁的，销毁后的类就不能再使用了，比如不能再实例化对象等
		      比如osgi技术会动态卸载类
	
	3.6) java程序对类的使用方式分为：
		主动使用(7种):
			创建类的实例
			访问某个类或接口的静态变量(getstatic 助记符号)，或者对该静态变量赋值(putstatic 助记符)
			调用类的静态方法（invoke助记符）
			反射
			初始化一个类的子类,子类被初始化的时候，父类也会被初始化
			java虚拟机启动时被标明为启动类的类（有main方法的类）
			JDK1.7开始提供的动态语言支持(比如javascrpt)：java.lang.invoke.MethodHandle实例的解析结果 _getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则立刻初始化
		被动使用:
			除了以上7中主动使用，其他使用java类的方式都被当作是对类的被动使用，都不会导致类的初始化
	     所有的java虚拟机实现必须在每个类或接口被java程序“首次主动使用”时，才初始化他们。

	3.7）类的加载
		类的加载指的是将类的.class文件中二进制数据读如到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构
		规范中并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中
		
		加载.class文件的方式:
			从本地系统(磁盘)中直接加载
			通过网络下载.class文件
			从zip,jar等归档文件中加载.class文件
			从专有数据库中提取.class文件
			将java源文件动态编译为.class文件，比如动态代理(动态代理在编译器是不存在这个类的，只有在运行期在存在) jsp文件(jsp文件中可以嵌入java代码，jsp最终会转化为servlet)
	3.8) 类加载例子：
		源码见 project/jvm_lecture项目 com.sandro.classloader.Test1，com.sandro.classloader.Test2，com.sandro.classloader.Test3
		对于静态字段来说，只有直接定义了这个字段的类在首次主动使用的时候才会初始化，通过子类调用父类的静态字段，子类不会在首次主动使用的时候初始化
	
	        -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来
 	        比如在class根目录中运行:
	        ..../jvm_lecture/out/production/jvm_lecture$ java -XX:+TraceClassLoading com.sandro.classloader.Test1	
	   	
  	        输出如下：
			..... //jdk的一些类
			[Loaded com.sandro.classloader.Test1 from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]//进程主类
			.....//jdk的一些类
			[Loaded com.sandro.classloader.Test1$Parent from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
			[Loaded com.sandro.classloader.Test1$Child from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
   	
5、jvm参数
	一般jvm参数都是已 -XX:开头的
	一般写法有如下几种：
	5.1）布尔类型的设置
		-XX:+<option> ,表示开启 <option>选项，比如：java -XX:+TraceClassLoading com.xxx.xxx.MainClass
		-XX:-<option> ,表示关闭 <option>选项，jvm有些选项是默认开启的，如果在启动某个进程时候不想用某个已经开启的选项，可以通过"-"关闭
	5.2）赋值设置
		-XX:<option>=<value> 表示将option选项的值设置为value,如：-XX:SurvivorRatio=8,表示eden区与survivior区大小比例为8比1
	
4、常量的本质含义与反编译及助记符详解
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test3
	final修饰的字符串是常量，在编译阶段这个常量就已经保存在调用这个常量的方法所在类的常量池中了
			
	通过 javap -c com.sandro.classloader.Test3反编译
	如下：
		sandro@sandro-Lenovo-XiaoXin-V4000:~/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture$ javap -c com.sandro.classloader.Test3
		Compiled from "Test3.java"
		public class com.sandro.classloader.Test3 {
  			public com.sandro.classloader.Test3();
    				Code:
       					0: aload_0
       					1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       					4: return

  			public static void main(java.lang.String[]);
    				Code:
       					0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       					3: ldc           #4                  // String hello world
       					5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       					8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					11: bipush        567
      					13: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
      					16: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					19: new           #7                  // class java/lang/StringBuilder
      					22: dup
      					23: invokespecial #8                  // Method java/lang/StringBuilder."<init>":()V
      					26: ldc           #9                  // String list size is
      					28: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      					31: getstatic     #11                 // Field com/sandro/classloader/Test3$Parent.list:Ljava/util/List;
      					34: invokeinterface #12,  1           // InterfaceMethod java/util/List.size:()I
      					39: invokevirtual #13                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      					42: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      					45: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      					48: return

		}

	助记符：
	ldc : 表示将int,float 或者 String类型的常量值从常量池中推送置栈顶	
	bipush:表示将单字节(-128~127)的常量推送置栈顶，从测试结果看567也用的是bipush，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	sipush:表示将一个短整形常量值（-32768~32767）推送到栈顶，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	iconst_1:表示将int类型的数字1推送置栈顶，最多到iconst_5,也就是说jvm对int类型 -1～5单独设置了助记符, -1对应的助记符iconst_m1
	助记符的实现在rt.jar中，都有相应的源码可以查看，比如ldc bipush等就在com.sun.org.apache.bcel.internal.generic包下

5、编译期常量与运行期常量的区别
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test4 
	当一个常量的值如果不能在编译期间确定，那么其值就不会被放到调用类的常量池中
	这时在运行程序时，会导致主动使用这个常量所在的类，这个类就肯定会被初始化
	
6、数组创建本质分析
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test5
	对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.xxx.xxx
	动态生成的类型其父类是Object
	对于数组来说，JavaDoc经常构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。
	助记符：
		anewarray，表示创建一个引用类型的（如类，接口，数组）数组，并将其引用值压入栈顶
		newarray,表示创建一个指定的原始类型（如：int,char,short等）的数组，并将其引用压入栈顶

7、接口初始化规则
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test6
	接口中的属性都是public static final的，也就是一个常量，如果是确定的常量，则编译期间这个常量会保存在调用类中的常量池中
	如果常量是需要运行期间才能确定的，那么这个常量首次主动调用时，接口会被初始化，如果接口有父类，父类也会被初始化

8、类连接阶段和初始化阶段静态变量赋值顺序的例子
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test7
	初始化阶段是对静态变量赋值的阶段，赋值的顺序是按照代码从上到下的顺序执行的，因此如果书写不当，有可能造成意外情况。

9、类加载器深入解析及重要特性剖析
	1)进程启动顺序
		开始 		 
		 ⥥	     
	     是否装载APP ----否----> ClassLoader装载成功 -------否---------------> 抛出异常
                 ↓                           ↓                                        ↓
                 是                          ↓                                        ↓
                 ↓                           ↓                                        ↓   
	        连接<----------成功----------+			                      ↓
		 ↓                                                                    ↓
          初始化主入口的类---------------------------->调用主类.main()函数---------->结束
  
	2)
	        +--------------------------+
	开始--- |---> 验证--->准备---->解析|-->初始化--->实例化---->垃圾回收及对象终结--->结束	
		+--------------------------+
		加载：就是把二进制形式的java类读入java虚拟机中
		
		连接：验证，准备，解析
		
                初始化：为类的静态变量赋值
		
	        类的实例化：1)为新的对象分配内存，一般是在堆上分配
			    2)为实例变量赋默认值
			    3)为实例变量赋正确的初始值
			    4)java编译器会为它编译的每一个类都至少生成一个实例初始化方法，在java的class文件中，这个实例初始化方法被成为“<init>”。针对源代码中的每一个类的构造方法，
			      java编译器都产生一个“<init>”方法
        
        3)类的加载
	 -类的加载的最终产品是位于内存中的Class对象
	 -Class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口
	 -有两种类型的类加载器
		1)java虚拟机自带的加载器
		      -根类加载器(Bootstrap classloader),也叫启动类加载器
		      -扩展类加载器(Extension classloader)
		      -系统(应用)类加载器(System/app classloader)
                2)用户自定义的类加载器
		      -java.lang.ClassLoader的子类
		      -用户可以定制类的加载方式
         -类加载器并不需要等到某个类被“首次主动使用”时再加载它，比如使用-XX:+TraceClassLoading 就能看到每个类加载的顺序  
	  源码分析详见 project/jvm_lecture项目 com.sandro.classloader.Test7
	  原因：
		1)jvm规范允许类加载器在预料某个类将要被使用时就预先加载它。
		  如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误(LinkageError错误)
		2）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
       
	4)类连接中的验证阶段
	  -类加载后，就进入了连接阶段。连接就是将已经读到内存的类的二进制数据合并到虚拟机的运行时环境中去。
	  -类的验证内容（主要验证工作，不同虚拟机细节上会有不同）
		1）类文件的解构检查
		2）语义检查
		3）字节码验证
		4）二进制兼容性的验证	
	
	5)类连接中的准备阶段
	  在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认初始值。
	  例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且默认赋值为0，为long类型的静态变量b分配8各字节的内存空间，同样的默认赋值为0
		public class Sample{
			private static a=1;
			private static long b;
   			static{
				b=2;
			}
		}
        
	6)类的初始化
	  在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。
	  在程序中，静态变量的初始化有两种途径：
		(1)在静态变量的声明出进行初始化
	        (2)在静态代码块中进行初始化。
          例如在以下代码中，静态变量a和b都被显示初始化，而静态变量c没有被显示初始化，它将保持默认值0
                 public class Sample{
                         private static a=1; //在静态变量的声明出进行初始化
                         private static long b;
		         private static long c:
                         static{
                                 b=2;        //在静态代码块进行初始化
                         }
                 }
	
	静态变量的声明语句，以及静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。
	例如当以下sample类被初始化后，它的静态变量的取值是4
		public class sample{
			static int a=1;
			static{ a=2; }
			static{ a=4; }
       			public static void main(String args[]){
				System.out.println(a);// 输出 ：4	
			}
		}
  	
	7)类的初始化步骤：
		-假如这个类还没有被加载和连接，那就先进行加载和连接
		-假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
		-假如类中存在初始化语句，那就依次执行这些初始化语句

	8)类的初始化时机(7种)
		-创建类的实例
		-访问某个类或接口的静态变量，或者对该静态变量赋值
		-调用类的静态方法
		-反射
		-初始化一个类的子类
		-java虚拟机启动时被标明为启动的类
	  	-JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle 实例的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化则初始化
		
	  除了上述7种情形，其他使用java类的方式都被看做是被动使用，不会导致类的初始化
	  当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
		-在初始化一个类时，并不会先初始化它所实现的接口
		 源码见 project/jvm_lecture项目 com.sandro.classloader.Test9
 
		-在初始化一个接口时，并不会先初始化它的父接口
		 源码见 project/jvm_lecture项目 com.sandro.classloader.Test10

          因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量(实际是不确定的常量，比如获取uuid之类的)时，才会导致该接口的初始化
 	  只有当程序访问的静态变量或者静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用
	  调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用。不会导致类的初始化
	  
	 9)类加载器
	   类加载器用来把类加载到java虚拟机中。从jdk1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好的保证java平台的安全。
	   在此委托机制中，出了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。
	   当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。
 	   如果loader1本身加载失败，就抛异常了
	
	   虚拟机自带了以下几种加载器
		-根类加载器(Bootstrap ClassLoader): 也叫启动类加载器，该加载器没有父加载器。它负责加载虚拟机的核心类库，如java.lang.*等。
		                                    类如java.lang.Object就是由根类加载器加载的。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。
					            根类加载器的实现依赖于底层操作系统，由c++实现，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类。
						    加载$JAVA_HOME中 jre/lib/rt.java
	
		-扩展类加载器（Extension ClassLoader）: 它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的 jre\lib\ext子目录(扩展目录)中加载类库
					                如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯JAVA类，是java.lang.ClassLoader类的子类。
		-系统加载器（System):也成为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类。
				     它是用户自定义的类加载器的默认父类加载器。系统类加载器是纯JAVA类，是java.lang.ClassLoader类的子类
	   除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载都应该继承ClassLoader类。
	   
	   类加载器层级关系图：他们并不是继承关系，实际上是包含关系
	
			根类加载器
	                     ⬆
		        扩展类加载器
			     ⬆
		        系统类加载器
			     ⬆
		     用户自定义类加载器	
 			     
	   	比如 系统类加载要加载一个类，先交给父亲扩展类加载器加载，扩展类加载器会继续向上交给根类加载器加载，如果此时根类加载器加载不了，则会重新返回给扩展类加载器加载
		     扩展类加载器如果也加载不了，则最后只能返回给系统类加载器去加载。这个时候如果系统类加载器也加载不了，就会抛异常了
			
10、类加载双亲委托机制详解
	1）类加载的父亲（双亲）委托机制
	   在父亲委托机制中，各个加载器按照父子关系形成了属性结构，除了根类加载器之外，其余加载器都有且只有一个父加载器
                       
                             根类加载器
                                 ⬆
                            扩展类加载器
                                 ⬆
                            系统类加载器-----+
	                         ⬆ 委托      ↓ 加载动作通过loader1委托给系统加载器类，一般工程中的类实际上都是系统类加载器实际完成的
                               loader1<-----加载-----> Sample类 
                                 ⬆
                               loader2       
                                                         
         
	2）类加载器查询加载器示意图
            
         ⬆                                           ↓ 
 	 ⬆ 1.                                        ↓ 
	 ⬆ 自        +--------------------------+    ↓ 
	 ⬆ 底        |ClassLoader Architecture  |    ↓ 
	 ⬆ 向        |                          |    ↓ 2.
	 ⬆ 上        |     Bootstrap ClassLoader|    ↓ 自 ---------> Load JRE/lib/rt.jar或者 -Xbootclasspath选项指定的jar包
	 ⬆ 检        |                          |    ↓ 顶
	 ⬆ 查        |                          |    ↓ 向
	 ⬆ 类        |     Extension ClassLoader|    ↓ 下 ---------> Load JRE/lib/ext/*.jar或 -Djava.ext.dirs指定目录下的jar包
         ⬆ 是        |                          |    ↓ 尝
	 ⬆ 否        |                          |    ↓ 试   
	 ⬆ 已        |      App ClassLoader     |    ↓ 加 ---------> Load CLASSPATH或 -Djava.class.path所指定的目录下的类和jar包
         ⬆ 经        |                          |    ↓ 载
	 ⬆ 加        |                          |    ↓ 类 
	 ⬆ 载        |      Custom ClassLoader  |    ↓    ---------> 通过java.lang.ClassLoader的子类自定义加载class
         ⬆           +--------------------------+    ↓
         ⬆                                           ↓
	
	3)定义类加载器和初始类加载器
	  -若有一个类加载器能够成功加载用户自己编写的Test类，那么这个类加载器被成为定义类加载器  
 	  -所有能成功返回Class对象引用的类加载（包括定义类加载器）都被成为初始类加载器
          -比如 1）图中所示，loader1尝试加载 Sample类，最终实际上是系统类加载器加载成功，那么此时系统类加载器就被称为定义类加载器，
		   因为sample类对象的引用是从loader1中返回的，因此loader1是初始类加载器，loader1的父亲也是处是类加载器

	4)使用类加载器加载class
	  源码见 project/jvm_lecture项目 com.sandro.classloader.Test11
	  
11、类加载器与类初始化案例
	1）演示类的常量和静态变量读取时，类的初始化例子
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test8
	
	2）演示类加载和初始化顺序的例子
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test12
	
        3）类的实例化导致初始化的例子
           源码见 project/jvm_lecture项目 com.sandro.classloader.Test13

	4）通过子类调用父类的静态变量和静态方法，都只能算是对父类的主动使用 案例
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test14

	5）通过classloader加载的class对象不会初始化，通过反射加载的class对象会让类初始化
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test15	

12、不同的类加载器作用与加载器动作分析
	1) 读取系统类加载器，并循环读取其所有的父加载器
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test16

	2) 上下文类加载器，通过类加载器读取资源在磁盘上的路径
	   jar hell问题以及解决方法
	   源码见 project/jvm_lecture项目 com.sandro.classloader.Test17

	3) 获得Classloader的途径
	   clazz.getClassLoader();//获取当前类的ClassLoader
	   Thread.currentThread().getContextClassLoader();//获得当前线程上下文的classloader
	   ClassLoader.getSystemClassLoader();//获取系统类加载器
	   DriverManager.getCallerClassLoader();//获得调用者的ClassLoader

13、ClassLoader源码分析与实例剖析
	-ClassLoader抽象类，要自定义加载器必须要继承ClassLoader
	-ClassLoader加载类的时候需要二进制文件名
	-如：
           "java.lang.String"
    	   "javax.swing.JSpinner$DefaultEditor"
           "java.security.KeyStore$Builder$FileBuilder$1"
           "java.net.URLClassLoader$3$1"
	-每一个class对象都包含一个定义这个类的ClassLoader
	
	-数组类型对应的class对象并不是classloader创建的，它是jvm根据需要自动创建的，数组使用的类加载器和数组元素的类加载器是一样的，如果数组中的元素是源是类型，那么数组类是没有类加载器的
	 案例： project/jvm_lecture项目 com.sandro.classloader.Test18
	
	-ClassLoader使用的是双亲委托模型去查找类或者资源。启动类加载器是没有双亲的。

	-支持多线程加载类的加载器叫做并发加载器(parallel capable class loader)，并发加载器需要使用ClassLoader.registerAsParallelCapable方法去注册，默认情况下ClassLoader已经注册了
	 如果子类需要并行加载的化，子类也需要注册
	 在委托模型不是严格化层次的环境下，加载器需要注册为并发加载器，否则有可能出现死锁问题
	
	-jvm通常情况下是从本地文件系统加载的，比如unix使用的是CLASSPATH环境变量指定的路径加载类库
 	-有些类并不是来源与文件，有可能通过其他来源，比如网络，动态代理等，这种情况下defineClass方法可以把字节数组转化为一个class实例
	 NetworkClassLoader源码中可以看到defineClass方法的使用
	 例如：ClassLoader loader = new NetworkClassLoader(host,port);
	       Object main = loader.loadClass("Main",true).newInstance();
      
14、自定义加载器实例
	project/jvm_lecture项目 com.sandro.classloader.Test19

15、类的命名空间
	每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类所组成
	在同一个命名空间中，不会出现类的完整的名字(包括类的包名)相同的两个类
	在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类
	
	命名空间中的类加载关系：
		子加载器加载的类，可以访问父加载器加载过的类
		而父加载器加载的类，不能访问子加载器加载的类
	
16、类的卸载
	-当Sample类被加载、连接和初始化后，它的声明周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束声明周期。
	 Sample类在方法区内的数据也会被卸载，从而结束Sample类的声明周期。

	-一个类何时结束声明周期，取决于代表它的对象何时结束声明周期。

	-由java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载，java虚拟机自带的类加载器包括根加载器、扩展类加载器和系统加载器。     
	 java虚拟机本身会始终引用这些类的加载器，而这些类加载器则会始终引用他们所加载的Class对象，因此这些Class对象始终是可及的。

	-用户自定义的类加载器所加载的类是可以被卸载的。   

	-比如，sample类由load1加载，在类的加载器的内部实现中，用一个java集合来存放所加载类的引用。
	 另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader方法，就能获得它的类加载器。
	 由此可见，代表Sample类的Class实例与loader1之间为双向关联关系。
	 一个类的实例总是引用代表这个类的Class对象。在Object类总定义了getClass()方法，这个方法返回代表对象所属的类的class对象的引用。
	 此外，所有java类都有一个静态属性class，它引用代表这个类的class对象

	-类卸载的例子：project/jvm_lecture项目 com.sandro.classloader.Test20

17、自定义类加载器在复杂情况下的运行分析
	project/jvm_lecture项目 com.sandro.classloader.Test21

18、类加载器的命名空间案例
	project/jvm_lecture项目 com.sandro.classloader.Test22

19、jvm各种加载器类的路径和设置
	project/jvm_lecture项目 com.sandro.classloader.Test23	
	
	扩展类加载器类路径设置方法：
		java -Djava.ext.dirs = ./com.xxx.xxxx.xxx
		将当前目录中的类设置为扩展加载器加载的类路径，这样修改该以后，其他的所有扩展包都无法加载了，要小心使用

20、不同命名空间加载相同类导致的问题
	project/jvm_lecture项目 com.sandro.classloader.Test24

21、类加载的双亲委托模型的优势
	1)可以确保java核心库的类型安全:所有的java应用都至少会引用java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到jvm中
				       如果这个加载过程是由java应用自己的类加载器所完成的。那么很可能能就会在jvm中存在多个版本的java.lang.Object的类
			               而且这些类还是相互不兼容，相互不可见的(由于命名空间导致)。
				       借助于双亲委托机制,java核心类库中的类的加载工作都是由启动类(根类)来统一加载完成，从而确保了java应用所使用的都是同一个版本的java核心类库。
				       他们相互之间都是兼容的
	2)可以确保java核心类库所提供的类不会被自定义的类所替代
	3)不同的类加载器可以为相同名称(binary name)的类创建额外的命名空间，相同名称的类可以并存在jvm中只需要用不同的类加载器来加载他们即可。
	  不同类加载器所加载的类之间是不兼容的，这就相当于在jvm内部创建了一个又一个相互隔离的java类空间，这类技术在多框架中都得到了实际的应用。
        4)某些框架比如tomcat 会修改双亲委托模型以满足web开发的需要

22、扩展类加载器类路径设置要点
	project/jvm_lecture项目 com.sandro.classloader.Test25
	-扩展类加载器默认是加载jar包的，而不是class文件
	 在class目录下运行jar命令给Test1打成jar包，并命名为test.jar
	project/jvm_lecture/out/production/jvm_lecture$ jar cvf test.jar com/sandro/classloader/Test1.class
	
	-运行时设置扩展类加载器：
		在~project/jvm_lecture/out/production/jvm_lecture目录下运行 设置扩展类加载器命令
		java -Djava.ext.dirs=./ com.sandro.classloader.Test25
		-D 一般是运行时设置，java.ext.dirs=./ 将当前目录设置为扩展类加载器需要加载的类路径

23、平台特定的启动类加载器深入分析
	project/jvm_lecture项目 com.sandro.classloader.Test26
	在运行期，一个java类是由该类的完全限定名(binary name,二进制名)和用于加载该类的定义类加载器(defining loader)所共同决定的
	如果同样名字(相同的完全限定名)的类是由两个不同的加载器所加载，那么这些类就是不同的，即使class文件的字节码完全一样，并且从相同的位值加载亦如此

	ClassLoader存在于rt.jar，它是由启动类加载器加载的。启动类加载器是c++编写的它内建于jvm中。
	扩展类加载器和应用类加载器是在jvm启动的时候被启动类加载器加载（Bootstrap ,这是一个特殊机器码，是特定于平台的机器指令，它负责开始整个加载过程）
	加载第一个纯java类加载器就是启动类加载器的职责
	启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的类等等。

24、类加载器源码分析
	1）ClassLoader.getSystemClassLoader()
	   -返回用于委托的系统类加载器。它是所有新的ClassLoader实例的默认的委托双亲。它也是通常用于启动应用的类加载器
	    这个方法首先在运行期启动很早的时候就被调用，在被调用的时刻会创建系统类加载器，并且将其设置为所在线程的上下文类加载器(context class loader)	
	    默认的系统类加载器是与这个类实现相关的实例
	    如果系统属性 java.system.class.loader指定了一个类，那么这个类就会替换条默认的系统类加载器。这个类默认是系统类加载器加载的。这个类必须是ClassLoader的子类，并且实现了设置双亲的构造函数
	    	protected ClassLoader(ClassLoader parent) 
	    系统类加载器会作为这个自定义系统类加载器的父加载器
	   
           -源码说明：
		initSystemClassLoader:ClassLoader创建的时候调用，
                                      sclSet：如果设置了系统类加载器，就不再设置了
				      scl:静态变量，保存当前系统类加载器
				      sun.misc.Launcher:这里面定义了系统类加载器和应用类加载器，sun的Launcher没有开源，如果想看开源的代码可以查看openjdk开源代码
                                                        官网:openjdk.java.net			
	   	                                        在launcher构造方法中
								1）创建扩展类加载器 ExtClassLoader.getExtClassLoader()
								   在静态块中ClassLoader.registerAsParallerCapable()，注册了可以并行加载的接口
								   这里面可以看到java.ext.dirs属性的作用，会读取这个属性目录的类文件
								   并对每一个文件进行权限校验			
								2）创建应用类加载器AppClassLoader.getAppClassLoader(extclassloader)
								   这个对象赋值给一个Launcher的成员变量
								   appclassloader从java.class.path路径中加载，并运行在一个安全受限的上下文中
								   将extclassloader赋值给appclassloader的父加载器
                                                                3) Thread.currentThread().setContetClassLoader(loader)
                                                                   为当前的执行线程设置上下文类加载器
								4）设置安全管理器
                                      将Launchuer中的loader,实际上就是应用类夹杂器赋值给scl		   		
				      对scl进行权限验证：SystemClassLoaderAction(scl)	              
							 1)读取java.system.class.loader系统属性
	                                                 2)如果为空，使用原有的应用类加载器
							   如果不为空，反射生成对应的类加载器实例，并且把当前的应用类加载器设置为新实例的父加载器
	     						 3)将新的应用类加载器设置到当前线程的上下文类加载器中

25、上下文类加载器
	-project/jvm_lecture项目 com.sandro.contextclassloader.Test101
	 当前类加载器：current Classloader ,用于加载当前类的加载器
                      每各类都会使用自己的类加载器（即加载自身的类加载器）去加载其他类(这个类所依赖的其他类)
		      比如：classX引用了classY,那么classX的加载器去加载classY(前提是classY没有被加载过)
	-线程上下文类加载器：Context ClassLoader
		            线程上下文类加载器，从JDK1.2开始引入
			    get/setContextLoader()用于获取和设置一个类加载器
		            如果没有设置的情况下，线程将继承其父线程上下文类加载器
			    java应用运行时的初始线程的上下文类加载器，是应用类加载器
        		    在线程中运行的代码可以同过该类加载器来加载类与资源
	
	-线程上下文类加载器的重要性
 	 比如JDBC连接方式：
		Class.forName("com.mysql.driver.Driver");
		Connection conn = Driver.getConnection();
		Statement st = conn.getStatment();
         JDBC是一套连接标准，它提供了基本的接口和标准类，这些类是在java核心库rt.jar的 java.sql中，比如java.sql.Connection
	 这些接口是由启动加载器加载的，具体的实现是在各厂商数据库实现中，而厂商的类库是放在classpath中的，由应用类加载器加载                 
	 基于加载器的双亲委托模式，启动类加载的类和接口（SPI，Service Provider Interface）无法加载应用类加载器中的类(厂商的接口实现)
	 为了解决这个问题，jvm提供了线程上下文类加载器：父ClassLoader可以使用当前线程的Thread.currentThread().getContextClassLoader()去加载classpath中的类
	 这就解决了父classloader不能使用子classloader加载的类的问题，即改变了双亲委托模型
	
        -总结：在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层加载器加载，但是对于SPI，有些接口是java核心库提供的
               java核心库由启动类加载器加载，这些接口实现却来自与不同的jar包（厂商提供），java的启动类加载是不会加载其他来源的jar包
	       这样传统双亲模型就无法满足SPI的要求，而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来加载接口实现类
	-常见的SPI:JDBC，JNDI(java命名和目录接口标准)，JAXP(xml解析标准)，这些SPI接口实现类的加载都需要打破双亲委托模式才能执行。
	-不使用jvm的双亲委托模式的理论子：tomact，tomcat为了让服务隔离，也重新实现了自己的类加载器，如果子类能加载，就加载，不去委托父加载器，这和传统的双亲委托模式完全相反了
	 但是能非常好的使用服务器上多个web服务同时执行的情况

26、上下文类加载器应用实例
	-project/jvm_lecture项目 com.sandro.contextclassloader.Test102
	 线程上下文类加载器的一般使用模式（获取->使用->还原）
         当高层提供了统一的接口让底层区实现，同时又要在高层加载(实例化)底层的类时，就必须要通过上下文类加载器来帮助高层的ClassLoader找到并加载该类
        
	-jvm ServiceLoader通过上下文加载器加载mysql jdbc 驱动实现类的例子
	 project/jvm_lecture项目 com.sandro.contextclassloader.Test103
	
27、java字节码文件结构查看
	-project/jvm_lecture项目 com.sandro.bytecode.Test1
	
	-项目class根目录下使用javap 命令查看class源码文件的框架信息:javap com.sandro.bytecode.Test1
 	 此时输出的是一个类的框架，但是没有私有变量，类的很多相关信息是没有的
	
	-使用 javap -c com.sandro.bytecode.Test1 查看更详细的类助记符信息
	 使用javap -c依然无法看到全部的信息
     
        -使用javap -verbose -p com.sandro.bytecode.Test1 可以看到全部的类助记符信息
	 -verbose将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类中的变量与成员变量的信息
	 -p 将会把私有方法也输出出来，不使用-p只会展示共有方法
	
	-linux下使用 hexdump -C Test1.class 命令可以查看16进制的信息
	 [-C] 规范化"十六进制+ASCII"显示,显示结果如下：
		00000000  ca fe ba be 00 00 00 34  00 3a 0a 00 0c 00 20 09  |.......4.:.... .|
		00000010  00 06 00 21 09 00 22 00  23 07 00 24 0a 00 04 00  |...!..".#..$....|
		00000020  20 07 00 25 0a 00 26 00  27 0a 00 04 00 28 08 00  | ..%..&.'....(..|
		00000030  29 0a 00 04 00 2a 0a 00  2b 00 2c 07 00 2d 01 00  |)....*..+.,..-..|
		00000040  01 61 01 00 01 49 01 00  06 3c 69 6e 69 74 3e 01  |.a...I...<init>.|
		00000050  00 03 28 29 56 01 00 04  43 6f 64 65 01 00 0f 4c  |..()V...Code...L|
		00000060  69 6e 65 4e 75 6d 62 65  72 54 61 62 6c 65 01 00  |ineNumberTable..|
		00000070  12 4c 6f 63 61 6c 56 61  72 69 61 62 6c 65 54 61  |.LocalVariableTa|
		00000080  62 6c 65 01 00 04 74 68  69 73 01 00 1b 4c 63 6f  |ble...this...Lco|
		00000090  6d 2f 73 61 6e 64 72 6f  2f 62 79 74 65 63 6f 64  |m/sandro/bytecod|
		000000a0  65 2f 54 65 73 74 31 3b  01 00 04 73 65 74 41 01  |e/Test1;...setA.|
		000000b0  00 04 28 49 29 56 01 00  04 67 65 74 41 01 00 03  |..(I)V...getA...|
		000000c0  28 29 49 01 00 04 6d 61  69 6e 01 00 16 28 5b 4c  |()I...main...([L|
		000000d0  6a 61 76 61 2f 6c 61 6e  67 2f 53 74 72 69 6e 67  |java/lang/String|
		000000e0  3b 29 56 01 00 04 61 72  67 73 01 00 13 5b 4c 6a  |;)V...args...[Lj|
		000000f0  61 76 61 2f 6c 61 6e 67  2f 53 74 72 69 6e 67 3b  |ava/lang/String;|
		00000100  01 00 0a 53 6f 75 72 63  65 46 69 6c 65 01 00 0a  |...SourceFile...|
		00000110  54 65 73 74 31 2e 6a 61  76 61 0c 00 0f 00 10 0c  |Test1.java......|
		00000120  00 0d 00 0e 07 00 2e 0c  00 2f 00 30 01 00 17 6a  |........./.0...j|
		00000130  61 76 61 2f 6c 61 6e 67  2f 53 74 72 69 6e 67 42  |ava/lang/StringB|
		00000140  75 69 6c 64 65 72 01 00  19 63 6f 6d 2f 73 61 6e  |uilder...com/san|
		00000150  64 72 6f 2f 62 79 74 65  63 6f 64 65 2f 54 65 73  |dro/bytecode/Tes|
		00000160  74 31 07 00 31 0c 00 32  00 33 0c 00 34 00 35 01  |t1..1..2.3..4.5.|
		00000170  00 05 20 74 65 73 74 0c  00 36 00 33 07 00 37 0c  |.. test..6.3..7.|
		00000180  00 38 00 39 01 00 10 6a  61 76 61 2f 6c 61 6e 67  |.8.9...java/lang|
		00000190  2f 4f 62 6a 65 63 74 01  00 10 6a 61 76 61 2f 6c  |/Object...java/l|
		000001a0  61 6e 67 2f 53 79 73 74  65 6d 01 00 03 6f 75 74  |ang/System...out|
		000001b0  01 00 15 4c 6a 61 76 61  2f 69 6f 2f 50 72 69 6e  |...Ljava/io/Prin|
		000001c0  74 53 74 72 65 61 6d 3b  01 00 0f 6a 61 76 61 2f  |tStream;...java/|
		000001d0  6c 61 6e 67 2f 43 6c 61  73 73 01 00 07 67 65 74  |lang/Class...get|
		000001e0  4e 61 6d 65 01 00 14 28  29 4c 6a 61 76 61 2f 6c  |Name...()Ljava/l|
		000001f0  61 6e 67 2f 53 74 72 69  6e 67 3b 01 00 06 61 70  |ang/String;...ap|
		00000200  70 65 6e 64 01 00 2d 28  4c 6a 61 76 61 2f 6c 61  |pend..-(Ljava/la|
		00000210  6e 67 2f 53 74 72 69 6e  67 3b 29 4c 6a 61 76 61  |ng/String;)Ljava|
		00000220  2f 6c 61 6e 67 2f 53 74  72 69 6e 67 42 75 69 6c  |/lang/StringBuil|
		00000230  64 65 72 3b 01 00 08 74  6f 53 74 72 69 6e 67 01  |der;...toString.|
		00000240  00 13 6a 61 76 61 2f 69  6f 2f 50 72 69 6e 74 53  |..java/io/PrintS|
		00000250  74 72 65 61 6d 01 00 07  70 72 69 6e 74 6c 6e 01  |tream...println.|
		00000260  00 15 28 4c 6a 61 76 61  2f 6c 61 6e 67 2f 53 74  |..(Ljava/lang/St|
		00000270  72 69 6e 67 3b 29 56 00  21 00 06 00 0c 00 00 00  |ring;)V.!.......|
		00000280  01 00 02 00 0d 00 0e 00  00 00 04 00 01 00 0f 00  |................|
		00000290  10 00 01 00 11 00 00 00  38 00 02 00 01 00 00 00  |........8.......|
		000002a0  0a 2a b7 00 01 2a 04 b5  00 02 b1 00 00 00 02 00  |.*...*..........|
		000002b0  12 00 00 00 0a 00 02 00  00 00 03 00 04 00 04 00  |................|
		000002c0  13 00 00 00 0c 00 01 00  00 00 0a 00 14 00 15 00  |................|
		000002d0  00 00 01 00 16 00 17 00  01 00 11 00 00 00 3e 00  |..............>.|
		000002e0  02 00 02 00 00 00 06 2a  1b b5 00 02 b1 00 00 00  |.......*........|
		000002f0  02 00 12 00 00 00 0a 00  02 00 00 00 07 00 05 00  |................|
		00000300  08 00 13 00 00 00 16 00  02 00 00 00 06 00 14 00  |................|
		00000310  15 00 00 00 00 00 06 00  0d 00 0e 00 01 00 01 00  |................|
		00000320  18 00 19 00 01 00 11 00  00 00 2f 00 01 00 01 00  |........../.....|
		00000330  00 00 05 2a b4 00 02 ac  00 00 00 02 00 12 00 00  |...*............|
		00000340  00 06 00 01 00 00 00 0b  00 13 00 00 00 0c 00 01  |................|
		00000350  00 00 00 05 00 14 00 15  00 00 00 09 00 1a 00 1b  |................|
		00000360  00 01 00 11 00 00 00 4c  00 03 00 01 00 00 00 1e  |.......L........|
		00000370  b2 00 03 bb 00 04 59 b7  00 05 12 06 b6 00 07 b6  |......Y.........|
		00000380  00 08 12 09 b6 00 08 b6  00 0a b6 00 0b b1 00 00  |................|
		00000390  00 02 00 12 00 00 00 0a  00 02 00 00 00 0f 00 1d  |................|
		000003a0  00 10 00 13 00 00 00 0c  00 01 00 00 00 1e 00 1c  |................|
		000003b0  00 1d 00 00 00 01 00 1e  00 00 00 02 00 1f        |..............|
		000003be
	jclasslib:https://github.com/ingokegel/jclasslib
	          这是一个java class字节码查看工具相对与javap命令更详细的展示class各字节含义	
	          在idea中 setting->plugin 中可以搜索jclasslib 并安装，就可以直接在编译器上方便的查看了，安装之后重启，就能找到Bytecode viewer，在这里就可以查看了
	java 字节码整体结构：
		Magic Number(4个字节) :魔数 值为0xCAFEBABE(咖啡宝贝) ，由java创始人James Gosling制定
		Version(2 + 2 个字节) :包括minor_version和major_version: 1.1(45),1.2(46),1.3(47),1.4(48),1.5(49),1.6(50),1.7(51),1.8(52).指令集多年不变，但是版本号每次发布都变化
		Constant Pool(2 + n个字节) :包括字符串常量，数值常量等
		Access Flags(2个字节):针对于当前类的访问标志，比如public final class,public class 等
		This Class Name(2个字节):当前类的名字
		Super Class Name(2个字节):当前类的父类
		Interface(2+n个字节):当前类实现的接口列表
		Fields(2 + n个字节):当前类的成员变量的信息
		Methods(2+n个字节):当前类的方法列表
		Attributes(2+n个字节):当前类的附加属性，一些编译器在编译的时候会往这里插入一些特殊属性供jvm执行的时候使用
	

28、java字节码魔数，版本号，常量池(constant pool)深入分析
         -对于class字节码来说 都是已8位(1个字节)为单位来记录的
         -魔数：所有的字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE(咖啡宝贝)，魔数值用来初步判断该字节码是否是一个有效的java字节码文件
         -主办本号：major version: 52，对应魔数后面的4个字节中的后两个字节(00 00 00 34中的0034)，52对应jdk8 51对应jdk7.....
         -次版本号: minor version: 0 , 对应魔数后面的4个字节中的前两个字节(00 00 00 34中的0000)
                    所以该文件的版本号 是 1.8.0，1.8对应0034 .0对应0000 ，可以通过java -version查看当前java的版本号
                    jvm在执行class文件的时候就是根据这个版本号确认是否可以兼容

	-紧接着主版本号之后的就是常量池入口(第9个字节开始)。
	-一个java类定义的很多信息都是由常量池维护和描述的，一般来讲常量池是class文件中最大的部分，jvm执行时根据一个索引就可以在常量池中找到具体信息的位值，可以将常量池看作是class文件的资源仓库。
	-常量池中包含java类中定义的方法与变量信息。
	-常量池中主要存储两类常量:子面量与符号量
		-子面量:文本字符串；java中声明为final的常量值等
		-符号量:类和接口的全局限定名(包名和类名)；字段的名称和描述符；方法的名称和描述符等。
	-常量池的总体解构：java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。
		常量池数量：紧跟在主办本号后面的两个字节，比如:ca fe ba be 00 00 00 34  00 3a 0a 00 0c 00 20 09... 中， 00 3a就是常量池数量58个，
		常量池数组：-紧跟在常量池数量之后,比如:ca fe ba be 00 00 00 34  00 3a 0a 00 0c 00 20 09... 中， 0a 00 0c 00 20 09... 就是常量池数组
			    -常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、解构都是不同的，所以每个元素占据的空间也是不同的。但是每一种元素的第一个数据都是一个u1类型。
			    -u1类型是一个标志位，占据一个字节，jvm在解析类型时就可以根据u1类型来读取具体的信息。
			    -u1一个字节，u2两个字节，u4四个字节，u8八个字节
			    -经典的常量类型有11种，从jdk7开始扩增，具体类型可以从官网中查到
			    -比如 CONSTANT_Utf8_info分三部分:tag(u1),length(U2),bytes(u1),这里tag值为1，代表后面的数据是一个utf8数据，之后的length为U2占用两个字节代表字符串的长度，bytes就是长度
			     为length的UTF-8编码的字符串
		对应的javap -verbose 命令中Constant pool中的元素实际上是57个，这里需要注意常量池数组中的元素个数 = 常量池数量-1 (其中0不使用)。
		这么做的目的是满足某些常量池索引值的数据在特定情况下需要表达"不引用任何一个常量池"的含义。
		根本原因是索引为0也是一个常量(保留常量)，只不过它不位于常量数组中，这个常量就对应null值，所一个常量池的索引从1而非0开始。
	
	-在jvm规范中，每个变量/字段都有描述信息，描述信息主要作用是描述字段的数据类型，方法的参数列表(包括数量，类型与顺序)与返回值。
	 根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示(如：Ljava/lang/String;)。
	 这么做的原因是为了压缩字节码文件的体积，对于基本数据类型jvm都只使用一个大写子母来表示
		如：B - byte
		    C - char
		    D - double
	            F - float
                    I - int
	            J - long
		    S - short
	  	    Z - boolean
                    V - void
		    L+全限定名 - 对象类型 如：Ljava/lang/String; 
	-对于数组类型来说，每一个维度使用一个前置的方括号来表示，如：int[] 被记录为 [I 。String[][]被记录为[[Ljava/lang/String;

	-用描述符来描述方法的时候，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()只内，
	 如方法：String getName(int id , String name) 的描述符为(I,Ljava/lang/String;)Ljava/lang/String;
	 默认的构造函数用<init>来表示
29 Class文件结构中常量池的11种数据类型
	CONSTANT_Utf8_info:              tag u1 1,length u2 UTF-8的字符串长度，bytes u1 长度为lenght的UTF-8编码的字符串
	CONSTANT_Integer_info:           tag u1 3,bytes u4 按照高位在前的存储的int值
	CONSTANT_Float_info:             tag u1 4,bytes u4 按照高位在前的存储的int值
	CONSTANT_Long_info:              tag u1 5,bytes u8 按照高位在前的存储的long值
	CONSTANT_Double_info:            tag u1 6,bytes u8 按照高位在前的存储的double值
	CONSTANT_Class_info:             tag u1 7,bytes u2 指向全限定名常量项的索引
	CONSTANT_String_info:            tag u1 8,bytes u2 指向字符串字面量的索引
	CONSTANT_Field_ref_info:         tag u1 9,index u2 指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项,index u2 指向字段描述符CONSTANT_NameAndType_info的索引项
	CONSTANT_Methodref_info:         tag u1 10,index u2 指向声明方法的类描述符CONSTANT_Class_info的所印象,index u2 指向名称及类型描述符CONSTANT_NameAndType_info的索引项
	CONSTANT_InterfaceMethodref_info:tag u1 11,index u2 指向声明方法的接口描述符CONSTANT_Class_info的所印象,index u2 指向名称及类型描述符CONSTANT_NameAndType_info的索引项
	CONSTANT_NameAndType_info:       tag u1 12,index u2 指向该字段或方法名称常量项的索引，index u2 指向该字段或方法描述符常量项的索引

30、常量池字节码分析
                                           58个常量    #1 10号类型常量    #2 9号类型常量
	00000000  ca fe ba be 00 00 00 34  [00 3a]    [0a 00 0c 00 20]   [09  |.......4.:.... .|
			       #3 9号类型常量     #4 7号常量  #5 10号类型常量
	00000010  00 06 00 21] [09 00 22 00  23] [07 00 24]  [0a 00 04 00  |...!..".#..$....|
		       #6 7号类型常量	#7 10号类型常量	   #8 10号类型常量  #9 8号类型常量	
	00000020  20] [07 00 25]       [0a 00 26 00  27]  [0a 00 04 00 28] [08 00  | ..%..&.'....(..|
			#10 10号类型常量  #11 10号类型常量  #12 7号常量	 #13 1号常量	
	00000030  29] [0a 00 04 00 2a]   [0a 00  2b 00 2c] [07 00 2d]  [01 00  |)....*..+.,..-..|
			  #14 1号常量		#15 1号常量
	00000040  01 61] [01 00 01 49] [01 00  06 3c 69 6e 69 74 3e] 01  |.a...I...<init>.|
	00000050  00 03 28 29 56 01 00 04  43 6f 64 65 01 00 0f 4c  |..()V...Code...L|
	
        ....

        00000250  74 72 65 61 6d 01 00 07  70 72 69 6e 74 6c 6e 01  |tream...println.|
        00000260  00 15 28 4c 6a 61 76 61  2f 6c 61 6e 67 2f 53 74  |..(Ljava/lang/St|
        		   g    ; )  V  									
	00000270  72 69 6e 67 3b 29 56] (常量池所有常量)   00  21 00 06 00 0c 00 00 00  |ring;)V.!.......|

	从第9个字节开始 00 3a ，代表58个常量(除去null的0号常量，实际上是57个常量)
	#1 :第11个字节是第一个常量的类型 ：0a 即10号类型,及后面有两项内容都是u2类型（每项占两个字节）
		12 13字节 00 0c ，12
        	14 15字节 00 20 ，32
	    对应的Constant pool 第一个常量 #1 = Methodref          #12.#32
	    12 32这两个索引具体内容实际上在后面
	#2 :从第16个字节开始 ，09 00 06 00 21 ，9号类型常量，
		00 06 ： 6号索引
		00 21 ： 33号索引
	    对应的Constant pool 第二个常量 #2 = Fieldref           #6.#33  
	#3 :09 00 22 00 23 , 9号类型常量
		00 22：34
		00 23：35
	    对应的Constant pool 第三个常量 #3 = Fieldref           #34.#35 
	#4 : 07 00 24 7号常量 
		00 24 :36
	    对应的Constant pool 第四个常量 #4 = Class              #36
  	
	#5 : 0a 00 04 00 20 ,10号类型常量
	     00 04 ： 4
	     00 20 ： 32
	     对应的Constant pool 第5个常量 #5 = Methodref          #4.#32
	#6 ：07 00 25 7号类型常量
	     00 25 ： 37
	     对应的Constant pool 第6个常量  #6 = Class              #37
	#7 ：0a 00 26 00  27 10号类型常量
	     #7 = Methodref          #38.#39 
	#8 ：0a 00 04 00 28 10号类型常量
	     Methodref          #4.#40 
	#9 ：08 00 29 8号类型常量
             String             #41  
        #10：0a 00 04 00 2a 10号类型常量
	     #10 = Methodref          #4.#42 
	#11: 0a 00  2b 00 2c 10号类型常量
	     #11 = Methodref          #43.#44
        #12: 07 00 2d	7号类型常量
	     #12 = Class              #45  
	#13: 01 00 01 61 1号类型常量
	     00 01 ：字符串长度 1
	     61 : 字符16位ascII码  a
             #13 = Utf8               a
        #14: 01 00 01 49 1号类型常量
	     00 01 ：字符串长度 1
	     49 : 字符16位ascII码  I  		 	
	     #14 = Utf8               I
	#15  01 00  06 3c 69 6e 69 74 3e 1号类型常量
	     00  06 ：字符串长度 6
	     3c 69 6e 69 74 3e ：<init>
	     #15 = Utf8               <init>
	..... 		 		     
        			
	    	
31、Access Flags 访问标志符 u2
	-访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明成final。 	
	 ACC_PUBLIC        0X0001  public类型
	 ACC_PRIVATE       0X0002  private类型
	 ACC_FINAL         0X0010  final 类型
	 ACC_PUBLIC_STATIC 0X0009  public static 类型
	 ACC_SUPER         0X0020  子类调用父类的方法
	 ACC_INTERFACE     0X0200  接口类
	 ACC_ABSTRACT      0X0400  抽象类
	 ACC_SYNTHETIC     0X1000  不在源代码中
	 ACC_ANNOTATION    0X2000  注解
	 ACC_ENUM          0X4000  枚举
	
	               常量池常量列表结束
	- 00000270  72 69 6e 67 3b 29 56]   00  21 00 06 00 0c 00 00 00  |ring;)V.!.......|
        	
	-访问标志符接在常量池后面两个字节 ：00 21 
	 实际上是 0x0001 和 0x0020的并集，表示 ACC_PUBLIC和ACC_SUPER

32、This Class Name 当前类名 u2
                     常量池常量列表结束	     Access Flags  This class name
	- 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]         00 0c 00 00 00  |ring;)V.!.......|
	
	00 06 : 对应常量池6号索引  #6 = Class              #37            // com/sandro/bytecode/Test1

32、Super Class Name 当前类的父类 u2

                      常量池常量列表结束      Access Flags  This class name   super class name
         - 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]           [00 0c]          00 00 00  |ring;)V.!.......|
         
         00 0c : 对应常量池12号索引  #12 = Class              #45            // java/lang/Object

33、interfaces 接口列表 2 + n个字节
                       常量池常量列表结束      Access Flags  This class name  super class name        接口数量
          - 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]           [00 0c]                 [00 00] 00  |ring;)V.!.......|
	   数量：00 00 ，此时接口数量是0，所以接口列表就没有内容了直接连接下一个数据

34、Fields 2 + n个字节
	-字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量(静态变量)以及实例变量(成员变量)，但是不包括方法内部声明的局部变量 
                        常量池常量列表结束      Access Flags  This class name  super class name        接口数量 属性的数量
        - 00000270  72 69 6e 67 3b 29 56]   [00  21]      [00 06]           [00 0c]                 [00 00] [00             |ring;)V.!.......|	
	                 属性列表  
	  00000280  01] [00 02 00 0d 00 0e 00 00] 00 04 00 01 00 0f 00  |................|
          字段数量00 01 ，说名只有一个
	  	
	-字段表数据结构
	 access_flags u2， 访问符号 
         name_index u2 ，名字索引
         descriptor_index u2 ，描述索引
	 attributes_count u2 ，字段附加信息长度，如果是0，则后面的atribute_info就没有了
         attribute_info ，附加信息内容，长度为 attributes_count
	
	- 00 02 00 0d 00 0e 00
	  0002 access_flags为private
	  000d name_index,对应 #13 = Utf8               a
	  000e 描述索引,对应   #14 = Utf8               I
	  0000 附加信息长度 0，代表没有附加信息
	  因此当前字段就是一个名字为a 的 private的整形变量

35、Methods 方法表 2+n个字节
			属性列表                 方法数量  第一个方法
	00000280  01] [00 02 00 0d 00 0e 00 00] [00 04]   [00 01 00 0f 00  |................|
				 attribute_length = 56  attribute结构体字节码		
        00000290  10 00 01 00 11 (00 00 00 38)         (00 02 00 01 00 00 00  |........8.......|
        000002a0  0a 2a b7 00 01 2a 04 b5  00 02 b1 00 00 00 02 00  |.*...*..........|
        000002b0  12 00 00 00 0a 00 02 00  00 00 03 00 04 00 04 00  |................|
        000002c0  13 00 00 00 0c 00 01 00  00 00 0a 00 14 00 15 00  |................|
        000002d0  00)] 00 01 00 16 00 17 00  01 00 11 00 00 00 3e 00  |..............>.|

        - 0x0004 = 4 ： 方法的数量是4个
	-方法表数据结构
	 {
	 	access_flags u2， 访问符号 
         	name_index u2 ，名字索引
         	descriptor_index u2 ，描述索引
         	attributes_count u2 ，字段附加信息长度，如果是0，则后面的atribute_info就没有了
	 	attribute_info ，附加信息数据表 表长是 attribute_count
	
	 attribute_info数据体结构
	 {
	  	attribute_name_index u2
          	attribute_length u4
          	info[attribute_length] u1 长度为attribute_length的1个字节为单位的数组保存
 	 }
	
	 code的结构：当attribute_name_index 在常量池中指向的是code的时候需要用code结构体分析数据
	 {
		attribute_name_index u2
		attribute_length u4 ，表示attribute所包含的字节数，不包含attribute_name_index和 attribute_length字段
		max_stack u2，表示这个方法运行的任何时刻所能达到的操作数栈的最大深度 
	 	max_locals u2 表示方法执行期间粗昂见的局部变量的数目，包含用来表示传入的参数的局部变量
	        code_length u4 表示该方法所包含的字节码的字节数以及具体的指令码
		code[code_length],单位是1个字节 , 具体字节码即是该方法被调用时虚拟机执行的自己码
		exception_table_length u2
		exception_table[exception_table_length]
		exception_table 元数据结构体{
			//这里存放的是处理异常的信息
			//每个exception_table表由start_pc,end_pc,handler_pc,catch_type组成
			//start_pc和end_pc表示在code数组中的从start_pc到end_pc处(包含start_pc,不包含end_pc)的指令抛出的异常会由这个表项来处理
		        //handler_pc表示会被处理的异常类型，它指向常量池里的一个异常类。当catch_type为0时，表示处理所有的异常
			start_pc u2
			end_pc u2
			handler_pc u2
			catch_type u2
		}
		attributes_count u2,code属性长度
		attribute_info[attributes_count]，code属性信息
		{
			
		}
	 }

	-第一个方法
	 00 01 00 0f 00 10 00 01 00 11 00 00 00 38...后面56个字节
	 00 01 ，access_flags=ACC_PUBLIC
	 00 0f , name_index = 15
		 #15 = Utf8               <init>,构造方法
		 构造方法统一都使用 <init>助记符
	         默认的无参数构造方法，如果自己实现了无参数的构造方法，生成的字节码也是这样的，在默认的构造方法中会将成员变量赋值
		 多个构造方法，就会有多个 <init> 方法体
		 如果自己实现了一个有参数的构造方法，实际上在有参数的构造方法中也会给每个成员变量赋值
	 00 10 , descriptor_index = 16
	         #16 = Utf8               ()V
	 00 01 , attributes_count = 1 说明有一个attribute数据
	 00 11 , attribute_info[1].attribute_name_index = 17
	         #17 = Utf8               Code 
		 code代表执行代码，用助记符的方式描述方法体
	 00 00 00 38,attribute_info[1].attribute_length = 56 

	 code : 因为.attribute_name_index指向常量池中的常量是code,所以需要用code结构体来分析 info[56]这部分数据
		code是每个方法最重要的属性，这个属性几乎总是存在的
	        00 02 00 01 00 00 00 0a  2a b7 00 01 2a 04 b5 00 
		02 b1 00 00 00 02 00 12  00 00 00 0a 00 02 00 00 
		00 03 00 04 00 04 00 13  00 00 00 0c 00 01 00 00 
		00 0a 00 14 00 15 00 00  	 
          {      
                 max_stack u2，00 02->2
                 max_locals u2 , 00 01 ->1
                 code_length u4,00 00 00 0a ->10
                 code[code_length],单位是1个字节，2a b7 00 01 2a 04 b5 00 02 b1
				   通过查表可以将16进制和具体的助记符关联起来
				   官网地址：https://docs.oracle.com/javase/specs/jvms/se19/html/index.html（Chapter 6. The Java Virtual Machine Instruction Set ）
				   -2a,aload_0, 将索引为0的元素推送到操作栈的栈顶，准备调用 
				   -b7 [00 01],  invokespecial 1 -> #1 = Methodref          #12.#32        // java/lang/Object."<init>":()V
						这里是调用了父类的构造方法
				   -2a, aload_0
				   -04, iconst_1 ，推送整形1到栈顶，从这里看到非静态全局变量实际上是在默认的构造方法中赋值的
				   -b5 [00 02] ,putfield 2 -> #2 = Fieldref           #6.#33         // com/sandro/bytecode/Test1.a:I
						给成员变量赋值（此时要赋的值已经在上一行放到栈顶了）
			           -b1 ,return		
                 exception_table_length u2，00 00 = 0
                 exception_table[exception_table_length]，此时为空
                 attributes_count u2,00 02 = 2，
                 attribute_info[0]：00 12 [00 00 00 0a 00 02 00 00 00 03 00 04 00 04] 00 13  00 00 00 0c 00 01 00 00 00 0a 00 14 00 15 00 00
		 { 
			00 12(18)：第一个属性索引#18 = Utf8               LineNumberTable
			LineNumberTable：行号和字节码的对应关系，方便代码和执行位值关联，用于定位代码使用
			LineNumberTable struct{
				length u4 ,00 00 00 0a 长度为10个字节
					   00 02 00 00 00 03 00 04 00 04
				liner_number_table_length u2 00 02->2
				line_number_table{	
					start_pc u2
					line_number u2
				}->table[0].start_pc = 0000 table[0].line_number=0003 //这里怀疑是因为代码中注释的原因导致行号没有对齐，javap中看 liner_number是208和210
				   table[1].start_pc = 0004 table[1].line_nmuber=0004
			}
          	}
		attribute_info[1]：00 13 00 00 00 0c 00 01 00 00 00 0a 00 14 00 15 00 00
		{
			00 13(19): 第二个属性索引 #19 = Utf8               LocalVariableTable
			LocalVariableTable 局部变量表，
					   在java当中每一个非静态方法中都有一个this的，在字节码中这个this就是通过第一个局部变量隐式的传递进来的
			{
				length u4, 00 00 0c = 12 ,说明后面12个字节都是LocalVariableTable的数据
					   00 01 00 00 00 0a 00 14 00 15 00 00
				count u2, 00 01 =1  ，局部变量的个数是1个
				start u2, 00 00 = 0 起始位值是0
				length u2,00 0a = 10 长度是10
				name_index u2 ,0x0014 = 20 ->  #20 = Utf8               this
					       		
 				desc_index u2 ,0x0015 = 21 ->  #21 = Utf8               Lcom/sandro/bytecode/Test1;
				校验检查位 u2,0x0000 = 0
			}
		}
			 
	}
	
	-第2个方法：	      第二个方法开始
				public   index=22 setA   (I)V    1个attri    code结构    len=62       code_data
	         000002d0  00 [(00 01)  (00 16)        (00 17)  (00 01)     (00 11)   （00 00 00 3e）(00  
                 000002e0  02 00 02 00 00 00 06 2a  1b b5 00 02 b1 00 00 00  
                 000002f0  02 00 12 00 00 00 0a 00  02 00 00 00 07 00 05 00 
                 00000300  08 00 13 00 00 00 16 00  02 00 00 00 06 00 14 00  
                 00000310  15 00 00 00 00 00 06 00  0d 00 0e 00 01)] 00 01 00 

	-第3个方法：                                                public   index=34 getA		 
		 00000310  15 00 00 00 00 00 06 00  0d 00 0e 00 01 [(00 01  (00 
				()I     1个 attri  code结构     len=47        code_data
                 00000320  18) (00 19) (00 01)   (00 11)     （00 00 00 2f）(00 01 00 01 00  
                 00000330  00 00 05 2a b4 00 02 ac  00 00 00 02 00 12 00 00  
                 00000340  00 06 00 01 00 00 00 0b  00 13 00 00 00 0c 00 01  
                 00000350  00 00 00 05 00 14 00 15  00 00)] 00 09 00 1a 00 1b  
                 00000360  00 01 00 11 00 00 00 4c  00 03 00 01 00 00 00 1e  

	-第4个方法
		                                            public static index=26 main  ([Ljava/lang/String;)V
                 00000350  00 00 00 05 00 14 00 15  00 00 [(00 09)        (00 1a)        (00 1b)
			    1个attri  code结构	  len=76	code_data	
                 00000360  (00 01)   (00 11)   （00 00 00 4c） (00 03 00 01 00 00 00 1e 
                 00000370  b2 00 03 bb 00 04 59 b7  00 05 12 06 b6 00 07 b6  
                 00000380  00 08 12 09 b6 00 08 b6  00 0a b6 00 0b b1 00 00  
                 00000390  00 02 00 12 00 00 00 0a  00 02 00 00 00 0f 00 1d  
                 000003a0  00 10 00 13 00 00 00 0c  00 01 00 00 00 1e 00 1c  
                 000003b0  00 1d 00 00)] 00 01 00 1e  00 00 00 02 00 1f        

	
35、字节码文件的attribute
	class文件自己的一些属性信息
	000003b0  00 1d 00 00 [00 01 00 1e  00 00 00 02 00 1f]
	
	count u2 ,0x0001=1 ,只有一个属性信息
	index u2,0x001e = 30  #30 = Utf8               SourceFile
	len u4 ,0x00000002 = 2,长度只占据两个字节
	socefile_index u2, 0x001f=31  #31 = Utf8               Test1.java

36、案例2字节码
	project/jvm_lecture项目 com.sandro.bytecode.Test2
	字节码如下：
	
	java文件魔数  minor_version = 0  major_version=52即jdk1.8  58个常量  [常量池开始
        [ca fe ba be] [00 00]           [00 34]                   [00 30]   [0a 00 0a 00 23 08 
        00 24 09 00 05 00 25 09  00 05 00 26 07 00 27 0a 
        00 05 00 23 0a 00 05 00  28 0a 00 29 00 2a 09 00 
        05 00 2b 07 00 2c 01 00  03 73 74 72 01 00 12 4c 
        6a 61 76 61 2f 6c 61 6e  67 2f 53 74 72 69 6e 67 
        3b 01 00 04 78 4e 75 6d  01 00 01 49 01 00 05 69 
        6e 4e 75 6d 01 00 13 4c  6a 61 76 61 2f 6c 61 6e 
        67 2f 49 6e 74 65 67 65  72 3b 01 00 06 3c 69 6e 
        69 74 3e 01 00 03 28 29  56 01 00 04 43 6f 64 65 
        01 00 0f 4c 69 6e 65 4e  75 6d 62 65 72 54 61 62 
        6c 65 01 00 12 4c 6f 63  61 6c 56 61 72 69 61 62 
        6c 65 54 61 62 6c 65 01  00 04 74 68 69 73 01 00 
        1b 4c 63 6f 6d 2f 73 61  6e 64 72 6f 2f 62 79 74 
        65 63 6f 64 65 2f 54 65  73 74 32 3b 01 00 04 6d 
        61 69 6e 01 00 16 28 5b  4c 6a 61 76 61 2f 6c 61 
        6e 67 2f 53 74 72 69 6e  67 3b 29 56 01 00 04 61 
        72 67 73 01 00 13 5b 4c  6a 61 76 61 2f 6c 61 6e 
        67 2f 53 74 72 69 6e 67  3b 01 00 05 74 65 73 74 
        32 01 00 07 73 65 74 78  4e 75 6d 01 00 04 28 49 
        29 56 01 00 01 78 01 00  08 3c 63 6c 69 6e 69 74 
        3e 01 00 0a 53 6f 75 72  63 65 46 69 6c 65 01 00 
        0a 54 65 73 74 32 2e 6a  61 76 61 0c 00 11 00 12 
        01 00 07 57 65 6c 63 6f  6d 65 0c 00 0b 00 0c 0c 
        00 0d 00 0e 01 00 19 63  6f 6d 2f 73 61 6e 64 72 
        6f 2f 62 79 74 65 63 6f  64 65 2f 54 65 73 74 32 
        0c 00 1d 00 1e 07 00 2d  0c 00 2e 00 2f 0c 00 0f 
        00 10 01 00 10 6a 61 76  61 2f 6c 61 6e 67 2f 4f 
        62 6a 65 63 74 01 00 11  6a 61 76 61 2f 6c 61 6e 
        67 2f 49 6e 74 65 67 65  72 01 00 07 76 61 6c 75 
        65 4f 66 01 00 16 28 49  29 4c 6a 61 76 61 2f 6c
                                  常量池结束]  ACC_PUBLIC，ACC_SUPER  this classname=#5 -> Class              #39            // com/sandro/bytecode/Test2
        61 6e 67 2f 49 6e 74 65  67 65 72 3b] [00 21]                [00 05] 
	super classname = #10->java/lang/Object  接口数量=0   Fields数量=3 [fields开始
        [00 0a]                                  [00 00]      [00 03]      [00 00  00 0b 00 0c 00 00 00 02 
                                        fields结束] 方法数量=4
        00 0d 00 0e 00 00 00 09  00 0f 00 10 00 00] [00 04] 
	[方法区开始 
	 (方法1开始
        [(00 01 00 11 00 12 00 01  00 13 00 00 00 42 00 02 
        00 01 00 00 00 10 2a b7  00 01 2a 12 02 b5 00 03 
        2a 08 b5 00 04 b1 00 00  00 02 00 14 00 00 00 0e 
        00 03 00 00 00 03 00 04  00 04 00 0a 00 06 00 15 
						方法1结束
        00 00 00 0c 00 01 00 00  00 10 00 16 00 17 00 00)
	(方法2开始 
        (00 09 00 18 00 19 00 01  00 13 00 00 00 57 00 02 
        00 02 00 00 00 17 bb 00  05 59 b7 00 06 4c 2b 10 
        08 b6 00 07 10 14 b8 00  08 b3 00 09 b1 00 00 00 
        02 00 14 00 00 00 12 00  04 00 00 00 0b 00 08 00 
        0c 00 0e 00 0d 00 16 00  0e 00 15 00 00 00 16 00 
        02 00 00 00 17 00 1a 00  1b 00 00 00 08 00 0f 00 
        方法2结束	(方法3开始
	1c 00 17 00 01) (00 01 00  1d 00 1e 00 01 00 13 00 
        00 00 3e 00 02 00 02 00  00 00 06 2a 1b b5 00 04 
        b1 00 00 00 02 00 14 00  00 00 0a 00 02 00 00 00 
        11 00 05 00 12 00 15 00  00 00 16 00 02 00 00 00 
        06 00 16 00 17 00 00 00  00 00 06 00 1f 00 0e 00 
 方法3结束) (方法4开始	
        01) (00 08 00 20 00 12 00  01 00 13 00 00 00 21 00 
        01 00 00 00 00 00 09 10  0a b8 00 08 b3 00 09 b1 
					       方法区结束]
					       方法4结束)
        00 00 00 01 00 14 00 00  00 06 00 01 00 00 00 08)] 
        00 01 00 21 00 00 00 02  00 22                   

	常量池：
	0a 00 0a 00 23            #1 = Methodref          #10.#35        // java/lang/Object."<init>":()V
	08 00 24                  #2 = String             #36            // Welcome
	09 00 05 00 25            #3 = Fieldref           #5.#37         // com/sandro/bytecode/Test2.str:Ljava/lang/String;
	09 00 05 00 26            #4 = Fieldref           #5.#38         // com/sandro/bytecode/Test2.xNum:I
	07 00 27                  #5 = Class              #39            // com/sandro/bytecode/Test2 
	0a 00 05 00 23            #6 = Methodref          #5.#35         // com/sandro/bytecode/Test2."<init>":()V
	0a 00 05 00 28            #7 = Methodref          #5.#40         // com/sandro/bytecode/Test2.setxNum:(I)V
	0a 00 29 00 2a            #8 = Methodref          #41.#42        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
	09 00 05 00 2b            #9 = Fieldref           #5.#43         // com/sandro/bytecode/Test2.inNum:Ljava/lang/Integer;
	07 00 2c                  #10 = Class              #44            // java/lang/Object
	01 00 03 73 74 72         #11 = Utf8               str 
	01 00 12 4c 6a 61 76 61 2f 6c 61 6e  67 2f 53 74 72 69 6e 67 3b 
			          #12 = Utf8               Ljava/lang/String;
	01 00 04 78 4e 75 6d      #13 = Utf8               xNum
	01 00 01 49               #14 = Utf8               I 
	01 00 05 69 6e 4e 75 6d 
			          #15 = Utf8               inNum
	01 00 13 4c 6a 61 76 61 2f 6c 61 6e 67 2f 49 6e 74 65 67 65 72 3b 
			          #16 = Utf8               Ljava/lang/Integer;	
	01 00 06 3c 69 6e 69 74 3e 
			          #17 = Utf8               <init>
	01 00 03 28 29  56        #18 = Utf8               ()V
	01 00 04 43 6f 64 65      #19 = Utf8               Code
        01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 
			          #20 = Utf8               LineNumberTable
        01 00 12 4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 
				  #21 = Utf8               LocalVariableTable
	01 00 04 74 68 69 73 
				  #22 = Utf8               this
	01 00 1b 4c 63 6f 6d 2f 73 61 6e 64 72 6f 2f 62 79 74 65 63 6f 64 65 2f 54 65 73 74 32 3b 
				  #23 = Utf8               Lcom/sandro/bytecode/Test2;
	01 00 04 6d 61 69 6e      #24 = Utf8               main
	01 00 16 28 5b  4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56 
				  #25 = Utf8               ([Ljava/lang/String;)V	
	01 00 04 61 72 67 73      #26 = Utf8               args
	01 00 13 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 
				  #27 = Utf8               [Ljava/lang/String;  
	01 00 05 74 65 73 74 32 
				  #28 = Utf8               test2
	01 00 07 73 65 74 78  4e 75 6d 
                                  #29 = Utf8               setxNum
	01 00 04 28 49 29 56      #30 = Utf8               (I)V
	01 00 01 78               #31 = Utf8               x
	01 00 08 3c 63 6c 69 6e 69 74 3e 
				  #32 = Utf8               <clinit>
	01 00 0a 53 6f 75 72 63 65 46 69 6c 65
                                  #33 = Utf8               SourceFile 
	01 00 0a 54 65 73 74 32 2e 6a 61 76 61 
				  #34 = Utf8               Test2.java
	0c 00 11 00 12            #35 = NameAndType        #17:#18        // "<init>":()V
        01 00 07 57 65 6c 63 6f 6d 65 
				  #36 = Utf8               Welcome 
	0c 00 0b 00 0c            #37 = NameAndType        #11:#12        // str:Ljava/lang/String;
	0c 00 0d 00 0e            #38 = NameAndType        #13:#14        // xNum:I 
	01 00 19 63 6f 6d 2f 73 61 6e 64 72 6f 2f 62 79 74 65 63 6f 64 65 2f 54 65 73 74 32
				  #39 = Utf8               com/sandro/bytecode/Test2 
	0c 00 1d 00 1e            #40 = NameAndType        #29:#30        // setxNum:(I)V
	07 00 2d                  #41 = Class              #45            // java/lang/Integer 
	0c 00 2e 00 2f            #42 = NameAndType        #46:#47        // valueOf:(I)Ljava/lang/Integer; 
	0c 00 0f 00 10            #43 = NameAndType        #15:#16        // inNum:Ljava/lang/Integer;
	01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 
				  #44 = Utf8               java/lang/Object	
        01 00 11 6a 61 76 61 2f 6c 61 6e 67 2f 49 6e 74 65 67 65 72
				  #45 = Utf8               java/lang/Integer 
	01 00 07 76 61 6c 75 65 4f 66     
				  #46 = Utf8               valueOf
 	01 00 16 28 49 29 4c 6a 61 76 61 2f 6c 61 6e 67 2f 49 6e 74 65 67 65 72 3b 
				  #47 = Utf8               (I)Ljava/lang/Integer;	

	Fields: 
	00 09 00 0f 00 10 00 00 
	
	00 01 00 11 00 12 00 01  00 13 00 00 00 42 00 02
	fields[0] = 00 00 00 0b 00 0c 00 00 
	fields[0].access_flags = 0x0000(),0就代表没有，也可以理解为protected
	fields[0].name_index = 0x000b , #11 = Utf8               str
	fields[0].descriptor_index = 0x000c ,  #12 = Utf8               Ljava/lang/String;
	fields[0].attributes_count = 0x0000
	
        fields[1] = 00 02 00 0d 00 0e 00 00 
        fields[1].access_flags = 0x0002, private
        fields[1].name_index = 0x000d , 0x000e ,  #13 = Utf8               xNum
        fields[1].descriptor_index = 0x000e ,  #14 = Utf8               I
        fields[1].attributes_count = 0x0000 

        fields[2] = 00 09 00 0f 00 10 00 00  
        fields[2].access_flags = 0x0009, public static
        fields[2].name_index = 0x000f , 0x000e ,  #15 = Utf8               inNum
        fields[2].descriptor_index = 0x0010 ,  #16 = Utf8               Ljava/lang/Integer;
        fields[2].attributes_count = 0x0000

	
	方法：
	methods[0].access_flags = 0x0001 public  
	methods[0].name_index = 0x0011 , #17 = Utf8               <init>
	methods[0].descriptor_index = 0x0012 , #18 = Utf8               ()V 
	methods[0].attributes_count = 0x0001
	methods[0].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
 	methods[0].attribute_info[0].info_length = 0x00000042 ,66字节长度 
	methods[0].attribute_info[0].code = {
		max_stack = 0x0002,2
		max_locals = 0x0001,1
		code_length = 0x00000010,
		code_data = 2a b7 00 01 2a 12 02 b5 00 03 2a 08 b5 00 04 b1
		code:
			2a:aload_0
			b7 [00 01]: invokespecial #1=Methodref  #10.#35  // java/lang/Object."<init>":()V
			2a:aload_0
			12 [02]:ldc #2=String  #36 // Welcome
    			b5 [00 03] : putfield #3 Fieldref #5.#37 // com/sandro/bytecode/Test2.str:Ljava/lang/String;
			2a:aload_0
			08:iconst_5
			b5 [00 04] : putfield #4 Fieldref #5.#38   // com/sandro/bytecode/Test2.xNum:I
			b1:return
		exception_table_length= 0x0000
		attributes_count = 0x0002
		attribute_info[0] = {
			attribute_index=0x0014,#20 = Utf8 LineNumberTable
			LineNumberTable{
				length=0x0000000e
				tableinfo=00 03 00 00 00 03 00 04  00 04 00 0a 00 06
				table_count=0x0003
				table[0].start_pc=0x0000
				table[0].line_number=0x0003
                                table[1].start_pc=0x0004
                                table[1].line_number=0x0004
                                table[2].start_pc=0x000a
                                table[2].line_number=0x0006
			}		
		} 
                attribute_info[1] = {
                        attribute_index=0x0015,#21 = Utf8 LocalVariableTable
                        LocalVariableTable{
                                length=0x0000000c
                                tableinfo=00 01 00 00 00 10 00 16 00 17 00 00
                                count = 0x0001
				start = 0x0000
				length = 0x0010
		 		name_index = 0x0016, #22 = Utf8 this
				desc_index = 0x0017, #23 = Utf8 Lcom/sandro/bytecode/Test2;
				校验检查位 = 0x0000
                        }
                }
	
	}		

        methods[1].access_flags = 0x0009 public static
        methods[1].name_index = 0x0018 , #24 = Utf8  main
        methods[1].descriptor_index = 0x0019 , #25 = Utf8 ([Ljava/lang/String;)V
        methods[1].attributes_count = 0x0001
        methods[1].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
        methods[1].attribute_info[0].info_length = 0x00000057 ,87字节长度
        methods[1].attribute_info[0].code = {
                max_stack = 0x0002,2
                max_locals = 0x0002,2
                code_length = 0x00000017,
                code_data {
			bb [00 05]: new #5 = Class #39  // com/sandro/bytecode/Test2 
			59: dup
			b7 [00 06]:invokespecial #6 = Methodref #5.#35   // com/sandro/bytecode/Test2."<init>":()V
			4c:astore_1 
			2b:aload_1 
			10 [08] bipush 8 
			b6 [00 07] invokevirtual invokespecial #7 = Methodref #5.#40 // com/sandro/bytecode/Test2.setxNum:(I)V	
			10 [14] bigpush 20 
			b8 [00 08] invokestatic #8 = Methodref  #41.#42    // java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 
			b3 [00 09] pubstatic #9 = Fieldref      #5.#43     // com/sandro/bytecode/Test2.inNum:Ljava/lang/Integer; 
			b1 return
			
                exception_table_length= 0x0000
                attributes_count = 0x0002
                attribute_info[0] = {
                        attribute_index=0x0014,#20 = Utf8 LineNumberTable
                        LineNumberTable{
                                length=0x00000012
                                tableinfo=00 04 00 00 00 0b 00 08 00 0c 00 0e 00 0d 00 16 00  0e
                                table_count=0x0004 
                                table[0].start_pc=0x0000
                                table[0].line_number=0x000b
                                table[1].start_pc=0x0008
                                table[1].line_number=0x000c
                                table[2].start_pc=0x000e
                                table[2].line_number=0x000d
				table[3].start_pc=0x0016
				table[3].line_number=0x000e
                        }               
                }
                attribute_info[1] = {
                        attribute_index=0x0015,#21 = Utf8 LocalVariableTable
                        LocalVariableTable{
                                length=0x00000016
                                tableinfo=00 02 00 00 00 17 00 1a 00 1b 00 00     00 08 00 0f 00 1c 00 17 00 01
                                count = 0x0002
				table[0] = {
                                	start = 0x0000
                                	length = 0x0017
                                	name_index = 0x001a, #26 = Utf8 args
                                	desc_index = 0x001b, #27 = Utf8 [Ljava/lang/String;
                                	校验检查位 = 0x0000
				}
                                table[1] = {
                                        start = 0x0008
                                        length = 0x000f
                                        name_index = 0x001c, #28 = Utf8  test2
                                        desc_index = 0x0017, #23 = Utf8  Lcom/sandro/bytecode/Test2;
                                        校验检查位 = 0x0001
                                }

                        }
                }

        } 
        methods[2].access_flags = 0x0001 public
        methods[2].name_index = 0x001d , #29 = Utf8 setxNum
        methods[2].descriptor_index = 0x001e , #30 = Utf8 (I)V
        methods[2].attributes_count = 0x0001
        methods[2].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
        methods[2].attribute_info[0].info_length = 0x0000003e ,62字节长度
        methods[2].attribute_info[0].code = {
                max_stack = 0x0002,2
                max_locals = 0x0002,2
                code_length = 0x00000006,
                code_data {
			2a : aload_0 
			1b : iload_1 
			b5 [00 04] : putfield #4 = Fieldref #5.#38 // com/sandro/bytecode/Test2.xNum:I
			b1 : return
			
                exception_table_length= 0x0000
                attributes_count = 0x0002
                attribute_info[0] = {
                        attribute_index=0x0014,#20 = Utf8 LineNumberTable
                        LineNumberTable{
                                length=0x0000000a
                                tableinfo=00 02 00 00 00 11 00 05 00 12
                                table_count=0x0002
                                table[0].start_pc=0x0000
                                table[0].line_number=0x0011
                                table[1].start_pc=0x0005
                                table[1].line_number=0x0012
                        }               
                }
                attribute_info[1] = {
                        attribute_index=0x0015,#21 = Utf8 LocalVariableTable
                        LocalVariableTable{
                                length=0x00000016
                                tableinfo= 00 02    00 00 00 06 00 16 00 17 00 00     00  00 00 06 00 1f 00 0e 00 01
                                count = 0x0002
				table[0] = {
                                	start = 0x0000
                                	length = 0x0006
                                	name_index = 0x0016, #22 = Utf8 this
                                	desc_index = 0x0017, #23 = Utf8 Lcom/sandro/bytecode/Test2;
                                	校验检查位 = 0x0000
				}
                                table[1] = {
                                        start = 0x0000
                                        length = 0x0006
                                        name_index = 0x001f, #31 = Utf8 x
                                        desc_index = 0x000e, #14 = Utf8 I
                                        校验检查位 = 0x0001
                                }

                        }
                }

        }
        methods[3].access_flags = 0x0008 static代码块
        methods[3].name_index = 0x0020 , #32 = Utf8 <clinit> ，
			        在这个代码块中对静态变量进行赋值
				如果有多个static代码块，和多个静态变量，字节码实际上会统一合并到一起，放到<clinit>这个方法中去按照代码顺序执行
        methods[3].descriptor_index = 0x0012 , #18 = Utf8 ()V
        methods[3].attributes_count = 0x0001
        methods[3].attribute_info[0].attribute_name_index = 0x0013,  #19 = Utf8               Code
        methods[3].attribute_info[0].info_length = 0x00000021 ,33字节长度
        methods[3].attribute_info[0].code = {
                max_stack = 0x0001,1
                max_locals = 0x0000,01
                code_length = 0x00000009,
                code_data {
			10 [0a]:bigbush 10 
			b8 [00 08] invokestatic  #8=Methodref  #41.#42 // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
			b3 [00 09] putstatatic  #9=Fieldref    #5.#43  // com/sandro/bytecode/Test2.inNum:Ljava/lang/Integer;
			b1 : return
			
                exception_table_length= 0x0000
                attributes_count = 0x0001
                attribute_info[0] = {
                        attribute_index=0x0014,#20 = Utf8 LineNumberTable
                        LineNumberTable{
                                length=0x00000006
                                tableinfo=00 01 00 00 00 08
                                table_count=0x0001
                                table[0].start_pc=0x0000
                                table[0].line_number=0x0008
                        }               
                }
                
        }
	00 01 00 21 00 00 00 02  00 22
	class_attribute.count = 0x0001
	class_attribute.index = 0x0021, #33 = Utf8  SourceFile
	class_attribute.len = 0x000002
	sourcefile_index = 0x0022, #34 = Utf8               Test2.java


36、synchronized关键字
	project/jvm_lecture项目 com.sandro.bytecode.Test3
	
	-synchronized修饰实例方法
	 反编译后普通方法和synchronized方法：

	  private void setData();
	    descriptor: ()V
	    flags: ACC_PRIVATE
	    Code:
	      stack=0, locals=1, args_size=1
	         0: return
	      LineNumberTable:
	        line 6: 0
	      LocalVariableTable:
	        Start  Length  Slot  Name   Signature
	            0       1     0  this   Lcom/sandro/bytecode/Test3;

	  private synchronized void setData2();
	    descriptor: ()V
	    flags: ACC_PRIVATE, ACC_SYNCHRONIZED
	    Code:
	      stack=0, locals=1, args_size=1
	         0: return
	      LineNumberTable:
	        line 10: 0
	      LocalVariableTable:
	        Start  Length  Slot  Name   Signature
	            0       1     0  this   Lcom/sandro/bytecode/Test3;
	
	 这两个方法的区别就在flags上，synchronized方法会在flags上增加一个ACC_SYNCHRONIZED标志，其他都一样
	 原因是当synchronized修饰在一个实例方法上的时候，在code中其是已经隐含了使用moniterenter  和 moniterexit 即加锁和释放锁的指令了
	
	-使用syncronized修饰变量
	  private void test();
	     descriptor: ()V
	     flags: ACC_PRIVATE
	     Code:
	       stack=2, locals=3, args_size=1
	          0: aload_0
 	          1: getfield      #3                  // Field lockObj:Ljava/lang/Object;
	          4: dup
	          5: astore_1
	          6: monitorenter
	          7: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
	         10: aload_0
	         11: getfield      #3                  // Field lockObj:Ljava/lang/Object;
	         14: invokevirtual #5                  // Method java/lang/Object.hashCode:()I
	         17: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
	         20: aload_1
	         21: monitorexit
	         22: goto          30
	         25: astore_2
	         26: aload_1
	         27: monitorexit
	         28: aload_2
	         29: athrow
	         30: return
	       Exception table:
	          from    to  target type
	              7    22    25   any
	             25    28    25   any
	       LineNumberTable:
	         line 14: 0
	         line 15: 7
	         line 16: 20
	         line 17: 30
	       LocalVariableTable:
	         Start  Length  Slot  Name   Signature
	             0      31     0  this   Lcom/sandro/bytecode/Test3;
	       StackMapTable: number_of_entries = 2
	         frame_type = 255 /* full_frame */
	           offset_delta = 25
	           locals = [ class com/sandro/bytecode/Test3, class java/lang/Object ]
	           stack = [ class java/lang/Throwable ]
	         frame_type = 250 /* chop */
	           offset_delta = 4
	 
	 由于是在方法内使用synchronized修饰变量 ，可以在code中看到 monitorenter 和 moniterexit 来上锁和释放锁的指令
	 从25行开始，虚拟机又增加了异常处理，保证当System.out.println出现异常后依然能够调用moniterexit保证锁的释放
	 
	-synchronized修饰静态方法
	   private static synchronized void test2();
	     descriptor: ()V
	     flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNCHRONIZED
	     Code:
	       stack=0, locals=0, args_size=0
	          0: return
	       LineNumberTable:
	         line 21: 0
	 对于静态同步方法，在code中依然没有moniterenter和moniterexit，此时上锁实际上是放在的当前类上，此时锁标记位值已经为1了，相当于隐含的使用了上锁和释放锁的操作了
	 
37、异常表的作用和this关键字在方法中的原理
	java字节码对于异常的处理方式：
		-统一采用异常表的方式对异常进行处理。
		-在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，二是采用特定的指令的方式
		-当异常处理存在finally语句块时，现代化的jvm采取的处理方式是将finally块的字节码拼接到每一个catch块后面
		 换句话说程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码
	
	project/jvm_lecture项目 com.sandro.bytecode.Test4
	反编译后test方法的code部分如下：
	  public void test();
	    descriptor: ()V
	    flags: ACC_PUBLIC
	    Code:
	      stack=3,             //java对于方法调用是基于栈的操作，这里指运行时刻，最深的栈深度是3
	      locals=4,            //局部变量是4，this,is,sc,第四个局部变量是三个catch中的一个Excetpion，因为catch中的异常只能进入一个。这里的locals是最多的局部变量数，所以是4
	      args_size=1          //对于非静态方法（实例方法）第一个参数默认会把this当作参数传递该给方法，所以args_size是1
			           //这个操作是由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问，接下来在运行期间由jvm在调用实例方法时，自动传入该this
	         0: new           #2                  // class java/io/FileInputStream
	         3: dup
	         4: ldc           #3                  // String aaa.txt
	         6: invokespecial #4                  // Method java/io/FileInputStream."<init>":(Ljava/lang/String;)V
	         9: astore_1      将实例引用存储到了一个局部变量中去
	        10: aload_1
	        11: invokevirtual #5                  // Method java/io/InputStream.close:()V
	        14: new           #6                  // class java/net/ServerSocket
	        17: dup
	        18: sipush        9999
	        21: invokespecial #7                  // Method java/net/ServerSocket."<init>":(I)V
	        24: astore_2
	        25: aload_2
	        26: invokevirtual #8                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket;
	        29: pop
	        30: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
						      // 这里因为cathch中没有代码，所以直接列出的是finally中的代码，如果有catch则会列处catch中的字节码指令
	        33: ldc           #10                 // String finally
	        35: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        38: goto          88
	        41: astore_1
	        42: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        45: ldc           #10                 // String finally
	        47: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        50: goto          88
	        53: astore_1
	        54: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        57: ldc           #10                 // String finally
	        59: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        62: goto          88
	        65: astore_1
	        66: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        69: ldc           #10                 // String finally
	        71: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        74: goto          88
	        77: astore_3
	        78: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
	        81: ldc           #10                 // String finally
	        83: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
	        86: aload_3
	        87: athrow
	        88: return
	      Exception table:
	         from    to  target type
	             0    30    41   Class java/io/FileNotFoundException//从0到29行中，如果捕获FileFoundException则转到41行处理，从41开始由于catch中没有代码实际上就执行finally了
									//41行处实际上是 FileNotFoundException ex这句话
				                                        //然后在50行处goto到了return处 
	             0    30    53   Class java/io/IOException
	             0    30    65   Class java/lang/Exception
	             0    30    77   //any ,any就是0，如果上面3个异常都没有捕获则由0号也就是any来处理异常
                                     //这部分助记符是编译器自动加上去的
	      LineNumberTable:
	        line 12: 0
	        line 13: 10
	        line 14: 14
	        line 15: 25
	        line 21: 30
	        line 22: 38
	        line 17: 41
	        line 21: 42
	        line 22: 50
	        line 18: 53
	        line 21: 54
	        line 22: 62
	        line 19: 65
	        line 21: 66
	        line 22: 74
	        line 21: 77
	        line 22: 86
	        line 23: 88
	      LocalVariableTable: //局部变量表中 由于在编译期并不知道哪个异常会被捕获，所以只列出了其他的局部变量
	        Start  Length  Slot  Name   Signature
	           10      20     1    is   Ljava/io/InputStream;
	           25       5     2    sc   Ljava/net/ServerSocket;
	            0      89     0  this   Lcom/sandro/bytecode/Test4;
	      StackMapTable: number_of_entries = 5 //1.7之后引用的校验表，对于数据类型的校验上提供了更强的性能
	        frame_type = 105 /* same_locals_1_stack_item */
	          stack = [ class java/io/FileNotFoundException ]
	        frame_type = 75 /* same_locals_1_stack_item */
	          stack = [ class java/io/IOException ]
	        frame_type = 75 /* same_locals_1_stack_item */
	          stack = [ class java/lang/Exception ]
	        frame_type = 75 /* same_locals_1_stack_item */
	          stack = [ class java/lang/Throwable ]
	        frame_type = 10 /* same */
	
38、方法声明抛出的异常声明字节码
	project/jvm_lecture项目 com.sandro.bytecode.Test5
	案例中异常是声明在方法声明中的，此时这部分信息是jvm在方法中和code并列处增加了一个异常表保存信息
            public void test() throws java.io.IOException, java.lang.ExceptionInInitializerError;
               descriptor: ()V
               flags: ACC_PUBLIC
               Code:
                 ...
                 LineNumberTable:
                   ...
                 LocalVariableTable:
                   Start  Length  Slot  Name   Signature
                   ...
               Exceptions: //
                 throws java.io.IOException, java.lang.ExceptionInInitializerError

39、栈帧(statck frame)与操作数栈 以及 符号引用与直接引用

	栈帧：
		栈帧是一种用于帮助虚拟机执行方法调用和方法执行的数据结构
		栈帧本是一种数据结构，封装了方法的局部变量表，动态链接信息，方法的返回地址以及操作数栈等信息。 	
	
	符号引用和直接引用：
		和c++不同，由于在编译期间相互依赖的类之间是不知道对方的地址的，只有在运行时刻类加载并调用的时候才能知道，因此jvm使用了符号引用和直接引用
		符号引用，比如在常量池中，一个类会维护被调用的另一个类的全局唯一限定名
		在运行时刻会把符号引用转换为直接引用类似指针的内存地址，通过这种方式调用到其他类的方法或属性，这也是java的动态链接的能力
	
	静态解析和动态链接：
		有些符号引用会在类加载期间或者第一次使用的时候就会转换成直接引用，这种转换就叫做静态解析
		有些符号引用则是在每次运行期间转换为直接引用，这种转换叫做动态链接，这体现为java的多态性。
			Animal a = new Cat();
			a.sleep();
			a = new Dog();
			a.sleep();
			a = new Tiger();
			a.sleep();	
		比如这个代码中 ，编译期间a都是调用Animal的sleep(通过invokevirtual 指向父类的sleep)，只有在运行期间才会知道sleep才知道具体是哪个实例的sleep
	
	操作栈：

                       出栈 <-------+     ++--------入栈
		                    |     ↓  
				|______________|
                  		| stackframe3  |
                                |______________|
                                | stackframe2  |
                                |______________|  
                                | stackframe1  |
                                |______________|
		
		比如 ：3-2这个操作
		     1、把3压栈
		     2、把2压栈
		     3、开始执行减法操作
		     4、执行两次栈顶元素的弹出操作并保存在寄存器中，
		     5、在寄存器中执行减法
		     6、把结果再压栈保存到栈中，此时栈中只有一个元素就是结果1。
	
	局部变量表和slot
		slot是局部变量表的最小单位，比如long会用两个连续的slot保存，int,short只用一个slot保存
	        slot可以复用，比如方法体中的局部变量作用域是不同的
			例子：public void test(){
				int a = 1;
				if(a==1){
					int b = 2;
					int c = 3;
				}
				int d = 4;
				int e = 5;
			}
		在这个例子中 b和c这两个变量在 if作用域结束后就不再使用了，但是在局部变量表中b和c使用的slot是可能复用给d和e继续使用的。
		因此比如在一个方法中有10个int变量，实际上只用到了小与10个的slot，也可以能使用了10个slot。

	
40、jvm方法的的调用指令

	5种方法调用的指令：
		-invokeinterface:调用接口，调用接口中的方法，实际上是在运行期决定到底调用实现该接口的哪个对象的方法。
		-invokestatic:调用静态方法。
		-invokespecial:调用自己的私有方法、构造方法(<init>)以及父类的方法。
		-invokevirtual:调用虚方法，运行期动态查找的过程。
		-invokedynamic:1.7增加的，动态调用方法（比如动态语言javascript）。这种调用是最复杂的。
	
	project/jvm_lecture项目 com.sandro.bytecode.Test6
	案例分析，例子中的main方法code如下：
	     public static void main(java.lang.String[]);
	       Code:
	         stack=0, locals=1, args_size=1
	            0: invokestatic  #5                  // Method test:()V
				     调用的是当前类的静态法方法，所以用的是invokestatic
	            3: return
		
	静态解析:能被invokestatic和invokespecial调用的方法都是在解析阶段就能确定调用过程的。
		-父类方法
		-静态方法
		-私有方法:公有方法可能会被重写，就有可能出现多态的情况，私有方法则不会被重写，因此是可以确定的
		-当前类的构造方法
	 	这4类方法就成为非虚方法，他们是在类加载阶段就可以将符号引用转换成直接引用
	

41、方法重载与invokevitural字节码指令关系	
	project/jvm_lecture项目 com.sandro.bytecode.Test7	
	
	方法的静态分派:
		案例中 Grandpa g1 = new Father();
		g1的静态类型是Grandpa，而个g1的实际类型(真正指向的类型)是Father.
		变量的静态类型是不会变化的，而变量的实际类型根据代码的走向是有可能变化的(多态的一种体现)，实际类型是在运行期才能确定

	方法的重载：
		在方法的重载对于jvm来说是一种静态行为，重载方法的参数是根据静态参数来确定到底是调用哪个版本的方法
		比如 Test7.test(Grandpa  g),不管参数的实际类型是什么，对于test方法来说只认传参时参数的静态类型
		这种静态行为在编译器就可以完全确定的

	main方法的字节码：
	        public static void main(java.lang.String[]);
	          descriptor: ([Ljava/lang/String;)V
	          flags: ACC_PUBLIC, ACC_STATIC
	          Code:
	            stack=2, locals=4, args_size=1
	               0: new           #7                  // class com/sandro/bytecode/Father
	               3: dup
	               4: invokespecial #8                  // Method com/sandro/bytecode/Father."<init>":()V
	               7: astore_1
	               8: new           #9                  // class com/sandro/bytecode/Son
	              11: dup
	              12: invokespecial #10                 // Method com/sandro/bytecode/Son."<init>":()V
	              15: astore_2
	              16: new           #11                 // class com/sandro/bytecode/Test7
	              19: dup
	              20: invokespecial #12                 // Method "<init>":()V
	              23: astore_3
	              24: aload_3
	              25: aload_1
	              26: invokevirtual #13                 // Method test:(Lcom/sandro/bytecode/Grandpa;)V
	              29: aload_3
	              30: aload_2
	              31: invokevirtual #13                 // Method test:(Lcom/sandro/bytecode/Grandpa;)V
	              34: return
		
		26 31行 调用了test方法 使用的是invokevitrual指令

