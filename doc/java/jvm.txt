1、书籍和名人
	国内比较有名的人叫R大，比叫资深的java虚拟机专家，《深入理解java虚拟机》比较早期的书籍，比较经典
2、常用jvm工具
	jconsole:JDK自带的 jvm监控工具，通过jconsole可以查看各进程的 内存，线程,cpu等运行信息
	jvisualvm:oracle自带的集成工具，类似jconsole工具，功能更全面
	jmap:java命令行工具，能够打印给定的java进程，核心文件内存信息，jmap可能在未来的JDK版本中删除
	
3、类加载器的深入理解与阶段分析
	3.1)类加载：class loading
	在java代码中，类型(class , interface ,枚举等)的加载、连接与初始化过程都是在程序运行期间完成的
	类加载提供了更大的灵活性，增加了更多的可能性，所以java虽然是静态的开发语言，但是依然能够完成动态语言的功能
	类型的加载最常见的方式将类文件从磁盘上加载到内存中去。

	3.2)类加载器(class loader):java中的每一个类型最终都会进入到内存当中，类加载器就是用来做这个工作的

	3.3)java虚拟机(程序)的生命周期，在如下几种情况下，java虚拟机将结束声明周期
		执行了System.exit()方法
		程序正常结束
		程序在执行过程中遇到了异常或者错误而异常终止，比如异常没有catch，那么当前异常会一直向上抛出，直到main方法。
		由于系统错误而导致java虚拟机进程终止
	
	3.4)类的加载、连接、与初始化
		加载：查找并加载类的二进制数据
		连接：
	             a)验证，确保被加载的类的正确性，避免二进制文件被恶意修改
		     b)准备，为类的静态变量分配内存，并将其初始化为默认值，注意在这个阶段，静态变量即使在代码中有赋值，但是这个阶段还只是默认值
		     c)解析，把类中的符号引用转换为直接引用
		           符号引用是一种间接的引用，比如System.out.println("aaa"),System out println这三部分就是符号引用，这个符号引用会被存贮在当前类的常量池中
			   在解析阶段虚拟机会把这个符号引用转化为直接引用，指向实际的内存地址
			   这个过程包括查找System类，out子段，println方法以及确定方法的参数和返回值等步骤
			   最终System.out.println("aaa")会被解析成一个指向实际输出流对象的地址，使得程序能够正常执行
		初始化：为类的静态变量赋予正确的初始值(在连接的准备阶段，静态变量只会被赋予默认值)
 	
	3.5)类的使用和卸载
		使用：类的字节码文件加载到内存后，就可以使用了
		卸载：类加载到内存后，是可以销毁的，销毁后的类就不能再使用了，比如不能再实例化对象等
		      比如osgi技术会动态卸载类
	
	3.6) java程序对类的使用方式分为：
		主动使用(7种):
			创建类的实例
			访问某个类或接口的静态变量(getstatic 助记符号)，或者对该静态变量赋值(putstatic 助记符)
			调用类的静态方法（invoke助记符）
			反射
			初始化一个类的子类,子类被初始化的时候，父类也会被初始化
			java虚拟机启动时被标明为启动类的类（有main方法的类）
			JDK1.7开始提供的动态语言支持(比如javascrpt)：java.lang.invoke.MethodHandle实例的解析结果 _getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则立刻初始化
		被动使用:
			除了以上7中主动使用，其他使用java类的方式都被当作是对类的被动使用，都不会导致类的初始化
	     所有的java虚拟机实现必须在每个类或接口被java程序“首次主动使用”时，才初始化他们。

	3.7）类的加载
		类的加载指的是将类的.class文件中二进制数据读如到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构
		规范中并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中
		
		加载.class文件的方式:
			从本地系统(磁盘)中直接加载
			通过网络下载.class文件
			从zip,jar等归档文件中加载.class文件
			从专有数据库中提取.class文件
			将java源文件动态编译为.class文件，比如动态代理(动态代理在编译器是不存在这个类的，只有在运行期在存在) jsp文件(jsp文件中可以嵌入java代码，jsp最终会转化为servlet)
	3.8) 类加载例子：
		源码见 project/jvm_lecture项目 com.sandro.classloader.Test1，com.sandro.classloader.Test2
		对于静态字段来说，只有直接定义了这个字段的类在首次主动使用的时候才会初始化，通过子类调用父类的静态字段，子类不会在首次主动使用的时候初始化
		
			
		
	
	
	


