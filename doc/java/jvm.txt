1、书籍和名人
	国内比较有名的人叫R大，比叫资深的java虚拟机专家，《深入理解java虚拟机》比较早期的书籍，比较经典
2、常用jvm工具
	jconsole:JDK自带的 jvm监控工具，通过jconsole可以查看各进程的 内存，线程,cpu等运行信息
	jvisualvm:oracle自带的集成工具，类似jconsole工具，功能更全面
	jmap:java命令行工具，能够打印给定的java进程，核心文件内存信息，jmap可能在未来的JDK版本中删除
	
3、类加载器的深入理解与阶段分析
	3.1)类加载：class loading
	在java代码中，类型(class , interface ,枚举等)的加载、连接与初始化过程都是在程序运行期间完成的
	类加载提供了更大的灵活性，增加了更多的可能性，所以java虽然是静态的开发语言，但是依然能够完成动态语言的功能
	类型的加载最常见的方式将类文件从磁盘上加载到内存中去。

	3.2)类加载器(class loader):java中的每一个类型最终都会进入到内存当中，类加载器就是用来做这个工作的

	3.3)java虚拟机(程序)的生命周期，在如下几种情况下，java虚拟机将结束声明周期
		执行了System.exit()方法
		程序正常结束
		程序在执行过程中遇到了异常或者错误而异常终止，比如异常没有catch，那么当前异常会一直向上抛出，直到main方法。
		由于系统错误而导致java虚拟机进程终止
	
	3.4)类的加载、连接、与初始化
		加载：查找并加载类的二进制数据
		连接：
	             a)验证，确保被加载的类的正确性，避免二进制文件被恶意修改
		     b)准备，为类的静态变量分配内存，并将其初始化为默认值，注意在这个阶段，静态变量即使在代码中有赋值，但是这个阶段还只是默认值
		     c)解析，把类中的符号引用转换为直接引用
		           符号引用是一种间接的引用，比如System.out.println("aaa"),System out println这三部分就是符号引用，这个符号引用会被存贮在当前类的常量池中
			   在解析阶段虚拟机会把这个符号引用转化为直接引用，指向实际的内存地址
			   这个过程包括查找System类，out子段，println方法以及确定方法的参数和返回值等步骤
			   最终System.out.println("aaa")会被解析成一个指向实际输出流对象的地址，使得程序能够正常执行
		初始化：为类的静态变量赋予正确的初始值(在连接的准备阶段，静态变量只会被赋予默认值)
 	
	3.5)类的使用和卸载
		使用：类的字节码文件加载到内存后，就可以使用了
		卸载：类加载到内存后，是可以销毁的，销毁后的类就不能再使用了，比如不能再实例化对象等
		      比如osgi技术会动态卸载类
	
	3.6) java程序对类的使用方式分为：
		主动使用(7种):
			创建类的实例
			访问某个类或接口的静态变量(getstatic 助记符号)，或者对该静态变量赋值(putstatic 助记符)
			调用类的静态方法（invoke助记符）
			反射
			初始化一个类的子类,子类被初始化的时候，父类也会被初始化
			java虚拟机启动时被标明为启动类的类（有main方法的类）
			JDK1.7开始提供的动态语言支持(比如javascrpt)：java.lang.invoke.MethodHandle实例的解析结果 _getStatic,REF_putStatic,REF_invokeStatic句柄对应的类没有初始化，则立刻初始化
		被动使用:
			除了以上7中主动使用，其他使用java类的方式都被当作是对类的被动使用，都不会导致类的初始化
	     所有的java虚拟机实现必须在每个类或接口被java程序“首次主动使用”时，才初始化他们。

	3.7）类的加载
		类的加载指的是将类的.class文件中二进制数据读如到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象用来封装类在方法区内的数据结构
		规范中并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中
		
		加载.class文件的方式:
			从本地系统(磁盘)中直接加载
			通过网络下载.class文件
			从zip,jar等归档文件中加载.class文件
			从专有数据库中提取.class文件
			将java源文件动态编译为.class文件，比如动态代理(动态代理在编译器是不存在这个类的，只有在运行期在存在) jsp文件(jsp文件中可以嵌入java代码，jsp最终会转化为servlet)
	3.8) 类加载例子：
		源码见 project/jvm_lecture项目 com.sandro.classloader.Test1，com.sandro.classloader.Test2，com.sandro.classloader.Test3
		对于静态字段来说，只有直接定义了这个字段的类在首次主动使用的时候才会初始化，通过子类调用父类的静态字段，子类不会在首次主动使用的时候初始化
	
	        -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来
 	        比如在class根目录中运行:
	        ..../jvm_lecture/out/production/jvm_lecture$ java -XX:+TraceClassLoading com.sandro.classloader.Test1	
	   	
  	        输出如下：
			..... //jdk的一些类
			[Loaded com.sandro.classloader.Test1 from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]//进程主类
			.....//jdk的一些类
			[Loaded com.sandro.classloader.Test1$Parent from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
			[Loaded com.sandro.classloader.Test1$Child from file:/home/sandro/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture/]
   	
5、jvm参数
	一般jvm参数都是已 -XX:开头的
	一般写法有如下几种：
	5.1）布尔类型的设置
		-XX:+<option> ,表示开启 <option>选项，比如：java -XX:+TraceClassLoading com.xxx.xxx.MainClass
		-XX:-<option> ,表示关闭 <option>选项，jvm有些选项是默认开启的，如果在启动某个进程时候不想用某个已经开启的选项，可以通过"-"关闭
	5.2）赋值设置
		-XX:<option>=<value> 表示将option选项的值设置为value,如：-XX:SurvivorRatio=8,表示eden区与survivior区大小比例为8比1
	
4、常量的本质含义与反编译及助记符详解
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test3
	final修饰的字符串是常量，在编译阶段这个常量就已经保存在调用这个常量的方法所在类的常量池中了
			
	通过 javap -c com.sandro.classloader.Test3反编译
	如下：
		sandro@sandro-Lenovo-XiaoXin-V4000:~/mywork/gitwork/sandro/project/jvm_lecture/out/production/jvm_lecture$ javap -c com.sandro.classloader.Test3
		Compiled from "Test3.java"
		public class com.sandro.classloader.Test3 {
  			public com.sandro.classloader.Test3();
    				Code:
       					0: aload_0
       					1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       					4: return

  			public static void main(java.lang.String[]);
    				Code:
       					0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       					3: ldc           #4                  // String hello world
       					5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       					8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					11: bipush        567
      					13: invokevirtual #6                  // Method java/io/PrintStream.println:(I)V
      					16: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
      					19: new           #7                  // class java/lang/StringBuilder
      					22: dup
      					23: invokespecial #8                  // Method java/lang/StringBuilder."<init>":()V
      					26: ldc           #9                  // String list size is
      					28: invokevirtual #10                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      					31: getstatic     #11                 // Field com/sandro/classloader/Test3$Parent.list:Ljava/util/List;
      					34: invokeinterface #12,  1           // InterfaceMethod java/util/List.size:()I
      					39: invokevirtual #13                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      					42: invokevirtual #14                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      					45: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      					48: return

		}

	助记符：
	ldc : 表示将int,float 或者 String类型的常量值从常量池中推送置栈顶	
	bipush:表示将单字节(-128~127)的常量推送置栈顶，从测试结果看567也用的是bipush，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	sipush:表示将一个短整形常量值（-32768~32767）推送到栈顶，可能和cpu是64位有关也可能根虚拟机版本等有关系，这个范围不是固定的
	iconst_1:表示将int类型的数字1推送置栈顶，最多到iconst_5,也就是说jvm对int类型 -1～5单独设置了助记符, -1对应的助记符iconst_m1
	助记符的实现在rt.jar中，都有相应的源码可以查看，比如ldc bipush等就在com.sun.org.apache.bcel.internal.generic包下

5、编译期常量与运行期常量的区别
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test4 
	当一个常量的值如果不能在编译期间确定，那么其值就不会被放到调用类的常量池中
	这时在运行程序时，会导致主动使用这个常量所在的类，这个类就肯定会被初始化
	
6、数组创建本质分析
	源码见 project/jvm_lecture项目 com.sandro.classloader.Test5
	对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为[Lcom.xxx.xxx
	动态生成的类型其父类是Object
	对于数组来说，JavaDoc经常构成数组的元素为Component，实际上就是将数组降低一个维度后的类型。
	助记符：
		anewarray，表示创建一个引用类型的（如类，接口，数组）数组，并将其引用值压入栈顶
		newarray,表示创建一个指定的原始类型（如：int,char,short等）的数组，并将其引用压入栈顶
	
	


